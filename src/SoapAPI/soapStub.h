/* soapStub.h
   Generated by gSOAP 2.8.1 from Betfair.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL OR Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://www.betfair.com/publicapi/types/global/v3/"
#define SOAP_NAMESPACE_OF_ns2	"http://www.betfair.com/publicapi/v3/BFGlobalService/"
#define SOAP_NAMESPACE_OF_ns3	"http://www.betfair.com/publicapi/types/exchange/v5/"
#define SOAP_NAMESPACE_OF_ns4	"http://www.betfair.com/publicapi/v5/BFExchangeService/"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__APIErrorEnum
#define SOAP_TYPE_ns1__APIErrorEnum (361)
/* ns1:APIErrorEnum */
enum ns1__APIErrorEnum {ns1__APIErrorEnum__OK = 0, ns1__APIErrorEnum__INTERNAL_USCOREERROR = 1, ns1__APIErrorEnum__EXCEEDED_USCORETHROTTLE = 2, ns1__APIErrorEnum__USER_USCORENOT_USCORESUBSCRIBED_USCORETO_USCOREPRODUCT = 3, ns1__APIErrorEnum__SUBSCRIPTION_USCOREINACTIVE_USCOREOR_USCORESUSPENDED = 4, ns1__APIErrorEnum__VENDOR_USCORESOFTWARE_USCOREINACTIVE = 5, ns1__APIErrorEnum__VENDOR_USCORESOFTWARE_USCOREINVALID = 6, ns1__APIErrorEnum__SERVICE_USCORENOT_USCOREAVAILABLE_USCOREIN_USCOREPRODUCT = 7, ns1__APIErrorEnum__NO_USCORESESSION = 8, ns1__APIErrorEnum__TOO_USCOREMANY_USCOREREQUESTS = 9, ns1__APIErrorEnum__PRODUCT_USCOREREQUIRES_USCOREFUNDED_USCOREACCOUNT = 10, ns1__APIErrorEnum__SERVICE_USCORENOT_USCOREAVAILABLE_USCOREFOR_USCORELOGIN_USCORESTATUS = 11};
#endif

#ifndef SOAP_TYPE_ns1__LoginErrorEnum
#define SOAP_TYPE_ns1__LoginErrorEnum (362)
/* ns1:LoginErrorEnum */
enum ns1__LoginErrorEnum {ns1__LoginErrorEnum__OK = 0, ns1__LoginErrorEnum__OK_USCOREMESSAGES = 1, ns1__LoginErrorEnum__FAILED_USCOREMESSAGE = 2, ns1__LoginErrorEnum__INVALID_USCOREUSERNAME_USCOREOR_USCOREPASSWORD = 3, ns1__LoginErrorEnum__USER_USCORENOT_USCOREACCOUNT_USCOREOWNER = 4, ns1__LoginErrorEnum__INVALID_USCOREVENDOR_USCORESOFTWARE_USCOREID = 5, ns1__LoginErrorEnum__INVALID_USCOREPRODUCT = 6, ns1__LoginErrorEnum__INVALID_USCORELOCATION = 7, ns1__LoginErrorEnum__LOGIN_USCOREFAILED_USCOREACCOUNT_USCORELOCKED = 8, ns1__LoginErrorEnum__ACCOUNT_USCORESUSPENDED = 9, ns1__LoginErrorEnum__T_USCOREAND_USCOREC_USCOREACCEPTANCE_USCOREREQUIRED = 10, ns1__LoginErrorEnum__POKER_USCORET_USCOREAND_USCOREC_USCOREACCEPTANCE_USCOREREQUIRED = 11, ns1__LoginErrorEnum__LOGIN_USCOREREQUIRE_USCORETERMS_USCOREAND_USCORECONDITIONS_USCOREACCEPTANCE = 12, ns1__LoginErrorEnum__LOGIN_USCOREUNAUTHORIZED = 13, ns1__LoginErrorEnum__ACCOUNT_USCORECLOSED = 14, ns1__LoginErrorEnum__LOGIN_USCORERESTRICTED_USCORELOCATION = 15, ns1__LoginErrorEnum__API_USCOREERROR = 16};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveLIMBMessageErrorEnum
#define SOAP_TYPE_ns1__RetrieveLIMBMessageErrorEnum (363)
/* ns1:RetrieveLIMBMessageErrorEnum */
enum ns1__RetrieveLIMBMessageErrorEnum {ns1__RetrieveLIMBMessageErrorEnum__OK = 0, ns1__RetrieveLIMBMessageErrorEnum__API_USCOREERROR = 1};
#endif

#ifndef SOAP_TYPE_ns1__PrivacyPolicyChangeResponseEnum
#define SOAP_TYPE_ns1__PrivacyPolicyChangeResponseEnum (364)
/* ns1:PrivacyPolicyChangeResponseEnum */
enum ns1__PrivacyPolicyChangeResponseEnum {ns1__PrivacyPolicyChangeResponseEnum__NO_USCOREREPLY = 0, ns1__PrivacyPolicyChangeResponseEnum__ACCEPT = 1, ns1__PrivacyPolicyChangeResponseEnum__REJECT = 2};
#endif

#ifndef SOAP_TYPE_ns1__LIMBValidationErrorsEnum
#define SOAP_TYPE_ns1__LIMBValidationErrorsEnum (365)
/* ns1:LIMBValidationErrorsEnum */
enum ns1__LIMBValidationErrorsEnum {ns1__LIMBValidationErrorsEnum__INVALID_USCOREDOB = 0, ns1__LIMBValidationErrorsEnum__INVALID_USCOREADDRESS_USCORELINE1 = 1, ns1__LIMBValidationErrorsEnum__INVALID_USCOREADDRESS_USCORELINE2 = 2, ns1__LIMBValidationErrorsEnum__INVALID_USCOREADDRESS_USCORELINE3 = 3, ns1__LIMBValidationErrorsEnum__INVALID_USCORECITY = 4, ns1__LIMBValidationErrorsEnum__INVALID_USCORECOUNTY_USCORESTATE = 5, ns1__LIMBValidationErrorsEnum__INVALID_USCORECOUNTRY_USCOREOF_USCORERESIDENCE = 6, ns1__LIMBValidationErrorsEnum__INVALID_USCOREPOSTCODE = 7, ns1__LIMBValidationErrorsEnum__INVALID_USCOREHOME_USCOREPHONE = 8, ns1__LIMBValidationErrorsEnum__INVALID_USCOREWORK_USCOREPHONE = 9, ns1__LIMBValidationErrorsEnum__INVALID_USCOREMOBILE_USCOREPHONE = 10, ns1__LIMBValidationErrorsEnum__INVALID_USCOREEMAIL = 11, ns1__LIMBValidationErrorsEnum__INVALID_USCOREPASSWORD = 12, ns1__LIMBValidationErrorsEnum__RESERVED_USCOREPASSWORD = 13, ns1__LIMBValidationErrorsEnum__INVALID_USCORENEW_USCOREPASSWORD = 14, ns1__LIMBValidationErrorsEnum__INVALID_USCORETC_USCOREVERSION = 15, ns1__LIMBValidationErrorsEnum__INVALID_USCOREPRIVICY_USCOREVERSION = 16, ns1__LIMBValidationErrorsEnum__INVALID_USCORECHATNAME = 17, ns1__LIMBValidationErrorsEnum__CHATNAME_USCOREALREADY_USCORETAKEN = 18, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCOREADDRESS_USCORELINE_USCORE1 = 19, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCOREADDRESS_USCORELINE_USCORE2 = 20, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCOREADDRESS_USCORELINE_USCORE3 = 21, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCORECITY = 22, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCORECOUNTY_USCORESTATE = 23, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCOREZIP_USCORECODE = 24, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCORECOUNTRY_USCOREOF_USCORERESIDENCE = 25, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCOREPERSONAL_USCOREMESSAGE = 26, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCORETC_USCOREPRIVACY_USCOREPOLICY_USCOREMESSAGE = 27, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCOREPASSWORD_USCORECHANGE_USCOREMESSAGE = 28, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCOREBIRTH_USCOREDATE_USCORECHECK_USCOREMESSAGE = 29, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCOREADDRESS_USCORECHECK_USCOREMESSAGE = 30, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCORECONTACT_USCOREDETAILS_USCORECHECK_USCOREMESSAGE = 31, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCORECHATNAME_USCORECHENGE_USCOREMESSAGE = 32, ns1__LIMBValidationErrorsEnum__NO_USCORESUCH_USCORECARD_USCOREBILLING_USCOREADDRESS_USCORECHECK_USCOREMESSAGE = 33, ns1__LIMBValidationErrorsEnum__INVALID_USCOREPERSONAL_USCOREMESSAGE_USCOREACKNOWLEDGMENT = 34, ns1__LIMBValidationErrorsEnum__INVALID_USCORETC_USCOREPRIVACY_USCOREPOLICY_USCOREMESSAGE_USCOREACKNOWLEDGMENT = 35, ns1__LIMBValidationErrorsEnum__INVALID_USCOREBIRTH_USCOREDATE_USCORECHECK_USCOREMESSAGE = 36, ns1__LIMBValidationErrorsEnum__INVALID_USCOREADDRESS_USCORECHECK_USCOREMESSAGE = 37, ns1__LIMBValidationErrorsEnum__INVALID_USCORECONTACT_USCOREDETAILS_USCORECHECK_USCOREMESSAGE = 38, ns1__LIMBValidationErrorsEnum__INVALID_USCORECARD_USCOREBILLING_USCOREADDRESS_USCORECHECK_USCOREMESSAGE = 39};
#endif

#ifndef SOAP_TYPE_ns1__SubmitLIMBMessageErrorEnum
#define SOAP_TYPE_ns1__SubmitLIMBMessageErrorEnum (366)
/* ns1:SubmitLIMBMessageErrorEnum */
enum ns1__SubmitLIMBMessageErrorEnum {ns1__SubmitLIMBMessageErrorEnum__OK = 0, ns1__SubmitLIMBMessageErrorEnum__VALIDATION_USCOREERRORS = 1, ns1__SubmitLIMBMessageErrorEnum__INVALID_USCOREPASSWORD = 2, ns1__SubmitLIMBMessageErrorEnum__API_USCOREERROR = 3};
#endif

#ifndef SOAP_TYPE_ns1__LogoutErrorEnum
#define SOAP_TYPE_ns1__LogoutErrorEnum (367)
/* ns1:LogoutErrorEnum */
enum ns1__LogoutErrorEnum {ns1__LogoutErrorEnum__OK = 0, ns1__LogoutErrorEnum__API_USCOREERROR = 1};
#endif

#ifndef SOAP_TYPE_ns1__GetEventsErrorEnum
#define SOAP_TYPE_ns1__GetEventsErrorEnum (368)
/* ns1:GetEventsErrorEnum */
enum ns1__GetEventsErrorEnum {ns1__GetEventsErrorEnum__OK = 0, ns1__GetEventsErrorEnum__INVALID_USCOREEVENT_USCOREID = 1, ns1__GetEventsErrorEnum__NO_USCORERESULTS = 2, ns1__GetEventsErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 3, ns1__GetEventsErrorEnum__API_USCOREERROR = 4};
#endif

#ifndef SOAP_TYPE_ns1__MarketTypeEnum
#define SOAP_TYPE_ns1__MarketTypeEnum (369)
/* ns1:MarketTypeEnum */
enum ns1__MarketTypeEnum {ns1__MarketTypeEnum__O = 0, ns1__MarketTypeEnum__L = 1, ns1__MarketTypeEnum__R = 2, ns1__MarketTypeEnum__A = 3, ns1__MarketTypeEnum__NOT_USCOREAPPLICABLE = 4};
#endif

#ifndef SOAP_TYPE_ns1__MarketTypeVariantEnum
#define SOAP_TYPE_ns1__MarketTypeVariantEnum (370)
/* ns1:MarketTypeVariantEnum */
enum ns1__MarketTypeVariantEnum {ns1__MarketTypeVariantEnum__D = 0, ns1__MarketTypeVariantEnum__ASL = 1, ns1__MarketTypeVariantEnum__ADL = 2, ns1__MarketTypeVariantEnum__COUP = 3};
#endif

#ifndef SOAP_TYPE_ns1__MarketStatusEnum
#define SOAP_TYPE_ns1__MarketStatusEnum (371)
/* ns1:MarketStatusEnum */
enum ns1__MarketStatusEnum {ns1__MarketStatusEnum__ACTIVE = 0, ns1__MarketStatusEnum__INACTIVE = 1, ns1__MarketStatusEnum__CLOSED = 2, ns1__MarketStatusEnum__SUSPENDED = 3};
#endif

#ifndef SOAP_TYPE_ns1__BillingPeriodEnum
#define SOAP_TYPE_ns1__BillingPeriodEnum (372)
/* ns1:BillingPeriodEnum */
enum ns1__BillingPeriodEnum {ns1__BillingPeriodEnum__WEEKLY = 0, ns1__BillingPeriodEnum__MONTHLY = 1, ns1__BillingPeriodEnum__QUARTERLY = 2, ns1__BillingPeriodEnum__ANNUALLY = 3};
#endif

#ifndef SOAP_TYPE_ns1__ServiceEnum
#define SOAP_TYPE_ns1__ServiceEnum (373)
/* ns1:ServiceEnum */
enum ns1__ServiceEnum {ns1__ServiceEnum__ADD_USCOREPAYMENT_USCORECARD = 0, ns1__ServiceEnum__DELETE_USCOREPAYMENT_USCORECARD = 1, ns1__ServiceEnum__GET_USCOREPAYMENT_USCORECARD = 2, ns1__ServiceEnum__UPDATE_USCOREPAYMENT_USCORECARD = 3, ns1__ServiceEnum__LOGIN = 4, ns1__ServiceEnum__GET_USCOREBET = 5, ns1__ServiceEnum__PLACE_USCOREBETS = 6, ns1__ServiceEnum__WITHDRAW_USCORETO_USCOREPAYMENT_USCORECARD = 7, ns1__ServiceEnum__EDIT_USCOREBETS = 8, ns1__ServiceEnum__DEPOSIT_USCOREFROM_USCOREPAYMENT_USCORECARD = 9, ns1__ServiceEnum__CANCEL_USCOREBETS = 10, ns1__ServiceEnum__DO_USCOREKEEP_USCOREALIVE = 11, ns1__ServiceEnum__GET_USCOREACCOUNT_USCORESTATEMENT = 12, ns1__ServiceEnum__LOAD_USCOREMARKET_USCOREPROFIT_USCORELOSS = 13, ns1__ServiceEnum__GET_USCORECURRENT_USCOREBETS = 14, ns1__ServiceEnum__LOAD_USCOREACCOUNT_USCOREFUNDS = 15, ns1__ServiceEnum__LOAD_USCOREBET_USCOREHISTORY = 16, ns1__ServiceEnum__LOAD_USCOREDETAILED_USCOREAVAIL_USCOREMKT_USCOREDEPTH = 17, ns1__ServiceEnum__GET_USCOREMARKET_USCORETRADED_USCOREVOLUME = 18, ns1__ServiceEnum__LOAD_USCOREEVENTS = 19, ns1__ServiceEnum__LOAD_USCOREEVENT_USCORETYPES = 20, ns1__ServiceEnum__LOAD_USCOREMARKET = 21, ns1__ServiceEnum__LOAD_USCOREMARKET_USCOREPRICES = 22, ns1__ServiceEnum__LOAD_USCOREMARKET_USCOREPRICES_USCORECOMPRESSED = 23, ns1__ServiceEnum__LOAD_USCORESERVICE_USCOREANNOUNCEMENTS = 24, ns1__ServiceEnum__LOAD_USCORESUBSCRIPTION_USCOREINFO = 25, ns1__ServiceEnum__CREATE_USCOREACCOUNT = 26, ns1__ServiceEnum__CONVERT_USCORECURRENCY = 27, ns1__ServiceEnum__GET_USCORECURRENCIES = 28, ns1__ServiceEnum__FORGOT_USCOREPASSWORD = 29, ns1__ServiceEnum__MODIFY_USCOREPASSWORD = 30, ns1__ServiceEnum__VIEW_USCOREPROFILE = 31, ns1__ServiceEnum__MODIFY_USCOREPROFILE = 32, ns1__ServiceEnum__LOGOUT = 33, ns1__ServiceEnum__RETRIEVE_USCORELIMB_USCOREMESSAGE = 34, ns1__ServiceEnum__SUBMIT_USCORELIMB_USCOREMESSAGE = 35, ns1__ServiceEnum__GET_USCOREMARGIN_USCOREMARKET_USCOREPRICES = 36, ns1__ServiceEnum__GET_USCOREMARGIN_USCOREMARKET_USCOREPRICES_USCORECOMPRESSED = 37, ns1__ServiceEnum__GENERATE_USCOREREGISTERED_USCOREMARGIN_USCOREPRICES = 38, ns1__ServiceEnum__MARGINLOGIN = 39, ns1__ServiceEnum__TRANSFER_USCOREFUNDS = 40, ns1__ServiceEnum__ADD_USCOREVENDORSUBSCRIPTION = 41, ns1__ServiceEnum__UPDATE_USCOREVENDORSUBSCRIPTION = 42, ns1__ServiceEnum__CANCEL_USCOREVENDORSUBSCRIPTION = 43, ns1__ServiceEnum__GET_USCOREVENDOR_USCOREUSERS = 44, ns1__ServiceEnum__GET_USCOREVENDORSUBSCRIPTION_USCOREINFO = 45, ns1__ServiceEnum__GET_USCOREVENDOR_USCOREINFO = 46};
#endif

#ifndef SOAP_TYPE_ns1__SubscriptionStatusEnum
#define SOAP_TYPE_ns1__SubscriptionStatusEnum (374)
/* ns1:SubscriptionStatusEnum */
enum ns1__SubscriptionStatusEnum {ns1__SubscriptionStatusEnum__ACTIVE = 0, ns1__SubscriptionStatusEnum__INACTIVE = 1, ns1__SubscriptionStatusEnum__SUSPENDED = 2};
#endif

#ifndef SOAP_TYPE_ns1__PaymentsErrorEnum
#define SOAP_TYPE_ns1__PaymentsErrorEnum (375)
/* ns1:PaymentsErrorEnum */
enum ns1__PaymentsErrorEnum {ns1__PaymentsErrorEnum__OK = 0, ns1__PaymentsErrorEnum__ACCOUNT_USCORESUSPENDED = 1, ns1__PaymentsErrorEnum__API_USCOREERROR = 2, ns1__PaymentsErrorEnum__CARD_USCOREAMOUNT_USCOREOUTSIDE_USCORELIMIT = 3, ns1__PaymentsErrorEnum__CARD_USCOREEXPIRED = 4, ns1__PaymentsErrorEnum__CARD_USCORELOCKED = 5, ns1__PaymentsErrorEnum__CARD_USCORENOT_USCOREFOUND = 6, ns1__PaymentsErrorEnum__DEPOSIT_USCOREDECLINED = 7, ns1__PaymentsErrorEnum__DEPOSIT_USCORELIMIT_USCOREEXCEEDED = 8, ns1__PaymentsErrorEnum__EXCEEDS_USCOREBALANCE = 9, ns1__PaymentsErrorEnum__CARD_USCORENOT_USCOREVALIDATED = 10, ns1__PaymentsErrorEnum__INVALID_USCOREAMOUNT = 11, ns1__PaymentsErrorEnum__INVALID_USCORECARD_USCORECV2 = 12, ns1__PaymentsErrorEnum__INVALID_USCORECARD_USCOREDETAILS = 13, ns1__PaymentsErrorEnum__INVALID_USCOREEXPIRY_USCOREDATE = 14, ns1__PaymentsErrorEnum__INVALID_USCOREMASTERCARD = 15, ns1__PaymentsErrorEnum__INVALID_USCOREPASSWORD = 16, ns1__PaymentsErrorEnum__CFT_USCOREMAX_USCOREWITHDRAWAL_USCORELIMIT = 17, ns1__PaymentsErrorEnum__NEGATIVE_USCORENET_USCOREDEPOSITS = 18, ns1__PaymentsErrorEnum__NON_USCORESTERLING_USCORETO_USCOREUK_USCOREMASTERCARD = 19, ns1__PaymentsErrorEnum__NON_USCOREZERO_USCORENON_USCORENEG_USCORENET_USCOREDEPOSITS = 20, ns1__PaymentsErrorEnum__UNAUTHORIZED = 21, ns1__PaymentsErrorEnum__VISA_USCOREWITHDRAWAL_USCORENOT_USCOREPOSSIBLE = 22, ns1__PaymentsErrorEnum__DUPLICATE_USCOREWITHDRAWAL = 23, ns1__PaymentsErrorEnum__DEPOSITS_USCORENOT_USCORECLEARED = 24, ns1__PaymentsErrorEnum__INVALID_USCOREBANK_USCOREACCOUNT_USCOREDETAILS_USCOREFIELD = 25, ns1__PaymentsErrorEnum__EXPRESS_USCORETRANSFER_USCORENOT_USCOREAVAILABLE = 26, ns1__PaymentsErrorEnum__UNSUPPORTED_USCORECOUNTRY_USCOREFOR_USCOREBANK_USCORETRANSFER = 27};
#endif

#ifndef SOAP_TYPE_ns1__CardTypeEnum
#define SOAP_TYPE_ns1__CardTypeEnum (376)
/* ns1:CardTypeEnum */
enum ns1__CardTypeEnum {ns1__CardTypeEnum__VISA = 0, ns1__CardTypeEnum__MASTERCARD = 1, ns1__CardTypeEnum__VISADELTA = 2, ns1__CardTypeEnum__SWITCH = 3, ns1__CardTypeEnum__SOLO = 4, ns1__CardTypeEnum__ELECTRON = 5, ns1__CardTypeEnum__LASER = 6, ns1__CardTypeEnum__MAESTRO = 7};
#endif

#ifndef SOAP_TYPE_ns1__AddPaymentCardErrorEnum
#define SOAP_TYPE_ns1__AddPaymentCardErrorEnum (377)
/* ns1:AddPaymentCardErrorEnum */
enum ns1__AddPaymentCardErrorEnum {ns1__AddPaymentCardErrorEnum__OK = 0, ns1__AddPaymentCardErrorEnum__INVALID_USCORECARD_USCOREDETAILS = 1, ns1__AddPaymentCardErrorEnum__INVALID_USCORECARD_USCORECV2 = 2, ns1__AddPaymentCardErrorEnum__INVALID_USCOREPASSWORD = 3, ns1__AddPaymentCardErrorEnum__ACCOUNT_USCOREINACTIVE = 4, ns1__AddPaymentCardErrorEnum__UNAUTHORIZED = 5, ns1__AddPaymentCardErrorEnum__INVALID_USCOREEXPIRY_USCOREDATE = 6, ns1__AddPaymentCardErrorEnum__INVALID_USCORESTART_USCOREDATE = 7, ns1__AddPaymentCardErrorEnum__INVALID_USCORECARD_USCORENUMBER = 8, ns1__AddPaymentCardErrorEnum__INVALID_USCOREZIP_USCORECODE = 9, ns1__AddPaymentCardErrorEnum__INVALID_USCORECOUNTRY_USCORECODE = 10, ns1__AddPaymentCardErrorEnum__INVALID_USCOREBILLING_USCORENAME = 11, ns1__AddPaymentCardErrorEnum__INVALID_USCORECARD_USCOREADDRESS = 12, ns1__AddPaymentCardErrorEnum__CARD_USCOREALREADY_USCOREEXISTS = 13, ns1__AddPaymentCardErrorEnum__AGE_USCOREVERIFICATION_USCOREREQUIRED = 14, ns1__AddPaymentCardErrorEnum__NOT_USCOREFUNDED_USCOREWITH_USCOREFIRST_USCORECARD = 15, ns1__AddPaymentCardErrorEnum__CARD_USCORENOT_USCOREVALID_USCOREFOR_USCOREACCOUNT_USCORECURRENCY = 16, ns1__AddPaymentCardErrorEnum__INVALID_USCORECARD_USCORETYPE = 17, ns1__AddPaymentCardErrorEnum__MAXIMUM_USCORENUMBER_USCOREOF_USCORECARDS_USCOREREACHED = 18, ns1__AddPaymentCardErrorEnum__INVALID_USCOREISSUE_USCORENUMBER = 19, ns1__AddPaymentCardErrorEnum__API_USCOREERROR = 20};
#endif

#ifndef SOAP_TYPE_ns1__DeletePaymentCardErrorEnum
#define SOAP_TYPE_ns1__DeletePaymentCardErrorEnum (378)
/* ns1:DeletePaymentCardErrorEnum */
enum ns1__DeletePaymentCardErrorEnum {ns1__DeletePaymentCardErrorEnum__OK = 0, ns1__DeletePaymentCardErrorEnum__INVALID_USCORECARD_USCOREDETAILS = 1, ns1__DeletePaymentCardErrorEnum__INVALID_USCOREPASSWORD = 2, ns1__DeletePaymentCardErrorEnum__ACCOUNT_USCOREINACTIVE = 3, ns1__DeletePaymentCardErrorEnum__UNAUTHORIZED = 4, ns1__DeletePaymentCardErrorEnum__CARD_USCORENOT_USCOREDELETED = 5, ns1__DeletePaymentCardErrorEnum__API_USCOREERROR = 6};
#endif

#ifndef SOAP_TYPE_ns1__UpdatePaymentCardErrorEnum
#define SOAP_TYPE_ns1__UpdatePaymentCardErrorEnum (379)
/* ns1:UpdatePaymentCardErrorEnum */
enum ns1__UpdatePaymentCardErrorEnum {ns1__UpdatePaymentCardErrorEnum__OK = 0, ns1__UpdatePaymentCardErrorEnum__INVALID_USCORECARD_USCOREDETAILS = 1, ns1__UpdatePaymentCardErrorEnum__INVALID_USCOREPASSWORD = 2, ns1__UpdatePaymentCardErrorEnum__ACCOUNT_USCOREINACTIVE = 3, ns1__UpdatePaymentCardErrorEnum__UNAUTHORIZED = 4, ns1__UpdatePaymentCardErrorEnum__INVALID_USCORECOUNTRY_USCORECODE = 5, ns1__UpdatePaymentCardErrorEnum__INVALID_USCORECARD_USCOREADDRESS = 6, ns1__UpdatePaymentCardErrorEnum__INVALID_USCOREEXPIRY_USCOREDATE = 7, ns1__UpdatePaymentCardErrorEnum__INVALID_USCORESTART_USCOREDATE = 8, ns1__UpdatePaymentCardErrorEnum__INVALID_USCOREZIP_USCORECODE = 9, ns1__UpdatePaymentCardErrorEnum__INVALID_USCOREISSUE_USCORENUMBER = 10, ns1__UpdatePaymentCardErrorEnum__API_USCOREERROR = 11, ns1__UpdatePaymentCardErrorEnum__CARD_USCORENOT_USCOREFOUND = 12};
#endif

#ifndef SOAP_TYPE_ns1__GetPaymentCardErrorEnum
#define SOAP_TYPE_ns1__GetPaymentCardErrorEnum (380)
/* ns1:GetPaymentCardErrorEnum */
enum ns1__GetPaymentCardErrorEnum {ns1__GetPaymentCardErrorEnum__OK = 0, ns1__GetPaymentCardErrorEnum__INVALID_USCOREPASSWORD = 1, ns1__GetPaymentCardErrorEnum__ACCOUNT_USCOREINACTIVE = 2, ns1__GetPaymentCardErrorEnum__UNAUTHORIZED = 3, ns1__GetPaymentCardErrorEnum__API_USCOREERROR = 4};
#endif

#ifndef SOAP_TYPE_ns1__PaymentCardStatusEnum
#define SOAP_TYPE_ns1__PaymentCardStatusEnum (381)
/* ns1:PaymentCardStatusEnum */
enum ns1__PaymentCardStatusEnum {ns1__PaymentCardStatusEnum__LOCKED = 0, ns1__PaymentCardStatusEnum__UNLOCKED = 1};
#endif

#ifndef SOAP_TYPE_ns1__WithdrawByBankTransferModeEnum
#define SOAP_TYPE_ns1__WithdrawByBankTransferModeEnum (382)
/* ns1:WithdrawByBankTransferModeEnum */
enum ns1__WithdrawByBankTransferModeEnum {ns1__WithdrawByBankTransferModeEnum__VALIDATE = 0, ns1__WithdrawByBankTransferModeEnum__EXECUTE = 1};
#endif

#ifndef SOAP_TYPE_ns1__BankAccountDetailsFieldEnum
#define SOAP_TYPE_ns1__BankAccountDetailsFieldEnum (383)
/* ns1:BankAccountDetailsFieldEnum */
enum ns1__BankAccountDetailsFieldEnum {ns1__BankAccountDetailsFieldEnum__PAYEE = 0, ns1__BankAccountDetailsFieldEnum__BANK_USCORELOCATION_USCOREISO3 = 1, ns1__BankAccountDetailsFieldEnum__BANK_USCORENAME = 2, ns1__BankAccountDetailsFieldEnum__ACCOUNT_USCOREHOLDING_USCOREBRANCH = 3, ns1__BankAccountDetailsFieldEnum__ACCOUNT_USCORENUMBER = 4, ns1__BankAccountDetailsFieldEnum__ACCOUNT_USCORETYPE = 5, ns1__BankAccountDetailsFieldEnum__BANK_USCORECODE = 6, ns1__BankAccountDetailsFieldEnum__SORT_USCORECODE = 7, ns1__BankAccountDetailsFieldEnum__BANK_USCOREKEY = 8, ns1__BankAccountDetailsFieldEnum__BRANCH_USCORECODE = 9, ns1__BankAccountDetailsFieldEnum__ROUTING = 10, ns1__BankAccountDetailsFieldEnum__BANK_USCOREBSB = 11, ns1__BankAccountDetailsFieldEnum__BLZ_USCORECODE = 12, ns1__BankAccountDetailsFieldEnum__ABI_USCORECAB = 13, ns1__BankAccountDetailsFieldEnum__BANK_USCOREGIRO_USCORECREDIT_USCORENUMBER = 14};
#endif

#ifndef SOAP_TYPE_ns1__BankAccountTypeEnum
#define SOAP_TYPE_ns1__BankAccountTypeEnum (384)
/* ns1:BankAccountTypeEnum */
enum ns1__BankAccountTypeEnum {ns1__BankAccountTypeEnum__NotSpecified = 0, ns1__BankAccountTypeEnum__CH = 1, ns1__BankAccountTypeEnum__SA = 2, ns1__BankAccountTypeEnum__TR = 3};
#endif

#ifndef SOAP_TYPE_ns1__TransferFundsErrorEnum
#define SOAP_TYPE_ns1__TransferFundsErrorEnum (385)
/* ns1:TransferFundsErrorEnum */
enum ns1__TransferFundsErrorEnum {ns1__TransferFundsErrorEnum__OK = 0, ns1__TransferFundsErrorEnum__INVALID_USCOREAMOUNT = 1, ns1__TransferFundsErrorEnum__TRANSFER_USCOREFAILED = 2, ns1__TransferFundsErrorEnum__OVER_USCOREBALANCE = 3, ns1__TransferFundsErrorEnum__WALLETS_USCOREMUST_USCOREBE_USCOREDIFFERENT = 4, ns1__TransferFundsErrorEnum__SOURCE_USCOREWALLET_USCOREUNKNOWN = 5, ns1__TransferFundsErrorEnum__SOURCE_USCOREWALLET_USCORESUSPENDED = 6, ns1__TransferFundsErrorEnum__SOURCE_USCOREWALLET_USCORESUSPENDED_USCOREKYC = 7, ns1__TransferFundsErrorEnum__SOURCE_USCOREWALLET_USCOREKYC_USCOREWITHDRAWAL = 8, ns1__TransferFundsErrorEnum__SOURCE_USCOREWALLET_USCOREKYC_USCOREDEPOSIT_USCORETOTAL = 9, ns1__TransferFundsErrorEnum__SOURCE_USCOREWALLET_USCOREKYC_USCOREDEPOSIT_USCOREMONTH = 10, ns1__TransferFundsErrorEnum__TARGET_USCOREWALLET_USCOREUNKNOWN = 11, ns1__TransferFundsErrorEnum__TARGET_USCOREWALLET_USCORESUSPENDED = 12, ns1__TransferFundsErrorEnum__TARGET_USCOREWALLET_USCORESUSPENDED_USCOREKYC = 13, ns1__TransferFundsErrorEnum__TARGET_USCOREWALLET_USCOREKYC_USCOREWITHDRAWAL = 14, ns1__TransferFundsErrorEnum__TARGET_USCOREWALLET_USCOREKYC_USCOREDEPOSIT_USCORETOTAL = 15, ns1__TransferFundsErrorEnum__TARGET_USCOREWALLET_USCOREKYC_USCOREDEPOSIT_USCOREMONTH = 16, ns1__TransferFundsErrorEnum__API_USCOREERROR = 17};
#endif

#ifndef SOAP_TYPE_ns1__SelfExcludeErrorEnum
#define SOAP_TYPE_ns1__SelfExcludeErrorEnum (386)
/* ns1:SelfExcludeErrorEnum */
enum ns1__SelfExcludeErrorEnum {ns1__SelfExcludeErrorEnum__OK = 0, ns1__SelfExcludeErrorEnum__ACCOUNT_USCORECLOSED = 1, ns1__SelfExcludeErrorEnum__INVALID_USCOREPASSWORD = 2, ns1__SelfExcludeErrorEnum__INVALID_USCORESELF_USCOREEXCLUDE_USCOREVALUE = 3, ns1__SelfExcludeErrorEnum__API_USCOREERROR = 4};
#endif

#ifndef SOAP_TYPE_ns1__ConvertCurrencyErrorEnum
#define SOAP_TYPE_ns1__ConvertCurrencyErrorEnum (387)
/* ns1:ConvertCurrencyErrorEnum */
enum ns1__ConvertCurrencyErrorEnum {ns1__ConvertCurrencyErrorEnum__OK = 0, ns1__ConvertCurrencyErrorEnum__INVALID_USCOREAMOUNT = 1, ns1__ConvertCurrencyErrorEnum__INVALID_USCOREFROM_USCORECURRENCY = 2, ns1__ConvertCurrencyErrorEnum__INVALID_USCORETO_USCORECURRENCY = 3, ns1__ConvertCurrencyErrorEnum__CANNOT_USCORECONVERT = 4, ns1__ConvertCurrencyErrorEnum__API_USCOREERROR = 5};
#endif

#ifndef SOAP_TYPE_ns1__ViewReferAndEarnErrorEnum
#define SOAP_TYPE_ns1__ViewReferAndEarnErrorEnum (388)
/* ns1:ViewReferAndEarnErrorEnum */
enum ns1__ViewReferAndEarnErrorEnum {ns1__ViewReferAndEarnErrorEnum__OK = 0, ns1__ViewReferAndEarnErrorEnum__NO_USCORERESULTS = 1, ns1__ViewReferAndEarnErrorEnum__API_USCOREERROR = 2};
#endif

#ifndef SOAP_TYPE_ns1__ViewProfileV2ReqVersionEnum
#define SOAP_TYPE_ns1__ViewProfileV2ReqVersionEnum (389)
/* ns1:ViewProfileV2ReqVersionEnum */
enum ns1__ViewProfileV2ReqVersionEnum {ns1__ViewProfileV2ReqVersionEnum__V1 = 0};
#endif

#ifndef SOAP_TYPE_ns1__ViewProfileErrorEnum
#define SOAP_TYPE_ns1__ViewProfileErrorEnum (390)
/* ns1:ViewProfileErrorEnum */
enum ns1__ViewProfileErrorEnum {ns1__ViewProfileErrorEnum__OK = 0, ns1__ViewProfileErrorEnum__UNAUTHORIZED = 1, ns1__ViewProfileErrorEnum__API_USCOREERROR = 2};
#endif

#ifndef SOAP_TYPE_ns1__ModifyProfileErrorEnum
#define SOAP_TYPE_ns1__ModifyProfileErrorEnum (391)
/* ns1:ModifyProfileErrorEnum */
enum ns1__ModifyProfileErrorEnum {ns1__ModifyProfileErrorEnum__OK = 0, ns1__ModifyProfileErrorEnum__VALIDATION_USCOREERRORS = 1, ns1__ModifyProfileErrorEnum__PROFILE_USCOREMODIFICATION_USCOREERROR = 2, ns1__ModifyProfileErrorEnum__UNAUTHORIZED = 3, ns1__ModifyProfileErrorEnum__INVALID_USCOREPASSWORD = 4, ns1__ModifyProfileErrorEnum__ACCOUNT_USCOREINACTIVE = 5, ns1__ModifyProfileErrorEnum__API_USCOREERROR = 6};
#endif

#ifndef SOAP_TYPE_ns1__AccountStatusEnum
#define SOAP_TYPE_ns1__AccountStatusEnum (392)
/* ns1:AccountStatusEnum */
enum ns1__AccountStatusEnum {ns1__AccountStatusEnum__A = 0, ns1__AccountStatusEnum__C = 1, ns1__AccountStatusEnum__D = 2, ns1__AccountStatusEnum__L = 3, ns1__AccountStatusEnum__P = 4, ns1__AccountStatusEnum__S = 5, ns1__AccountStatusEnum__T = 6, ns1__AccountStatusEnum__X = 7, ns1__AccountStatusEnum__Z = 8};
#endif

#ifndef SOAP_TYPE_ns1__CreateAccountErrorEnum
#define SOAP_TYPE_ns1__CreateAccountErrorEnum (393)
/* ns1:CreateAccountErrorEnum */
enum ns1__CreateAccountErrorEnum {ns1__CreateAccountErrorEnum__OK = 0, ns1__CreateAccountErrorEnum__VALIDATION_USCOREERRORS = 1, ns1__CreateAccountErrorEnum__ACCOUNT_USCORECREATION_USCOREERROR = 2, ns1__CreateAccountErrorEnum__API_USCOREERROR = 3};
#endif

#ifndef SOAP_TYPE_ns1__ValidationErrorsEnum
#define SOAP_TYPE_ns1__ValidationErrorsEnum (394)
/* ns1:ValidationErrorsEnum */
enum ns1__ValidationErrorsEnum {ns1__ValidationErrorsEnum__DUPLICATE_USCOREUSERNAME = 0, ns1__ValidationErrorsEnum__FUNDS_USCORETRANSFER_USCORECANCEL = 1, ns1__ValidationErrorsEnum__FUNDS_USCORETRANSFER_USCORECURRENCY_USCOREMISMATCH = 2, ns1__ValidationErrorsEnum__INCOMPLETE_USCOREDETAILS = 3, ns1__ValidationErrorsEnum__INSUFFICIENT_USCOREFUNDS = 4, ns1__ValidationErrorsEnum__INVALID_USCOREACCOUNT_USCORETYPE = 5, ns1__ValidationErrorsEnum__INVALID_USCOREADDRESS_USCORELINE1 = 6, ns1__ValidationErrorsEnum__INVALID_USCOREADDRESS_USCORELINE2 = 7, ns1__ValidationErrorsEnum__INVALID_USCOREADDRESS_USCORELINE3 = 8, ns1__ValidationErrorsEnum__INVALID_USCOREANSWER1 = 9, ns1__ValidationErrorsEnum__INVALID_USCOREANSWER2 = 10, ns1__ValidationErrorsEnum__INVALID_USCOREBROWSER = 11, ns1__ValidationErrorsEnum__INVALID_USCORECITY = 12, ns1__ValidationErrorsEnum__INVALID_USCORECOUNTRY_USCOREOF_USCORERESIDENCE = 13, ns1__ValidationErrorsEnum__INVALID_USCORECOUNTY_USCORESTATE = 14, ns1__ValidationErrorsEnum__INVALID_USCORECURRENCY = 15, ns1__ValidationErrorsEnum__INVALID_USCOREDEPOSIT_USCORELIMIT = 16, ns1__ValidationErrorsEnum__INVALID_USCOREDEPOSIT_USCORELIMIT_USCOREFREQUENCY = 17, ns1__ValidationErrorsEnum__INVALID_USCOREDETAILS = 18, ns1__ValidationErrorsEnum__INVALID_USCOREDOB = 19, ns1__ValidationErrorsEnum__INVALID_USCOREEMAIL = 20, ns1__ValidationErrorsEnum__INVALID_USCOREFIRSTNAME = 21, ns1__ValidationErrorsEnum__INVALID_USCOREGENDER = 22, ns1__ValidationErrorsEnum__INVALID_USCOREHOME_USCOREPHONE = 23, ns1__ValidationErrorsEnum__INVALID_USCOREIP_USCOREADDRESS = 24, ns1__ValidationErrorsEnum__INVALID_USCORELANGUAGE = 25, ns1__ValidationErrorsEnum__INVALID_USCORELOCALE = 26, ns1__ValidationErrorsEnum__INVALID_USCORELOSS_USCORELIMIT = 27, ns1__ValidationErrorsEnum__INVALID_USCORELOSS_USCORELIMIT_USCOREFREQUENCY = 28, ns1__ValidationErrorsEnum__INVALID_USCOREMASTER_USCOREID = 29, ns1__ValidationErrorsEnum__INVALID_USCOREMOBILE_USCOREPHONE = 30, ns1__ValidationErrorsEnum__INVALID_USCOREPARTNERID = 31, ns1__ValidationErrorsEnum__INVALID_USCOREPASSWORD = 32, ns1__ValidationErrorsEnum__INVALID_USCOREPOSTCODE = 33, ns1__ValidationErrorsEnum__INVALID_USCOREPRIVICY_USCOREVERSION = 34, ns1__ValidationErrorsEnum__INVALID_USCOREPRODUCT_USCOREID = 35, ns1__ValidationErrorsEnum__INVALID_USCOREREFERRER_USCORECODE = 36, ns1__ValidationErrorsEnum__INVALID_USCOREREGION = 37, ns1__ValidationErrorsEnum__INVALID_USCORESECURITY_USCOREQUESTION1 = 38, ns1__ValidationErrorsEnum__INVALID_USCORESECURITY_USCOREQUESTION2 = 39, ns1__ValidationErrorsEnum__INVALID_USCORESUBPARTNERID = 40, ns1__ValidationErrorsEnum__INVALID_USCORESUPERPARTNERID = 41, ns1__ValidationErrorsEnum__INVALID_USCORESURNAME = 42, ns1__ValidationErrorsEnum__INVALID_USCORETC_USCOREVERSION = 43, ns1__ValidationErrorsEnum__INVALID_USCORETIMEZONE = 44, ns1__ValidationErrorsEnum__INVALID_USCORETITLE = 45, ns1__ValidationErrorsEnum__INVALID_USCOREUSERNAME = 46, ns1__ValidationErrorsEnum__INVALID_USCOREWORK_USCOREPHONE = 47, ns1__ValidationErrorsEnum__RESERVED_USCOREPASSWORD = 48};
#endif

#ifndef SOAP_TYPE_ns1__AccountTypeEnum
#define SOAP_TYPE_ns1__AccountTypeEnum (395)
/* ns1:AccountTypeEnum */
enum ns1__AccountTypeEnum {ns1__AccountTypeEnum__STANDARD = 0, ns1__AccountTypeEnum__MARGIN = 1, ns1__AccountTypeEnum__TRADING = 2, ns1__AccountTypeEnum__AGENT_USCORECLIENT = 3};
#endif

#ifndef SOAP_TYPE_ns1__GamcareLimitFreqEnum
#define SOAP_TYPE_ns1__GamcareLimitFreqEnum (396)
/* ns1:GamcareLimitFreqEnum */
enum ns1__GamcareLimitFreqEnum {ns1__GamcareLimitFreqEnum__DAILY = 0, ns1__GamcareLimitFreqEnum__WEEKLY = 1, ns1__GamcareLimitFreqEnum__MONTHLY = 2, ns1__GamcareLimitFreqEnum__YEARLY = 3};
#endif

#ifndef SOAP_TYPE_ns1__GenderEnum
#define SOAP_TYPE_ns1__GenderEnum (397)
/* ns1:GenderEnum */
enum ns1__GenderEnum {ns1__GenderEnum__M = 0, ns1__GenderEnum__F = 1, ns1__GenderEnum__UNKNOWN = 2};
#endif

#ifndef SOAP_TYPE_ns1__SecurityQuestion1Enum
#define SOAP_TYPE_ns1__SecurityQuestion1Enum (398)
/* ns1:SecurityQuestion1Enum */
enum ns1__SecurityQuestion1Enum {ns1__SecurityQuestion1Enum__SQ1A = 0, ns1__SecurityQuestion1Enum__SQ1B = 1, ns1__SecurityQuestion1Enum__SQ1C = 2, ns1__SecurityQuestion1Enum__SQ1D = 3};
#endif

#ifndef SOAP_TYPE_ns1__SecurityQuestion2Enum
#define SOAP_TYPE_ns1__SecurityQuestion2Enum (399)
/* ns1:SecurityQuestion2Enum */
enum ns1__SecurityQuestion2Enum {ns1__SecurityQuestion2Enum__SQ2A = 0, ns1__SecurityQuestion2Enum__SQ2B = 1, ns1__SecurityQuestion2Enum__SQ2C = 2, ns1__SecurityQuestion2Enum__SQ2D = 3};
#endif

#ifndef SOAP_TYPE_ns1__RegionEnum
#define SOAP_TYPE_ns1__RegionEnum (400)
/* ns1:RegionEnum */
enum ns1__RegionEnum {ns1__RegionEnum__ZAF = 0, ns1__RegionEnum__NA = 1, ns1__RegionEnum__NORD = 2, ns1__RegionEnum__GBR = 3, ns1__RegionEnum__IRL = 4, ns1__RegionEnum__AUS_USCORENZL = 5};
#endif

#ifndef SOAP_TYPE_ns1__TitleEnum
#define SOAP_TYPE_ns1__TitleEnum (401)
/* ns1:TitleEnum */
enum ns1__TitleEnum {ns1__TitleEnum__Dr = 0, ns1__TitleEnum__Mr = 1, ns1__TitleEnum__Miss = 2, ns1__TitleEnum__Mrs = 3, ns1__TitleEnum__Ms = 4};
#endif

#ifndef SOAP_TYPE_ns1__KYCStatusEnum
#define SOAP_TYPE_ns1__KYCStatusEnum (402)
/* ns1:KYCStatusEnum */
enum ns1__KYCStatusEnum {ns1__KYCStatusEnum__DEFAULT = 0, ns1__KYCStatusEnum__AGE_USCOREVERIFIED = 1, ns1__KYCStatusEnum__KYC = 2, ns1__KYCStatusEnum__KYC_USCORENON_USCOREAUS = 3};
#endif

#ifndef SOAP_TYPE_ns1__ForgotPasswordErrorEnum
#define SOAP_TYPE_ns1__ForgotPasswordErrorEnum (403)
/* ns1:ForgotPasswordErrorEnum */
enum ns1__ForgotPasswordErrorEnum {ns1__ForgotPasswordErrorEnum__OK = 0, ns1__ForgotPasswordErrorEnum__INVALID_USCOREUSERNAME = 1, ns1__ForgotPasswordErrorEnum__INVALID_USCORECOUNTRY_USCOREOF_USCORERESIDENCE = 2, ns1__ForgotPasswordErrorEnum__INVALID_USCOREEMAIL = 3, ns1__ForgotPasswordErrorEnum__INVALID_USCOREANSWER = 4, ns1__ForgotPasswordErrorEnum__INVALID_USCOREPASSWORD = 5, ns1__ForgotPasswordErrorEnum__TOO_USCOREMANY_USCOREATTEMPTS_USCOREACCOUNT_USCORESUSPENDED = 6, ns1__ForgotPasswordErrorEnum__API_USCOREERROR = 7};
#endif

#ifndef SOAP_TYPE_ns1__ModifyPasswordErrorEnum
#define SOAP_TYPE_ns1__ModifyPasswordErrorEnum (404)
/* ns1:ModifyPasswordErrorEnum */
enum ns1__ModifyPasswordErrorEnum {ns1__ModifyPasswordErrorEnum__OK = 0, ns1__ModifyPasswordErrorEnum__INVALID_USCOREPASSWORD = 1, ns1__ModifyPasswordErrorEnum__INVALID_USCORENEW_USCOREPASSWORD = 2, ns1__ModifyPasswordErrorEnum__PASSWORDS_USCOREDONT_USCOREMATCH = 3, ns1__ModifyPasswordErrorEnum__API_USCOREERROR = 4};
#endif

#ifndef SOAP_TYPE_ns1__SetChatNameErrorEnum
#define SOAP_TYPE_ns1__SetChatNameErrorEnum (405)
/* ns1:SetChatNameErrorEnum */
enum ns1__SetChatNameErrorEnum {ns1__SetChatNameErrorEnum__OK = 0, ns1__SetChatNameErrorEnum__INVALID_USCOREPASSWORD = 1, ns1__SetChatNameErrorEnum__ACCOUNT_USCORESUSPENDED = 2, ns1__SetChatNameErrorEnum__ACCOUNT_USCORENOT_USCOREFUNDED = 3, ns1__SetChatNameErrorEnum__CHAT_USCORENAME_USCOREUNAVAILABLE = 4, ns1__SetChatNameErrorEnum__CANNOT_USCORECHANGE_USCORECHAT_USCORENAME = 5, ns1__SetChatNameErrorEnum__API_USCOREERROR = 6};
#endif

#ifndef SOAP_TYPE_ns3__APIErrorEnum
#define SOAP_TYPE_ns3__APIErrorEnum (406)
/* ns3:APIErrorEnum */
enum ns3__APIErrorEnum {ns3__APIErrorEnum__OK = 0, ns3__APIErrorEnum__INTERNAL_USCOREERROR = 1, ns3__APIErrorEnum__EXCEEDED_USCORETHROTTLE = 2, ns3__APIErrorEnum__USER_USCORENOT_USCORESUBSCRIBED_USCORETO_USCOREPRODUCT = 3, ns3__APIErrorEnum__SUBSCRIPTION_USCOREINACTIVE_USCOREOR_USCORESUSPENDED = 4, ns3__APIErrorEnum__VENDOR_USCORESOFTWARE_USCOREINACTIVE = 5, ns3__APIErrorEnum__VENDOR_USCORESOFTWARE_USCOREINVALID = 6, ns3__APIErrorEnum__SERVICE_USCORENOT_USCOREAVAILABLE_USCOREIN_USCOREPRODUCT = 7, ns3__APIErrorEnum__NO_USCORESESSION = 8, ns3__APIErrorEnum__TOO_USCOREMANY_USCOREREQUESTS = 9, ns3__APIErrorEnum__PRODUCT_USCOREREQUIRES_USCOREFUNDED_USCOREACCOUNT = 10, ns3__APIErrorEnum__SERVICE_USCORENOT_USCOREAVAILABLE_USCOREFOR_USCORELOGIN_USCORESTATUS = 11};
#endif

#ifndef SOAP_TYPE_ns3__GetAccountFundsErrorEnum
#define SOAP_TYPE_ns3__GetAccountFundsErrorEnum (407)
/* ns3:GetAccountFundsErrorEnum */
enum ns3__GetAccountFundsErrorEnum {ns3__GetAccountFundsErrorEnum__OK = 0, ns3__GetAccountFundsErrorEnum__EXPOSURE_USCORECALC_USCOREIN_USCOREPROGRESS = 1, ns3__GetAccountFundsErrorEnum__API_USCOREERROR = 2};
#endif

#ifndef SOAP_TYPE_ns3__GetSilksErrorEnum
#define SOAP_TYPE_ns3__GetSilksErrorEnum (408)
/* ns3:GetSilksErrorEnum */
enum ns3__GetSilksErrorEnum {ns3__GetSilksErrorEnum__OK = 0, ns3__GetSilksErrorEnum__INVALID_USCORELOCALE = 1, ns3__GetSilksErrorEnum__INVALID_USCORENUMBER_USCOREOF_USCOREMARKETS = 2, ns3__GetSilksErrorEnum__API_USCOREERROR = 3};
#endif

#ifndef SOAP_TYPE_ns3__MarketDisplayErrorEnum
#define SOAP_TYPE_ns3__MarketDisplayErrorEnum (409)
/* ns3:MarketDisplayErrorEnum */
enum ns3__MarketDisplayErrorEnum {ns3__MarketDisplayErrorEnum__OK = 0, ns3__MarketDisplayErrorEnum__INVALID_USCOREMARKET = 1, ns3__MarketDisplayErrorEnum__NO_USCORESILKS_USCOREAVAILABLE = 2};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsResultEnum
#define SOAP_TYPE_ns3__CancelBetsResultEnum (410)
/* ns3:CancelBetsResultEnum */
enum ns3__CancelBetsResultEnum {ns3__CancelBetsResultEnum__OK = 0, ns3__CancelBetsResultEnum__BET_USCOREIN_USCOREPROGRESS = 1, ns3__CancelBetsResultEnum__BBM_USCOREDAEMON_USCORENOT_USCOREAVAILABLE = 2, ns3__CancelBetsResultEnum__INVALID_USCOREBET_USCOREID = 3, ns3__CancelBetsResultEnum__UNKNOWN_USCOREERROR = 4, ns3__CancelBetsResultEnum__TAKEN_USCOREOR_USCORELAPSED = 5, ns3__CancelBetsResultEnum__REMAINING_USCORECANCELLED = 6, ns3__CancelBetsResultEnum__INPLAY_USCOREFORBIDDEN = 7, ns3__CancelBetsResultEnum__FROM_USCORECOUNTRY_USCOREFORBIDDEN = 8, ns3__CancelBetsResultEnum__INPLAY_USCOREFROM_USCORECOUNTRY_USCOREFORBIDDEN = 9, ns3__CancelBetsResultEnum__SITE_USCOREUPGRADE = 10, ns3__CancelBetsResultEnum__BET_USCORENOT_USCORECANCELLED = 11, ns3__CancelBetsResultEnum__BSP_USCOREBETS_USCORECANNOT_USCOREBE_USCORECANCELLED = 12};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsErrorEnum
#define SOAP_TYPE_ns3__CancelBetsErrorEnum (411)
/* ns3:CancelBetsErrorEnum */
enum ns3__CancelBetsErrorEnum {ns3__CancelBetsErrorEnum__OK = 0, ns3__CancelBetsErrorEnum__BET_USCOREIN_USCOREPROGRESS = 1, ns3__CancelBetsErrorEnum__BBM_USCOREDAEMON_USCORENOT_USCOREAVAILABLE = 2, ns3__CancelBetsErrorEnum__INVALID_USCORENUMER_USCOREOF_USCORECANCELLATIONS = 3, ns3__CancelBetsErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 4, ns3__CancelBetsErrorEnum__MARKET_USCORESTATUS_USCOREINVALID = 5, ns3__CancelBetsErrorEnum__MARKET_USCOREIDS_USCOREDONT_USCOREMATCH = 6, ns3__CancelBetsErrorEnum__INVALID_USCOREMARKET_USCOREID = 7, ns3__CancelBetsErrorEnum__API_USCOREERROR = 8};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsByMarketErrorEnum
#define SOAP_TYPE_ns3__CancelBetsByMarketErrorEnum (412)
/* ns3:CancelBetsByMarketErrorEnum */
enum ns3__CancelBetsByMarketErrorEnum {ns3__CancelBetsByMarketErrorEnum__OK = 0, ns3__CancelBetsByMarketErrorEnum__INVALID_USCORENUMBER_USCOREOF_USCOREMARKETS = 1, ns3__CancelBetsByMarketErrorEnum__API_USCOREERROR = 2};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsByMarketResultEnum
#define SOAP_TYPE_ns3__CancelBetsByMarketResultEnum (413)
/* ns3:CancelBetsByMarketResultEnum */
enum ns3__CancelBetsByMarketResultEnum {ns3__CancelBetsByMarketResultEnum__OK = 0, ns3__CancelBetsByMarketResultEnum__MARKET_USCORESTATUS_USCOREINVALID = 1, ns3__CancelBetsByMarketResultEnum__UNKNOWN_USCOREERROR = 2, ns3__CancelBetsByMarketResultEnum__INVALID_USCOREMARKET = 3, ns3__CancelBetsByMarketResultEnum__NO_USCOREUNMATCHED_USCOREBETS = 4, ns3__CancelBetsByMarketResultEnum__INPLAY_USCOREFORBIDDEN = 5, ns3__CancelBetsByMarketResultEnum__FROM_USCORECOUNTRY_USCOREFORBIDDEN = 6, ns3__CancelBetsByMarketResultEnum__INPLAY_USCOREFROM_USCORECOUNTRY_USCOREFORBIDDEN = 7, ns3__CancelBetsByMarketResultEnum__SITE_USCOREUPGRADE = 8, ns3__CancelBetsByMarketResultEnum__BET_USCORENOT_USCORECANCELLED = 9};
#endif

#ifndef SOAP_TYPE_ns3__UpdateBetsResultEnum
#define SOAP_TYPE_ns3__UpdateBetsResultEnum (414)
/* ns3:UpdateBetsResultEnum */
enum ns3__UpdateBetsResultEnum {ns3__UpdateBetsResultEnum__OK = 0, ns3__UpdateBetsResultEnum__BET_USCOREIN_USCOREPROGRESS = 1, ns3__UpdateBetsResultEnum__BBM_USCOREDAEMON_USCORENOT_USCOREAVAILABLE = 2, ns3__UpdateBetsResultEnum__BET_USCORECANCELLED_USCOREREMAINING_USCOREUNMATCHED = 3, ns3__UpdateBetsResultEnum__BET_USCORECANNOT_USCOREBE_USCOREACCEPTED = 4, ns3__UpdateBetsResultEnum__BET_USCORENOT_USCORECANCELLED = 5, ns3__UpdateBetsResultEnum__BET_USCORETAKEN_USCOREOR_USCORELAPSED = 6, ns3__UpdateBetsResultEnum__CANCELLED_USCORENOT_USCOREPLACED = 7, ns3__UpdateBetsResultEnum__ERROR_USCORELINE_USCOREEXPO_USCOREBET_USCORECANCELLED_USCORENOT_USCOREPLACED = 8, ns3__UpdateBetsResultEnum__EVENT_USCORECLOSED_USCORECANNOT_USCOREMODIFY_USCOREBET = 9, ns3__UpdateBetsResultEnum__EXCEEDED_USCOREEXPOSURE_USCOREOR_USCOREAVAILABLE_USCORETO_USCOREBET_USCOREBALANCE = 10, ns3__UpdateBetsResultEnum__EXPOSURE_USCORECALCULATION_USCOREERROR = 11, ns3__UpdateBetsResultEnum__EXPOSURE_USCORECALCULATION_USCOREIN_USCOREPROGRESS = 12, ns3__UpdateBetsResultEnum__FROM_USCORECOUNTRY_USCOREON_USCOREEVENT_USCOREFORBIDDEN = 13, ns3__UpdateBetsResultEnum__INPLAY_USCOREFROM_USCORECOUNTRY_USCOREFORBIDDEN = 14, ns3__UpdateBetsResultEnum__INSUFFICIENT_USCOREBALANCE = 15, ns3__UpdateBetsResultEnum__INVALID_USCOREBET_USCOREID = 16, ns3__UpdateBetsResultEnum__INVALID_USCOREOLD_USCOREPRICE = 17, ns3__UpdateBetsResultEnum__INVALID_USCOREOLD_USCORESIZE = 18, ns3__UpdateBetsResultEnum__INVALID_USCOREPRICE = 19, ns3__UpdateBetsResultEnum__INVALID_USCOREPRICE_USCOREAND_USCORESIZE = 20, ns3__UpdateBetsResultEnum__INVALID_USCORESIZE = 21, ns3__UpdateBetsResultEnum__LOSS_USCORELIMIT_USCOREEXCEEDED = 22, ns3__UpdateBetsResultEnum__NEW_USCOREBET_USCORESUBMITTED_USCORESUCCESSFULLY = 23, ns3__UpdateBetsResultEnum__NOT_USCOREPLACED_USCOREEXPOSURE_USCOREEXCEEDED = 24, ns3__UpdateBetsResultEnum__NOT_USCOREPLACED_USCOREREMAINING_USCORECANCELLED = 25, ns3__UpdateBetsResultEnum__OK_USCOREREMAINING_USCORECANCELLED = 26, ns3__UpdateBetsResultEnum__PARTIAL_USCORECANCELLATION = 27, ns3__UpdateBetsResultEnum__REMAINING_USCORESIZE_USCORECANCELLED = 28, ns3__UpdateBetsResultEnum__RUNNER_USCOREREMOVED = 29, ns3__UpdateBetsResultEnum__SITE_USCOREUPGRADE = 30, ns3__UpdateBetsResultEnum__UNKNOWN_USCOREERROR = 31, ns3__UpdateBetsResultEnum__VACANT_USCORETRAP = 32, ns3__UpdateBetsResultEnum__WRONG_USCOREMININUM_USCOREPERMITTED_USCOREBET_USCORESIZE = 33, ns3__UpdateBetsResultEnum__BSP_USCOREBETS_USCORECANNOT_USCOREBE_USCORECANCELLED = 34, ns3__UpdateBetsResultEnum__BSP_USCOREBETTING_USCORENOT_USCOREALLOWED = 35, ns3__UpdateBetsResultEnum__BSP_USCOREBETTING_USCORENOT_USCORESUPPORTED = 36, ns3__UpdateBetsResultEnum__BSP_USCOREINVALID_USCOREPRICE_USCORELIMIT = 37, ns3__UpdateBetsResultEnum__BSP_USCOREMOC_USCOREBETS_USCOREEDITING_USCORENOT_USCOREPERMITTED = 38, ns3__UpdateBetsResultEnum__INVALID_USCOREBSP_USCOREBET_USCOREUPDATE = 39, ns3__UpdateBetsResultEnum__INVALID_USCOREINPUTS = 40, ns3__UpdateBetsResultEnum__PERSISTENCE_USCOREMODIFICATION_USCORESUCCESS = 41, ns3__UpdateBetsResultEnum__INVALID_USCORENEW_USCOREPRICE_USCORELIMIT = 42, ns3__UpdateBetsResultEnum__BSP_USCOREINVALID_USCOREPERSISTENCE = 43};
#endif

#ifndef SOAP_TYPE_ns3__UpdateBetsErrorEnum
#define SOAP_TYPE_ns3__UpdateBetsErrorEnum (415)
/* ns3:UpdateBetsErrorEnum */
enum ns3__UpdateBetsErrorEnum {ns3__UpdateBetsErrorEnum__OK = 0, ns3__UpdateBetsErrorEnum__BET_USCOREIN_USCOREPROGRESS = 1, ns3__UpdateBetsErrorEnum__BBM_USCOREDAEMON_USCORENOT_USCOREAVAILABLE = 2, ns3__UpdateBetsErrorEnum__ACCOUNT_USCOREPENDING = 3, ns3__UpdateBetsErrorEnum__ACCOUNT_USCORESUSPENDED = 4, ns3__UpdateBetsErrorEnum__ACCOUNT_USCORECLOSED = 5, ns3__UpdateBetsErrorEnum__INVALID_USCORENUMBER_USCOREOF_USCOREBETS = 6, ns3__UpdateBetsErrorEnum__INVALID_USCOREMARKET_USCOREID = 7, ns3__UpdateBetsErrorEnum__MARKET_USCORESTATUS_USCOREINVALID = 8, ns3__UpdateBetsErrorEnum__FROM_USCORECOUNTRY_USCOREFORBIDDEN = 9, ns3__UpdateBetsErrorEnum__API_USCOREERROR = 10, ns3__UpdateBetsErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 11};
#endif

#ifndef SOAP_TYPE_ns3__PlaceBetsErrorEnum
#define SOAP_TYPE_ns3__PlaceBetsErrorEnum (416)
/* ns3:PlaceBetsErrorEnum */
enum ns3__PlaceBetsErrorEnum {ns3__PlaceBetsErrorEnum__OK = 0, ns3__PlaceBetsErrorEnum__BETWEEN_USCORE1_USCOREAND_USCORE60_USCOREBETS_USCOREREQUIRED = 1, ns3__PlaceBetsErrorEnum__EVENT_USCOREINACTIVE = 2, ns3__PlaceBetsErrorEnum__EVENT_USCORECLOSED = 3, ns3__PlaceBetsErrorEnum__EVENT_USCORESUSPENDED = 4, ns3__PlaceBetsErrorEnum__ACCOUNT_USCORECLOSED = 5, ns3__PlaceBetsErrorEnum__ACCOUNT_USCORESUSPENDED = 6, ns3__PlaceBetsErrorEnum__AUTHORISATION_USCOREPENDING = 7, ns3__PlaceBetsErrorEnum__INTERNAL_USCOREERROR = 8, ns3__PlaceBetsErrorEnum__SITE_USCOREUPGRADE = 9, ns3__PlaceBetsErrorEnum__BACK_USCORELAY_USCORECOMBINATION = 10, ns3__PlaceBetsErrorEnum__INVALID_USCOREMARKET = 11, ns3__PlaceBetsErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 12, ns3__PlaceBetsErrorEnum__DIFFERING_USCOREMARKETS = 13, ns3__PlaceBetsErrorEnum__FROM_USCORECOUNTRY_USCOREFORBIDDEN = 14, ns3__PlaceBetsErrorEnum__ACCOUNT_USCOREIS_USCOREEXCLUDED = 15, ns3__PlaceBetsErrorEnum__BET_USCOREIN_USCOREPROGRESS = 16, ns3__PlaceBetsErrorEnum__BBM_USCOREDAEMON_USCORENOT_USCOREAVAILABLE = 17, ns3__PlaceBetsErrorEnum__BSP_USCOREBETTING_USCORENOT_USCORESUPPORTED = 18, ns3__PlaceBetsErrorEnum__API_USCOREERROR = 19};
#endif

#ifndef SOAP_TYPE_ns3__PlaceBetsResultEnum
#define SOAP_TYPE_ns3__PlaceBetsResultEnum (417)
/* ns3:PlaceBetsResultEnum */
enum ns3__PlaceBetsResultEnum {ns3__PlaceBetsResultEnum__OK = 0, ns3__PlaceBetsResultEnum__BET_USCOREIN_USCOREPROGRESS = 1, ns3__PlaceBetsResultEnum__BBM_USCOREDAEMON_USCORENOT_USCOREAVAILABLE = 2, ns3__PlaceBetsResultEnum__ACCOUNT_USCORECLOSED = 3, ns3__PlaceBetsResultEnum__ACCOUNT_USCOREIS_USCOREEXCLUDED = 4, ns3__PlaceBetsResultEnum__ACCOUNT_USCORESUSPENDED = 5, ns3__PlaceBetsResultEnum__CANNOT_USCOREACCEPT_USCOREBET = 6, ns3__PlaceBetsResultEnum__EXPOSURE_USCORECALCULATION_USCOREIN_USCOREPROGRESS = 7, ns3__PlaceBetsResultEnum__EXPOSURE_USCOREOR_USCOREAVAILABLE_USCOREBALANCE_USCOREEXCEEDED = 8, ns3__PlaceBetsResultEnum__FROM_USCORECOUNTRY_USCOREON_USCOREEVENT_USCOREFORBIDDEN = 9, ns3__PlaceBetsResultEnum__INPLAY_USCOREFROM_USCORECOUNTRY_USCOREFORBIDDEN = 10, ns3__PlaceBetsResultEnum__INSUFFICIENT_USCOREBALANCE = 11, ns3__PlaceBetsResultEnum__INVALID_USCOREASIAN_USCORELINE_USCOREID = 12, ns3__PlaceBetsResultEnum__INVALID_USCOREBET_USCORETYPE = 13, ns3__PlaceBetsResultEnum__INVALID_USCOREINCREMENT = 14, ns3__PlaceBetsResultEnum__INVALID_USCOREMARKET = 15, ns3__PlaceBetsResultEnum__INVALID_USCOREPRICE = 16, ns3__PlaceBetsResultEnum__INVALID_USCORESELECTION = 17, ns3__PlaceBetsResultEnum__INVALID_USCORESIZE = 18, ns3__PlaceBetsResultEnum__LINES_USCOREOUT_USCOREOF_USCORERANGE = 19, ns3__PlaceBetsResultEnum__LOSS_USCORELIMIT_USCOREEXCEEDED = 20, ns3__PlaceBetsResultEnum__SELECTION_USCOREREMOVED = 21, ns3__PlaceBetsResultEnum__UNKNOWN_USCOREERROR = 22, ns3__PlaceBetsResultEnum__VACANT_USCORETRAP = 23, ns3__PlaceBetsResultEnum__EVENT_USCORECLOSED = 24, ns3__PlaceBetsResultEnum__AUTHORISATION_USCOREPENDING = 25, ns3__PlaceBetsResultEnum__BSP_USCOREBETTING_USCORENOT_USCOREALLOWED = 26, ns3__PlaceBetsResultEnum__BSP_USCOREBETTING_USCORENOT_USCORESUPPORTED = 27, ns3__PlaceBetsResultEnum__BSP_USCOREMULTIPLE_USCOREBETS_USCORENOT_USCOREALLOWED = 28, ns3__PlaceBetsResultEnum__EVENT_USCORERECONCILED = 29, ns3__PlaceBetsResultEnum__INVALID_USCOREPERSISTENCE = 30, ns3__PlaceBetsResultEnum__ACCOUNT_USCORELOCKED = 31};
#endif

#ifndef SOAP_TYPE_ns3__BetTypeEnum
#define SOAP_TYPE_ns3__BetTypeEnum (418)
/* ns3:BetTypeEnum */
enum ns3__BetTypeEnum {ns3__BetTypeEnum__B = 0, ns3__BetTypeEnum__L = 1};
#endif

#ifndef SOAP_TYPE_ns3__MarketTypeEnum
#define SOAP_TYPE_ns3__MarketTypeEnum (419)
/* ns3:MarketTypeEnum */
enum ns3__MarketTypeEnum {ns3__MarketTypeEnum__O = 0, ns3__MarketTypeEnum__L = 1, ns3__MarketTypeEnum__R = 2, ns3__MarketTypeEnum__A = 3, ns3__MarketTypeEnum__NOT_USCOREAPPLICABLE = 4};
#endif

#ifndef SOAP_TYPE_ns3__MarketTypeVariantEnum
#define SOAP_TYPE_ns3__MarketTypeVariantEnum (420)
/* ns3:MarketTypeVariantEnum */
enum ns3__MarketTypeVariantEnum {ns3__MarketTypeVariantEnum__D = 0, ns3__MarketTypeVariantEnum__ASL = 1, ns3__MarketTypeVariantEnum__ADL = 2, ns3__MarketTypeVariantEnum__COUP = 3};
#endif

#ifndef SOAP_TYPE_ns3__GetCouponErrorEnum
#define SOAP_TYPE_ns3__GetCouponErrorEnum (421)
/* ns3:GetCouponErrorEnum */
enum ns3__GetCouponErrorEnum {ns3__GetCouponErrorEnum__OK = 0, ns3__GetCouponErrorEnum__INVALID_USCORECOUPON_USCOREID = 1, ns3__GetCouponErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 2, ns3__GetCouponErrorEnum__API_USCOREERROR = 3};
#endif

#ifndef SOAP_TYPE_ns3__HeartbeatErrorEnum
#define SOAP_TYPE_ns3__HeartbeatErrorEnum (422)
/* ns3:HeartbeatErrorEnum */
enum ns3__HeartbeatErrorEnum {ns3__HeartbeatErrorEnum__OK = 0, ns3__HeartbeatErrorEnum__NO_USCOREBETS_USCORECANCELLED = 1, ns3__HeartbeatErrorEnum__BETS_USCORECANCELLED = 2, ns3__HeartbeatErrorEnum__API_USCOREERROR = 3};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketErrorEnum
#define SOAP_TYPE_ns3__GetMarketErrorEnum (423)
/* ns3:GetMarketErrorEnum */
enum ns3__GetMarketErrorEnum {ns3__GetMarketErrorEnum__OK = 0, ns3__GetMarketErrorEnum__INVALID_USCOREMARKET = 1, ns3__GetMarketErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 2, ns3__GetMarketErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 3, ns3__GetMarketErrorEnum__API_USCOREERROR = 4};
#endif

#ifndef SOAP_TYPE_ns3__MarketStatusEnum
#define SOAP_TYPE_ns3__MarketStatusEnum (424)
/* ns3:MarketStatusEnum */
enum ns3__MarketStatusEnum {ns3__MarketStatusEnum__ACTIVE = 0, ns3__MarketStatusEnum__INACTIVE = 1, ns3__MarketStatusEnum__CLOSED = 2, ns3__MarketStatusEnum__SUSPENDED = 3};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketPricesErrorEnum
#define SOAP_TYPE_ns3__GetMarketPricesErrorEnum (425)
/* ns3:GetMarketPricesErrorEnum */
enum ns3__GetMarketPricesErrorEnum {ns3__GetMarketPricesErrorEnum__OK = 0, ns3__GetMarketPricesErrorEnum__INVALID_USCORECURRENCY = 1, ns3__GetMarketPricesErrorEnum__INVALID_USCOREMARKET = 2, ns3__GetMarketPricesErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 3, ns3__GetMarketPricesErrorEnum__API_USCOREERROR = 4};
#endif

#ifndef SOAP_TYPE_ns3__GetAllMarketsErrorEnum
#define SOAP_TYPE_ns3__GetAllMarketsErrorEnum (426)
/* ns3:GetAllMarketsErrorEnum */
enum ns3__GetAllMarketsErrorEnum {ns3__GetAllMarketsErrorEnum__OK = 0, ns3__GetAllMarketsErrorEnum__INVALID_USCORECOUNTRY_USCORECODE = 1, ns3__GetAllMarketsErrorEnum__INVALID_USCORELOCALE = 2, ns3__GetAllMarketsErrorEnum__INVALID_USCOREEVENT_USCORETYPE_USCOREID = 3, ns3__GetAllMarketsErrorEnum__API_USCOREERROR = 4};
#endif

#ifndef SOAP_TYPE_ns3__GetInPlayMarketsErrorEnum
#define SOAP_TYPE_ns3__GetInPlayMarketsErrorEnum (427)
/* ns3:GetInPlayMarketsErrorEnum */
enum ns3__GetInPlayMarketsErrorEnum {ns3__GetInPlayMarketsErrorEnum__OK = 0, ns3__GetInPlayMarketsErrorEnum__INVALID_USCORELOCALE = 1, ns3__GetInPlayMarketsErrorEnum__API_USCOREERROR = 2};
#endif

#ifndef SOAP_TYPE_ns3__GetPrivateMarketsErrorEnum
#define SOAP_TYPE_ns3__GetPrivateMarketsErrorEnum (428)
/* ns3:GetPrivateMarketsErrorEnum */
enum ns3__GetPrivateMarketsErrorEnum {ns3__GetPrivateMarketsErrorEnum__OK = 0, ns3__GetPrivateMarketsErrorEnum__INVALID_USCORELOCALE = 1, ns3__GetPrivateMarketsErrorEnum__INVALID_USCOREEVENT_USCORETYPE_USCOREID = 2, ns3__GetPrivateMarketsErrorEnum__INVALID_USCOREMARKET_USCORETYPE = 3, ns3__GetPrivateMarketsErrorEnum__NO_USCORERESULTS = 4, ns3__GetPrivateMarketsErrorEnum__API_USCOREERROR = 5};
#endif

#ifndef SOAP_TYPE_ns3__GetCompleteMarketPricesErrorEnum
#define SOAP_TYPE_ns3__GetCompleteMarketPricesErrorEnum (429)
/* ns3:GetCompleteMarketPricesErrorEnum */
enum ns3__GetCompleteMarketPricesErrorEnum {ns3__GetCompleteMarketPricesErrorEnum__OK = 0, ns3__GetCompleteMarketPricesErrorEnum__INVALID_USCORECURRENCY = 1, ns3__GetCompleteMarketPricesErrorEnum__INVALID_USCOREMARKET = 2, ns3__GetCompleteMarketPricesErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 3, ns3__GetCompleteMarketPricesErrorEnum__EVENT_USCORECLOSED = 4, ns3__GetCompleteMarketPricesErrorEnum__EVENT_USCORESUSPENDED = 5, ns3__GetCompleteMarketPricesErrorEnum__EVENT_USCOREINACTIVE = 6, ns3__GetCompleteMarketPricesErrorEnum__API_USCOREERROR = 7};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedErrorEnum
#define SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedErrorEnum (430)
/* ns3:GetMarketTradedVolumeCompressedErrorEnum */
enum ns3__GetMarketTradedVolumeCompressedErrorEnum {ns3__GetMarketTradedVolumeCompressedErrorEnum__OK = 0, ns3__GetMarketTradedVolumeCompressedErrorEnum__INVALID_USCORECURRENCY = 1, ns3__GetMarketTradedVolumeCompressedErrorEnum__INVALID_USCOREMARKET = 2, ns3__GetMarketTradedVolumeCompressedErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 3, ns3__GetMarketTradedVolumeCompressedErrorEnum__EVENT_USCORECLOSED = 4, ns3__GetMarketTradedVolumeCompressedErrorEnum__EVENT_USCORESUSPENDED = 5, ns3__GetMarketTradedVolumeCompressedErrorEnum__EVENT_USCOREINACTIVE = 6, ns3__GetMarketTradedVolumeCompressedErrorEnum__API_USCOREERROR = 7};
#endif

#ifndef SOAP_TYPE_ns3__GetMUBetsErrorEnum
#define SOAP_TYPE_ns3__GetMUBetsErrorEnum (431)
/* ns3:GetMUBetsErrorEnum */
enum ns3__GetMUBetsErrorEnum {ns3__GetMUBetsErrorEnum__OK = 0, ns3__GetMUBetsErrorEnum__INVALID_USCORESTART_USCORERECORD = 1, ns3__GetMUBetsErrorEnum__INVALID_USCOREMARKET_USCOREID = 2, ns3__GetMUBetsErrorEnum__INVALID_USCORERECORD_USCORECOUNT = 3, ns3__GetMUBetsErrorEnum__INVALID_USCOREBET_USCORESTATUS = 4, ns3__GetMUBetsErrorEnum__INVALID_USCOREORDER_USCOREBY_USCOREFOR_USCORESTATUS = 5, ns3__GetMUBetsErrorEnum__TOO_USCOREMANY_USCOREBETS_USCOREREQUESTED = 6, ns3__GetMUBetsErrorEnum__NO_USCORERESULTS = 7, ns3__GetMUBetsErrorEnum__API_USCOREERROR = 8};
#endif

#ifndef SOAP_TYPE_ns3__SortOrderEnum
#define SOAP_TYPE_ns3__SortOrderEnum (432)
/* ns3:SortOrderEnum */
enum ns3__SortOrderEnum {ns3__SortOrderEnum__DESC = 0, ns3__SortOrderEnum__ASC = 1};
#endif

#ifndef SOAP_TYPE_ns3__BetStatusEnum
#define SOAP_TYPE_ns3__BetStatusEnum (433)
/* ns3:BetStatusEnum */
enum ns3__BetStatusEnum {ns3__BetStatusEnum__U = 0, ns3__BetStatusEnum__M = 1, ns3__BetStatusEnum__S = 2, ns3__BetStatusEnum__C = 3, ns3__BetStatusEnum__V = 4, ns3__BetStatusEnum__L = 5, ns3__BetStatusEnum__MU = 6};
#endif

#ifndef SOAP_TYPE_ns3__BetCategoryTypeEnum
#define SOAP_TYPE_ns3__BetCategoryTypeEnum (434)
/* ns3:BetCategoryTypeEnum */
enum ns3__BetCategoryTypeEnum {ns3__BetCategoryTypeEnum__E = 0, ns3__BetCategoryTypeEnum__M = 1, ns3__BetCategoryTypeEnum__L = 2, ns3__BetCategoryTypeEnum__NONE = 3};
#endif

#ifndef SOAP_TYPE_ns3__BetPersistenceTypeEnum
#define SOAP_TYPE_ns3__BetPersistenceTypeEnum (435)
/* ns3:BetPersistenceTypeEnum */
enum ns3__BetPersistenceTypeEnum {ns3__BetPersistenceTypeEnum__NONE = 0, ns3__BetPersistenceTypeEnum__IP = 1, ns3__BetPersistenceTypeEnum__SP = 2};
#endif

#ifndef SOAP_TYPE_ns3__GetCurrentBetsErrorEnum
#define SOAP_TYPE_ns3__GetCurrentBetsErrorEnum (436)
/* ns3:GetCurrentBetsErrorEnum */
enum ns3__GetCurrentBetsErrorEnum {ns3__GetCurrentBetsErrorEnum__OK = 0, ns3__GetCurrentBetsErrorEnum__INVALID_USCORESTART_USCORERECORD = 1, ns3__GetCurrentBetsErrorEnum__INVALID_USCOREMARKET_USCOREID = 2, ns3__GetCurrentBetsErrorEnum__INVALID_USCORERECORD_USCORECOUNT = 3, ns3__GetCurrentBetsErrorEnum__INVALID_USCOREBET_USCORESTATUS = 4, ns3__GetCurrentBetsErrorEnum__INVALID_USCOREORDER_USCOREBY_USCOREFOR_USCORESTATUS = 5, ns3__GetCurrentBetsErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 6, ns3__GetCurrentBetsErrorEnum__NO_USCORERESULTS = 7, ns3__GetCurrentBetsErrorEnum__API_USCOREERROR = 8};
#endif

#ifndef SOAP_TYPE_ns3__BetsOrderByEnum
#define SOAP_TYPE_ns3__BetsOrderByEnum (437)
/* ns3:BetsOrderByEnum */
enum ns3__BetsOrderByEnum {ns3__BetsOrderByEnum__NONE = 0, ns3__BetsOrderByEnum__BET_USCOREID = 1, ns3__BetsOrderByEnum__MARKET_USCORENAME = 2, ns3__BetsOrderByEnum__PLACED_USCOREDATE = 3, ns3__BetsOrderByEnum__MATCHED_USCOREDATE = 4, ns3__BetsOrderByEnum__CANCELLED_USCOREDATE = 5};
#endif

#ifndef SOAP_TYPE_ns3__GetDetailedAvailMktDepthErrorEnum
#define SOAP_TYPE_ns3__GetDetailedAvailMktDepthErrorEnum (438)
/* ns3:GetDetailedAvailMktDepthErrorEnum */
enum ns3__GetDetailedAvailMktDepthErrorEnum {ns3__GetDetailedAvailMktDepthErrorEnum__OK = 0, ns3__GetDetailedAvailMktDepthErrorEnum__NO_USCORERESULTS = 1, ns3__GetDetailedAvailMktDepthErrorEnum__SUSPENDED_USCOREMARKET = 2, ns3__GetDetailedAvailMktDepthErrorEnum__INVALID_USCOREMARKET = 3, ns3__GetDetailedAvailMktDepthErrorEnum__INVALID_USCORERUNNER = 4, ns3__GetDetailedAvailMktDepthErrorEnum__INVALID_USCOREASIAN_USCORELINE = 5, ns3__GetDetailedAvailMktDepthErrorEnum__INVALID_USCORECURRENCY = 6, ns3__GetDetailedAvailMktDepthErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 7, ns3__GetDetailedAvailMktDepthErrorEnum__API_USCOREERROR = 8};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketTradedVolumeErrorEnum
#define SOAP_TYPE_ns3__GetMarketTradedVolumeErrorEnum (439)
/* ns3:GetMarketTradedVolumeErrorEnum */
enum ns3__GetMarketTradedVolumeErrorEnum {ns3__GetMarketTradedVolumeErrorEnum__OK = 0, ns3__GetMarketTradedVolumeErrorEnum__NO_USCORERESULTS = 1, ns3__GetMarketTradedVolumeErrorEnum__INVALID_USCOREMARKET = 2, ns3__GetMarketTradedVolumeErrorEnum__INVALID_USCORERUNNER = 3, ns3__GetMarketTradedVolumeErrorEnum__INVALID_USCOREASIAN_USCORELINE = 4, ns3__GetMarketTradedVolumeErrorEnum__MARKET_USCORECLOSED = 5, ns3__GetMarketTradedVolumeErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 6, ns3__GetMarketTradedVolumeErrorEnum__INVALID_USCORECURRENCY = 7, ns3__GetMarketTradedVolumeErrorEnum__API_USCOREERROR = 8};
#endif

#ifndef SOAP_TYPE_ns3__GetBetHistoryErrorEnum
#define SOAP_TYPE_ns3__GetBetHistoryErrorEnum (440)
/* ns3:GetBetHistoryErrorEnum */
enum ns3__GetBetHistoryErrorEnum {ns3__GetBetHistoryErrorEnum__OK = 0, ns3__GetBetHistoryErrorEnum__INVALID_USCOREEVENT_USCORETYPE_USCOREID = 1, ns3__GetBetHistoryErrorEnum__NO_USCORERESULTS = 2, ns3__GetBetHistoryErrorEnum__INVALID_USCORERECORD_USCORECOUNT = 3, ns3__GetBetHistoryErrorEnum__INVALID_USCOREBET_USCORESTATUS = 4, ns3__GetBetHistoryErrorEnum__INVALID_USCOREMARKET_USCORETYPE = 5, ns3__GetBetHistoryErrorEnum__INVALID_USCOREORDER_USCOREBY = 6, ns3__GetBetHistoryErrorEnum__INVALID_USCORESTART_USCORERECORD = 7, ns3__GetBetHistoryErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 8, ns3__GetBetHistoryErrorEnum__API_USCOREERROR = 9};
#endif

#ifndef SOAP_TYPE_ns3__GetAccountStatementErrorEnum
#define SOAP_TYPE_ns3__GetAccountStatementErrorEnum (441)
/* ns3:GetAccountStatementErrorEnum */
enum ns3__GetAccountStatementErrorEnum {ns3__GetAccountStatementErrorEnum__OK = 0, ns3__GetAccountStatementErrorEnum__INVALID_USCORESTART_USCORERECORD = 1, ns3__GetAccountStatementErrorEnum__INVALID_USCORERECORD_USCORECOUNT = 2, ns3__GetAccountStatementErrorEnum__INVALID_USCOREEND_USCOREDATE = 3, ns3__GetAccountStatementErrorEnum__INVALID_USCORESTART_USCOREDATE = 4, ns3__GetAccountStatementErrorEnum__NO_USCORERESULTS = 5, ns3__GetAccountStatementErrorEnum__API_USCOREERROR = 6, ns3__GetAccountStatementErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 7};
#endif

#ifndef SOAP_TYPE_ns3__AccountStatementEnum
#define SOAP_TYPE_ns3__AccountStatementEnum (442)
/* ns3:AccountStatementEnum */
enum ns3__AccountStatementEnum {ns3__AccountStatementEnum__OK = 0, ns3__AccountStatementEnum__RESULT_USCOREWON = 1, ns3__AccountStatementEnum__RESULT_USCORELOST = 2, ns3__AccountStatementEnum__RESULT_USCOREERR = 3, ns3__AccountStatementEnum__RESULT_USCOREFIX = 4, ns3__AccountStatementEnum__RESULT_USCORENOT_USCOREAPPLICABLE = 5, ns3__AccountStatementEnum__ACCOUNT_USCORECREDIT = 6, ns3__AccountStatementEnum__ACCOUNT_USCOREDEBIT = 7, ns3__AccountStatementEnum__COMMISSION_USCOREREVERSAL = 8};
#endif

#ifndef SOAP_TYPE_ns3__AccountStatementIncludeEnum
#define SOAP_TYPE_ns3__AccountStatementIncludeEnum (443)
/* ns3:AccountStatementIncludeEnum */
enum ns3__AccountStatementIncludeEnum {ns3__AccountStatementIncludeEnum__ALL = 0, ns3__AccountStatementIncludeEnum__EXCHANGE = 1, ns3__AccountStatementIncludeEnum__POKER_USCOREROOM = 2, ns3__AccountStatementIncludeEnum__DEPOSITS_USCOREWITHDRAWALS = 3};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketProfitAndLossErrorEnum
#define SOAP_TYPE_ns3__GetMarketProfitAndLossErrorEnum (444)
/* ns3:GetMarketProfitAndLossErrorEnum */
enum ns3__GetMarketProfitAndLossErrorEnum {ns3__GetMarketProfitAndLossErrorEnum__INVALID_USCOREMARKET = 0, ns3__GetMarketProfitAndLossErrorEnum__UNSUPPORTED_USCOREMARKET_USCORETYPE = 1, ns3__GetMarketProfitAndLossErrorEnum__OK = 2, ns3__GetMarketProfitAndLossErrorEnum__MARKET_USCORECLOSED = 3, ns3__GetMarketProfitAndLossErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 4, ns3__GetMarketProfitAndLossErrorEnum__API_USCOREERROR = 5};
#endif

#ifndef SOAP_TYPE_ns3__GetBetErrorEnum
#define SOAP_TYPE_ns3__GetBetErrorEnum (445)
/* ns3:GetBetErrorEnum */
enum ns3__GetBetErrorEnum {ns3__GetBetErrorEnum__OK = 0, ns3__GetBetErrorEnum__MARKET_USCORETYPE_USCORENOT_USCORESUPPORTED = 1, ns3__GetBetErrorEnum__BET_USCOREID_USCOREINVALID = 2, ns3__GetBetErrorEnum__NO_USCORERESULTS = 3, ns3__GetBetErrorEnum__API_USCOREERROR = 4, ns3__GetBetErrorEnum__INVALID_USCORELOCALE_USCOREDEFAULTING_USCORETO_USCOREENGLISH = 5};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__APIResponse
#define SOAP_TYPE_ns1__APIResponse (9)
/* ns1:APIResponse */
class SOAP_CMAC ns1__APIResponse
{
public:
	class ns1__APIResponseHeader *header;	/* optional element of type ns1:APIResponseHeader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__APIResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__APIResponse(): header(NULL), soap(NULL) { ns1__APIResponse::soap_default(NULL); }
	virtual ~ns1__APIResponse() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__APIResponseHeader
#define SOAP_TYPE_ns1__APIResponseHeader (10)
/* ns1:APIResponseHeader */
class SOAP_CMAC ns1__APIResponseHeader
{
public:
	enum ns1__APIErrorEnum errorCode;	/* required element of type ns1:APIErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	std::string *sessionToken;	/* optional element of type xsd:string */
	time_t timestamp;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__APIResponseHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__APIResponseHeader(): minorErrorCode(NULL), sessionToken(NULL), soap(NULL) { ns1__APIResponseHeader::soap_default(NULL); }
	virtual ~ns1__APIResponseHeader() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LoginReq
#define SOAP_TYPE_ns1__LoginReq (11)
/* ns1:LoginReq */
class SOAP_CMAC ns1__LoginReq
{
public:
	std::string ipAddress;	/* required element of type xsd:string */
	int locationId;	/* required element of type xsd:int */
	std::string password;	/* required element of type xsd:string */
	int productId;	/* required element of type xsd:int */
	std::string username;	/* required element of type xsd:string */
	int vendorSoftwareId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__LoginReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LoginReq(): soap(NULL) { ns1__LoginReq::soap_default(NULL); }
	virtual ~ns1__LoginReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrievePersonalLIMBMessage
#define SOAP_TYPE_ns1__RetrievePersonalLIMBMessage (14)
/* ns1:RetrievePersonalLIMBMessage */
class SOAP_CMAC ns1__RetrievePersonalLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	std::string message;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__RetrievePersonalLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrievePersonalLIMBMessage(): messageId(NULL), enforceDate(NULL), soap(NULL) { ns1__RetrievePersonalLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrievePersonalLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage
#define SOAP_TYPE_ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage (15)
/* ns1:RetrieveTCPrivacyPolicyChangeLIMBMessage */
class SOAP_CMAC ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	std::string reasonForChange;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage(): messageId(NULL), enforceDate(NULL), soap(NULL) { ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrievePasswordChangeLIMBMessage
#define SOAP_TYPE_ns1__RetrievePasswordChangeLIMBMessage (16)
/* ns1:RetrievePasswordChangeLIMBMessage */
class SOAP_CMAC ns1__RetrievePasswordChangeLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__RetrievePasswordChangeLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrievePasswordChangeLIMBMessage(): messageId(NULL), enforceDate(NULL), soap(NULL) { ns1__RetrievePasswordChangeLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrievePasswordChangeLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveBirthDateCheckLIMBMessage
#define SOAP_TYPE_ns1__RetrieveBirthDateCheckLIMBMessage (17)
/* ns1:RetrieveBirthDateCheckLIMBMessage */
class SOAP_CMAC ns1__RetrieveBirthDateCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	time_t *birthDate;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__RetrieveBirthDateCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveBirthDateCheckLIMBMessage(): messageId(NULL), enforceDate(NULL), birthDate(NULL), soap(NULL) { ns1__RetrieveBirthDateCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrieveBirthDateCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveAddressCheckLIMBMessage
#define SOAP_TYPE_ns1__RetrieveAddressCheckLIMBMessage (18)
/* ns1:RetrieveAddressCheckLIMBMessage */
class SOAP_CMAC ns1__RetrieveAddressCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	std::string address1;	/* required element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string *town;	/* optional element of type xsd:string */
	std::string *county;	/* optional element of type xsd:string */
	std::string *zipCode;	/* optional element of type xsd:string */
	std::string *country;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__RetrieveAddressCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveAddressCheckLIMBMessage(): messageId(NULL), enforceDate(NULL), address2(NULL), address3(NULL), town(NULL), county(NULL), zipCode(NULL), country(NULL), soap(NULL) { ns1__RetrieveAddressCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrieveAddressCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveContactDetailsCheckLIMBMessage
#define SOAP_TYPE_ns1__RetrieveContactDetailsCheckLIMBMessage (19)
/* ns1:RetrieveContactDetailsCheckLIMBMessage */
class SOAP_CMAC ns1__RetrieveContactDetailsCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	std::string *homeTelephone;	/* optional element of type xsd:string */
	std::string *workTelephone;	/* optional element of type xsd:string */
	std::string *mobileTelephone;	/* optional element of type xsd:string */
	std::string *emailAddress;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__RetrieveContactDetailsCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveContactDetailsCheckLIMBMessage(): messageId(NULL), enforceDate(NULL), homeTelephone(NULL), workTelephone(NULL), mobileTelephone(NULL), emailAddress(NULL), soap(NULL) { ns1__RetrieveContactDetailsCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrieveContactDetailsCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveChatNameChangeLIMBMessage
#define SOAP_TYPE_ns1__RetrieveChatNameChangeLIMBMessage (20)
/* ns1:RetrieveChatNameChangeLIMBMessage */
class SOAP_CMAC ns1__RetrieveChatNameChangeLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	std::string chatName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__RetrieveChatNameChangeLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveChatNameChangeLIMBMessage(): messageId(NULL), enforceDate(NULL), soap(NULL) { ns1__RetrieveChatNameChangeLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrieveChatNameChangeLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage
#define SOAP_TYPE_ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage (21)
/* ns1:ArrayOfRetrieveCardBillingAddressCheckLIMBMessage */
class SOAP_CMAC ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage
{
public:
	std::vector<class ns1__RetrieveCardBillingAddressCheckLIMBMessage * >ns1__retrieveCardBillingAddressCheckLIMBMessage;	/* sequence of 0 to 3 elements */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage(): soap(NULL) { ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveCardBillingAddressCheckLIMBMessage
#define SOAP_TYPE_ns1__RetrieveCardBillingAddressCheckLIMBMessage (22)
/* ns1:RetrieveCardBillingAddressCheckLIMBMessage */
class SOAP_CMAC ns1__RetrieveCardBillingAddressCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	time_t *enforceDate;	/* optional element of type xsd:dateTime */
	bool indicator;	/* required element of type xsd:boolean */
	std::string nickName;	/* required element of type xsd:string */
	std::string cardShortNumber;	/* required element of type xsd:string */
	std::string address1;	/* required element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string *town;	/* optional element of type xsd:string */
	std::string *county;	/* optional element of type xsd:string */
	std::string *zipCode;	/* optional element of type xsd:string */
	std::string *country;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__RetrieveCardBillingAddressCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveCardBillingAddressCheckLIMBMessage(): messageId(NULL), enforceDate(NULL), address2(NULL), address3(NULL), town(NULL), county(NULL), zipCode(NULL), country(NULL), soap(NULL) { ns1__RetrieveCardBillingAddressCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__RetrieveCardBillingAddressCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitPersonalLIMBMessage
#define SOAP_TYPE_ns1__SubmitPersonalLIMBMessage (24)
/* ns1:SubmitPersonalLIMBMessage */
class SOAP_CMAC ns1__SubmitPersonalLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	std::string *acknowledgment;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__SubmitPersonalLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitPersonalLIMBMessage(): messageId(NULL), acknowledgment(NULL), soap(NULL) { ns1__SubmitPersonalLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitPersonalLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitTCPrivacyPolicyChangeLIMBMessage
#define SOAP_TYPE_ns1__SubmitTCPrivacyPolicyChangeLIMBMessage (25)
/* ns1:SubmitTCPrivacyPolicyChangeLIMBMessage */
class SOAP_CMAC ns1__SubmitTCPrivacyPolicyChangeLIMBMessage
{
public:
	enum ns1__PrivacyPolicyChangeResponseEnum tCPrivacyPolicyChangeAcceptance;	/* required element of type ns1:PrivacyPolicyChangeResponseEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__SubmitTCPrivacyPolicyChangeLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitTCPrivacyPolicyChangeLIMBMessage(): soap(NULL) { ns1__SubmitTCPrivacyPolicyChangeLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitTCPrivacyPolicyChangeLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitPasswordChangeLIMBMessage
#define SOAP_TYPE_ns1__SubmitPasswordChangeLIMBMessage (26)
/* ns1:SubmitPasswordChangeLIMBMessage */
class SOAP_CMAC ns1__SubmitPasswordChangeLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	std::string *newPassword;	/* optional element of type xsd:string */
	std::string *newPasswordRepeat;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__SubmitPasswordChangeLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitPasswordChangeLIMBMessage(): messageId(NULL), newPassword(NULL), newPasswordRepeat(NULL), soap(NULL) { ns1__SubmitPasswordChangeLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitPasswordChangeLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitBirthDateCheckLIMBMessage
#define SOAP_TYPE_ns1__SubmitBirthDateCheckLIMBMessage (27)
/* ns1:SubmitBirthDateCheckLIMBMessage */
class SOAP_CMAC ns1__SubmitBirthDateCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	std::string *detailsCorrect;	/* optional element of type xsd:string */
	time_t *correctBirthDate;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__SubmitBirthDateCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitBirthDateCheckLIMBMessage(): messageId(NULL), detailsCorrect(NULL), correctBirthDate(NULL), soap(NULL) { ns1__SubmitBirthDateCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitBirthDateCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitAddressCheckLIMBMessage
#define SOAP_TYPE_ns1__SubmitAddressCheckLIMBMessage (28)
/* ns1:SubmitAddressCheckLIMBMessage */
class SOAP_CMAC ns1__SubmitAddressCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	std::string *detailsCorrect;	/* optional element of type xsd:string */
	std::string *newAddress1;	/* optional element of type xsd:string */
	std::string *newAddress2;	/* optional element of type xsd:string */
	std::string *newAddress3;	/* optional element of type xsd:string */
	std::string *newTown;	/* optional element of type xsd:string */
	std::string *newCounty;	/* optional element of type xsd:string */
	std::string *newZipCode;	/* optional element of type xsd:string */
	std::string *newCountry;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__SubmitAddressCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitAddressCheckLIMBMessage(): messageId(NULL), detailsCorrect(NULL), newAddress1(NULL), newAddress2(NULL), newAddress3(NULL), newTown(NULL), newCounty(NULL), newZipCode(NULL), newCountry(NULL), soap(NULL) { ns1__SubmitAddressCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitAddressCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitContactDetailsCheckLIMBMessage
#define SOAP_TYPE_ns1__SubmitContactDetailsCheckLIMBMessage (29)
/* ns1:SubmitContactDetailsCheckLIMBMessage */
class SOAP_CMAC ns1__SubmitContactDetailsCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	std::string *detailsCorrect;	/* optional element of type xsd:string */
	std::string *newHomeTelephone;	/* optional element of type xsd:string */
	std::string *newWorkTelephone;	/* optional element of type xsd:string */
	std::string *newMobileTelephone;	/* optional element of type xsd:string */
	std::string *newEmailAddress;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__SubmitContactDetailsCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitContactDetailsCheckLIMBMessage(): messageId(NULL), detailsCorrect(NULL), newHomeTelephone(NULL), newWorkTelephone(NULL), newMobileTelephone(NULL), newEmailAddress(NULL), soap(NULL) { ns1__SubmitContactDetailsCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitContactDetailsCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitChatNameChangeLIMBMessage
#define SOAP_TYPE_ns1__SubmitChatNameChangeLIMBMessage (30)
/* ns1:SubmitChatNameChangeLIMBMessage */
class SOAP_CMAC ns1__SubmitChatNameChangeLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	std::string *newChatName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__SubmitChatNameChangeLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitChatNameChangeLIMBMessage(): messageId(NULL), newChatName(NULL), soap(NULL) { ns1__SubmitChatNameChangeLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitChatNameChangeLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage
#define SOAP_TYPE_ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage (31)
/* ns1:ArrayOfSubmitCardBillingAddressCheckLIMBMessage */
class SOAP_CMAC ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage
{
public:
	std::vector<class ns1__SubmitCardBillingAddressCheckLIMBMessage * >ns1__submitCardBillingAddressCheckLIMBMessage;	/* sequence of 0 to 3 elements */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage(): soap(NULL) { ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitCardBillingAddressCheckLIMBMessage
#define SOAP_TYPE_ns1__SubmitCardBillingAddressCheckLIMBMessage (32)
/* ns1:SubmitCardBillingAddressCheckLIMBMessage */
class SOAP_CMAC ns1__SubmitCardBillingAddressCheckLIMBMessage
{
public:
	int *messageId;	/* optional element of type xsd:int */
	std::string *detailsCorrect;	/* optional element of type xsd:string */
	std::string nickName;	/* required element of type xsd:string */
	std::string *newAddress1;	/* optional element of type xsd:string */
	std::string *newAddress2;	/* optional element of type xsd:string */
	std::string *newAddress3;	/* optional element of type xsd:string */
	std::string *newTown;	/* optional element of type xsd:string */
	std::string *newCounty;	/* optional element of type xsd:string */
	std::string *newZipCode;	/* optional element of type xsd:string */
	std::string *newCountry;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__SubmitCardBillingAddressCheckLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitCardBillingAddressCheckLIMBMessage(): messageId(NULL), detailsCorrect(NULL), newAddress1(NULL), newAddress2(NULL), newAddress3(NULL), newTown(NULL), newCounty(NULL), newZipCode(NULL), newCountry(NULL), soap(NULL) { ns1__SubmitCardBillingAddressCheckLIMBMessage::soap_default(NULL); }
	virtual ~ns1__SubmitCardBillingAddressCheckLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfLIMBValidationErrorsEnum
#define SOAP_TYPE_ns1__ArrayOfLIMBValidationErrorsEnum (34)
/* ns1:ArrayOfLIMBValidationErrorsEnum */
class SOAP_CMAC ns1__ArrayOfLIMBValidationErrorsEnum
{
public:
	std::vector<enum ns1__LIMBValidationErrorsEnum >ns1__LIMBValidationErrorsEnum;	/* optional element of type ns1:LIMBValidationErrorsEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__ArrayOfLIMBValidationErrorsEnum */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfLIMBValidationErrorsEnum(): soap(NULL) { ns1__ArrayOfLIMBValidationErrorsEnum::soap_default(NULL); }
	virtual ~ns1__ArrayOfLIMBValidationErrorsEnum() { }
};
#endif

#ifndef SOAP_TYPE_ns1__APIRequest
#define SOAP_TYPE_ns1__APIRequest (39)
/* ns1:APIRequest */
class SOAP_CMAC ns1__APIRequest
{
public:
	class ns1__APIRequestHeader *header;	/* optional element of type ns1:APIRequestHeader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__APIRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__APIRequest(): header(NULL), soap(NULL) { ns1__APIRequest::soap_default(NULL); }
	virtual ~ns1__APIRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__APIRequestHeader
#define SOAP_TYPE_ns1__APIRequestHeader (40)
/* ns1:APIRequestHeader */
class SOAP_CMAC ns1__APIRequestHeader
{
public:
	LONG64 clientStamp;	/* required element of type xsd:long */
	std::string *sessionToken;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__APIRequestHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__APIRequestHeader(): sessionToken(NULL), soap(NULL) { ns1__APIRequestHeader::soap_default(NULL); }
	virtual ~ns1__APIRequestHeader() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BFEvent
#define SOAP_TYPE_ns1__BFEvent (42)
/* ns1:BFEvent */
class SOAP_CMAC ns1__BFEvent
{
public:
	int eventId;	/* required element of type xsd:int */
	std::string *eventName;	/* optional element of type xsd:string */
	int eventTypeId;	/* required element of type xsd:int */
	int menuLevel;	/* required element of type xsd:int */
	int orderIndex;	/* required element of type xsd:int */
	time_t startTime;	/* required element of type xsd:dateTime */
	std::string *timezone;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__BFEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BFEvent(): eventName(NULL), timezone(NULL), soap(NULL) { ns1__BFEvent::soap_default(NULL); }
	virtual ~ns1__BFEvent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfBFEvent
#define SOAP_TYPE_ns1__ArrayOfBFEvent (43)
/* ns1:ArrayOfBFEvent */
class SOAP_CMAC ns1__ArrayOfBFEvent
{
public:
	std::vector<ns1__BFEvent * >ns1__BFEvent_;	/* optional element of type ns1:BFEvent */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__ArrayOfBFEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfBFEvent(): soap(NULL) { ns1__ArrayOfBFEvent::soap_default(NULL); }
	virtual ~ns1__ArrayOfBFEvent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MarketSummary
#define SOAP_TYPE_ns1__MarketSummary (44)
/* ns1:MarketSummary */
class SOAP_CMAC ns1__MarketSummary
{
public:
	int eventTypeId;	/* required element of type xsd:int */
	int marketId;	/* required element of type xsd:int */
	std::string *marketName;	/* optional element of type xsd:string */
	enum ns1__MarketTypeEnum marketType;	/* required element of type ns1:MarketTypeEnum */
	enum ns1__MarketTypeVariantEnum marketTypeVariant;	/* required element of type ns1:MarketTypeVariantEnum */
	int menuLevel;	/* required element of type xsd:int */
	int orderIndex;	/* required element of type xsd:int */
	time_t startTime;	/* required element of type xsd:dateTime */
	std::string *timezone;	/* optional element of type xsd:string */
	std::string *venue;	/* optional element of type xsd:string */
	int betDelay;	/* required element of type xsd:int */
	int numberOfWinners;	/* required element of type xsd:int */
	int eventParentId;	/* required element of type xsd:int */
	int exchangeId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__MarketSummary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MarketSummary(): marketName(NULL), timezone(NULL), venue(NULL), soap(NULL) { ns1__MarketSummary::soap_default(NULL); }
	virtual ~ns1__MarketSummary() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfMarketSummary
#define SOAP_TYPE_ns1__ArrayOfMarketSummary (45)
/* ns1:ArrayOfMarketSummary */
class SOAP_CMAC ns1__ArrayOfMarketSummary
{
public:
	std::vector<ns1__MarketSummary * >ns1__MarketSummary_;	/* optional element of type ns1:MarketSummary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__ArrayOfMarketSummary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfMarketSummary(): soap(NULL) { ns1__ArrayOfMarketSummary::soap_default(NULL); }
	virtual ~ns1__ArrayOfMarketSummary() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CouponLink
#define SOAP_TYPE_ns1__CouponLink (46)
/* ns1:CouponLink */
class SOAP_CMAC ns1__CouponLink
{
public:
	int couponId;	/* required element of type xsd:int */
	std::string *couponName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__CouponLink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CouponLink(): couponName(NULL), soap(NULL) { ns1__CouponLink::soap_default(NULL); }
	virtual ~ns1__CouponLink() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfCouponLinks
#define SOAP_TYPE_ns1__ArrayOfCouponLinks (47)
/* ns1:ArrayOfCouponLinks */
class SOAP_CMAC ns1__ArrayOfCouponLinks
{
public:
	std::vector<ns1__CouponLink * >ns1__CouponLink_;	/* optional element of type ns1:CouponLink */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__ArrayOfCouponLinks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfCouponLinks(): soap(NULL) { ns1__ArrayOfCouponLinks::soap_default(NULL); }
	virtual ~ns1__ArrayOfCouponLinks() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EventType
#define SOAP_TYPE_ns1__EventType (50)
/* ns1:EventType */
class SOAP_CMAC ns1__EventType
{
public:
	int id;	/* required element of type xsd:int */
	std::string *name;	/* optional element of type xsd:string */
	int nextMarketId;	/* required element of type xsd:int */
	int exchangeId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__EventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EventType(): name(NULL), soap(NULL) { ns1__EventType::soap_default(NULL); }
	virtual ~ns1__EventType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfEventType
#define SOAP_TYPE_ns1__ArrayOfEventType (51)
/* ns1:ArrayOfEventType */
class SOAP_CMAC ns1__ArrayOfEventType
{
public:
	std::vector<ns1__EventType * >ns1__EventType_;	/* optional element of type ns1:EventType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__ArrayOfEventType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfEventType(): soap(NULL) { ns1__ArrayOfEventType::soap_default(NULL); }
	virtual ~ns1__ArrayOfEventType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Runner
#define SOAP_TYPE_ns1__Runner (53)
/* ns1:Runner */
class SOAP_CMAC ns1__Runner
{
public:
	int asianLineId;	/* required element of type xsd:int */
	double handicap;	/* required element of type xsd:double */
	std::string *name;	/* optional element of type xsd:string */
	int selectionId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__Runner */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Runner(): name(NULL), soap(NULL) { ns1__Runner::soap_default(NULL); }
	virtual ~ns1__Runner() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Subscription
#define SOAP_TYPE_ns1__Subscription (55)
/* ns1:Subscription */
class SOAP_CMAC ns1__Subscription
{
public:
	double billingAmount;	/* required element of type xsd:double */
	time_t billingDate;	/* required element of type xsd:dateTime */
	enum ns1__BillingPeriodEnum billingPeriod;	/* required element of type ns1:BillingPeriodEnum */
	int productId;	/* required element of type xsd:int */
	std::string *productName;	/* optional element of type xsd:string */
	class ns1__ArrayOfServiceCall *services;	/* optional element of type ns1:ArrayOfServiceCall */
	double setupCharge;	/* required element of type xsd:double */
	bool setupChargeActive;	/* required element of type xsd:boolean */
	enum ns1__SubscriptionStatusEnum status;	/* required element of type ns1:SubscriptionStatusEnum */
	time_t subscribedDate;	/* required element of type xsd:dateTime */
	bool vatEnabled;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__Subscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Subscription(): productName(NULL), services(NULL), soap(NULL) { ns1__Subscription::soap_default(NULL); }
	virtual ~ns1__Subscription() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ServiceCall
#define SOAP_TYPE_ns1__ServiceCall (56)
/* ns1:ServiceCall */
class SOAP_CMAC ns1__ServiceCall
{
public:
	int maxUsages;	/* required element of type xsd:int */
	LONG64 period;	/* required element of type xsd:long */
	time_t periodExpiry;	/* required element of type xsd:dateTime */
	enum ns1__ServiceEnum serviceType;	/* required element of type ns1:ServiceEnum */
	int usageCount;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__ServiceCall */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ServiceCall(): soap(NULL) { ns1__ServiceCall::soap_default(NULL); }
	virtual ~ns1__ServiceCall() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfServiceCall
#define SOAP_TYPE_ns1__ArrayOfServiceCall (57)
/* ns1:ArrayOfServiceCall */
class SOAP_CMAC ns1__ArrayOfServiceCall
{
public:
	std::vector<ns1__ServiceCall * >ns1__ServiceCall_;	/* optional element of type ns1:ServiceCall */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns1__ArrayOfServiceCall */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfServiceCall(): soap(NULL) { ns1__ArrayOfServiceCall::soap_default(NULL); }
	virtual ~ns1__ArrayOfServiceCall() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfSubscription
#define SOAP_TYPE_ns1__ArrayOfSubscription (58)
/* ns1:ArrayOfSubscription */
class SOAP_CMAC ns1__ArrayOfSubscription
{
public:
	std::vector<ns1__Subscription * >ns1__Subscription_;	/* optional element of type ns1:Subscription */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__ArrayOfSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfSubscription(): soap(NULL) { ns1__ArrayOfSubscription::soap_default(NULL); }
	virtual ~ns1__ArrayOfSubscription() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PaymentCard
#define SOAP_TYPE_ns1__PaymentCard (70)
/* ns1:PaymentCard */
class SOAP_CMAC ns1__PaymentCard
{
public:
	std::string nickName;	/* required element of type xsd:string */
	std::string cardShortNumber;	/* required element of type xsd:string */
	std::string expiryDate;	/* required element of type xsd:string */
	std::string *startDate;	/* optional element of type xsd:string */
	std::string *issueNumber;	/* optional element of type xsd:string */
	enum ns1__CardTypeEnum cardType;	/* required element of type ns1:CardTypeEnum */
	std::string *issuingCountryIso3;	/* optional element of type xsd:string */
	double *totalDeposits;	/* optional element of type xsd:double */
	double *totalWithdrawals;	/* optional element of type xsd:double */
	double *netDeposits;	/* optional element of type xsd:double */
	std::string *validationStatus;	/* optional element of type xsd:string */
	std::string billingName;	/* required element of type xsd:string */
	std::string *billingAddress1;	/* optional element of type xsd:string */
	std::string *billingAddress2;	/* optional element of type xsd:string */
	std::string *billingAddress3;	/* optional element of type xsd:string */
	std::string *billingAddress4;	/* optional element of type xsd:string */
	std::string *town;	/* optional element of type xsd:string */
	std::string *county;	/* optional element of type xsd:string */
	std::string *postcode;	/* optional element of type xsd:string */
	std::string *billingCountryIso3;	/* optional element of type xsd:string */
	enum ns1__PaymentCardStatusEnum cardStatus;	/* required element of type ns1:PaymentCardStatusEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns1__PaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PaymentCard(): startDate(NULL), issueNumber(NULL), issuingCountryIso3(NULL), totalDeposits(NULL), totalWithdrawals(NULL), netDeposits(NULL), validationStatus(NULL), billingAddress1(NULL), billingAddress2(NULL), billingAddress3(NULL), billingAddress4(NULL), town(NULL), county(NULL), postcode(NULL), billingCountryIso3(NULL), soap(NULL) { ns1__PaymentCard::soap_default(NULL); }
	virtual ~ns1__PaymentCard() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfPaymentCard
#define SOAP_TYPE_ns1__ArrayOfPaymentCard (71)
/* ns1:ArrayOfPaymentCard */
class SOAP_CMAC ns1__ArrayOfPaymentCard
{
public:
	std::vector<ns1__PaymentCard * >ns1__PaymentCard_;	/* optional element of type ns1:PaymentCard */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__ArrayOfPaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfPaymentCard(): soap(NULL) { ns1__ArrayOfPaymentCard::soap_default(NULL); }
	virtual ~ns1__ArrayOfPaymentCard() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfBankAccountDetailsField
#define SOAP_TYPE_ns1__ArrayOfBankAccountDetailsField (76)
/* ns1:ArrayOfBankAccountDetailsField */
class SOAP_CMAC ns1__ArrayOfBankAccountDetailsField
{
public:
	std::vector<class ns1__BankAccountDetailsField * >ns1__BankAccountDetailsField_;	/* optional element of type ns1:BankAccountDetailsField */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns1__ArrayOfBankAccountDetailsField */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfBankAccountDetailsField(): soap(NULL) { ns1__ArrayOfBankAccountDetailsField::soap_default(NULL); }
	virtual ~ns1__ArrayOfBankAccountDetailsField() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AbstractField
#define SOAP_TYPE_ns1__AbstractField (78)
/* ns1:AbstractField */
class SOAP_CMAC ns1__AbstractField
{
public:
	bool required;	/* required element of type xsd:boolean */
	bool readOnly;	/* required element of type xsd:boolean */
	int size;	/* required element of type xsd:int */
	int minLength;	/* required element of type xsd:int */
	int maxLength;	/* required element of type xsd:int */
	std::string regExp;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns1__AbstractField */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AbstractField(): soap(NULL) { ns1__AbstractField::soap_default(NULL); }
	virtual ~ns1__AbstractField() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BasicBankAccountDetails
#define SOAP_TYPE_ns1__BasicBankAccountDetails (79)
/* ns1:BasicBankAccountDetails */
class SOAP_CMAC ns1__BasicBankAccountDetails
{
public:
	std::string *bankName;	/* optional element of type xsd:string */
	std::string *accountHoldingBranch;	/* optional element of type xsd:string */
	std::string *bankGiroCreditNumber;	/* optional element of type xsd:string */
	std::string *accountNumber;	/* optional element of type xsd:string */
	std::string *sortCode;	/* optional element of type xsd:string */
	std::string *bankCode;	/* optional element of type xsd:string */
	std::string *blzCode;	/* optional element of type xsd:string */
	std::string *bankBsb;	/* optional element of type xsd:string */
	std::string *branchCode;	/* optional element of type xsd:string */
	std::string *bankLocationIso3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns1__BasicBankAccountDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BasicBankAccountDetails(): bankName(NULL), accountHoldingBranch(NULL), bankGiroCreditNumber(NULL), accountNumber(NULL), sortCode(NULL), bankCode(NULL), blzCode(NULL), bankBsb(NULL), branchCode(NULL), bankLocationIso3(NULL), soap(NULL) { ns1__BasicBankAccountDetails::soap_default(NULL); }
	virtual ~ns1__BasicBankAccountDetails() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Currency
#define SOAP_TYPE_ns1__Currency (88)
/* ns1:Currency */
class SOAP_CMAC ns1__Currency
{
public:
	std::string *currencyCode;	/* optional element of type xsd:string */
	double rateGBP;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ns1__Currency */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Currency(): currencyCode(NULL), soap(NULL) { ns1__Currency::soap_default(NULL); }
	virtual ~ns1__Currency() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfCurrency
#define SOAP_TYPE_ns1__ArrayOfCurrency (89)
/* ns1:ArrayOfCurrency */
class SOAP_CMAC ns1__ArrayOfCurrency
{
public:
	std::vector<ns1__Currency * >ns1__Currency_;	/* optional element of type ns1:Currency */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ns1__ArrayOfCurrency */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfCurrency(): soap(NULL) { ns1__ArrayOfCurrency::soap_default(NULL); }
	virtual ~ns1__ArrayOfCurrency() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfCurrencyV2
#define SOAP_TYPE_ns1__ArrayOfCurrencyV2 (93)
/* ns1:ArrayOfCurrencyV2 */
class SOAP_CMAC ns1__ArrayOfCurrencyV2
{
public:
	std::vector<class ns1__CurrencyV2 * >ns1__CurrencyV2_;	/* optional element of type ns1:CurrencyV2 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns1__ArrayOfCurrencyV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfCurrencyV2(): soap(NULL) { ns1__ArrayOfCurrencyV2::soap_default(NULL); }
	virtual ~ns1__ArrayOfCurrencyV2() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfValidationErrorsEnum
#define SOAP_TYPE_ns1__ArrayOfValidationErrorsEnum (104)
/* ns1:ArrayOfValidationErrorsEnum */
class SOAP_CMAC ns1__ArrayOfValidationErrorsEnum
{
public:
	std::vector<enum ns1__ValidationErrorsEnum >ns1__ValidationErrorsEnum;	/* optional element of type ns1:ValidationErrorsEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns1__ArrayOfValidationErrorsEnum */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfValidationErrorsEnum(): soap(NULL) { ns1__ArrayOfValidationErrorsEnum::soap_default(NULL); }
	virtual ~ns1__ArrayOfValidationErrorsEnum() { }
};
#endif

#ifndef SOAP_TYPE__ns2__login
#define SOAP_TYPE__ns2__login (112)
/* ns2:login */
class SOAP_CMAC _ns2__login
{
public:
	ns1__LoginReq *request;	/* required element of type ns1:LoginReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE__ns2__login */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__login(): request(NULL), soap(NULL) { _ns2__login::soap_default(NULL); }
	virtual ~_ns2__login() { }
};
#endif

#ifndef SOAP_TYPE__ns2__loginResponse
#define SOAP_TYPE__ns2__loginResponse (113)
/* ns2:loginResponse */
class SOAP_CMAC _ns2__loginResponse
{
public:
	class ns1__LoginResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:LoginResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE__ns2__loginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__loginResponse(): Result(NULL), soap(NULL) { _ns2__loginResponse::soap_default(NULL); }
	virtual ~_ns2__loginResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__retrieveLIMBMessage
#define SOAP_TYPE__ns2__retrieveLIMBMessage (114)
/* ns2:retrieveLIMBMessage */
class SOAP_CMAC _ns2__retrieveLIMBMessage
{
public:
	class ns1__RetrieveLIMBMessageReq *request;	/* required element of type ns1:RetrieveLIMBMessageReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE__ns2__retrieveLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__retrieveLIMBMessage(): request(NULL), soap(NULL) { _ns2__retrieveLIMBMessage::soap_default(NULL); }
	virtual ~_ns2__retrieveLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE__ns2__retrieveLIMBMessageResponse
#define SOAP_TYPE__ns2__retrieveLIMBMessageResponse (115)
/* ns2:retrieveLIMBMessageResponse */
class SOAP_CMAC _ns2__retrieveLIMBMessageResponse
{
public:
	class ns1__RetrieveLIMBMessageResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:RetrieveLIMBMessageResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE__ns2__retrieveLIMBMessageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__retrieveLIMBMessageResponse(): Result(NULL), soap(NULL) { _ns2__retrieveLIMBMessageResponse::soap_default(NULL); }
	virtual ~_ns2__retrieveLIMBMessageResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__submitLIMBMessage
#define SOAP_TYPE__ns2__submitLIMBMessage (116)
/* ns2:submitLIMBMessage */
class SOAP_CMAC _ns2__submitLIMBMessage
{
public:
	class ns1__SubmitLIMBMessageReq *request;	/* required element of type ns1:SubmitLIMBMessageReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE__ns2__submitLIMBMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__submitLIMBMessage(): request(NULL), soap(NULL) { _ns2__submitLIMBMessage::soap_default(NULL); }
	virtual ~_ns2__submitLIMBMessage() { }
};
#endif

#ifndef SOAP_TYPE__ns2__submitLIMBMessageResponse
#define SOAP_TYPE__ns2__submitLIMBMessageResponse (117)
/* ns2:submitLIMBMessageResponse */
class SOAP_CMAC _ns2__submitLIMBMessageResponse
{
public:
	class ns1__SubmitLIMBMessageResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:SubmitLIMBMessageResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE__ns2__submitLIMBMessageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__submitLIMBMessageResponse(): Result(NULL), soap(NULL) { _ns2__submitLIMBMessageResponse::soap_default(NULL); }
	virtual ~_ns2__submitLIMBMessageResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__logout
#define SOAP_TYPE__ns2__logout (118)
/* ns2:logout */
class SOAP_CMAC _ns2__logout
{
public:
	class ns1__LogoutReq *request;	/* required element of type ns1:LogoutReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE__ns2__logout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__logout(): request(NULL), soap(NULL) { _ns2__logout::soap_default(NULL); }
	virtual ~_ns2__logout() { }
};
#endif

#ifndef SOAP_TYPE__ns2__logoutResponse
#define SOAP_TYPE__ns2__logoutResponse (119)
/* ns2:logoutResponse */
class SOAP_CMAC _ns2__logoutResponse
{
public:
	class ns1__LogoutResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:LogoutResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE__ns2__logoutResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__logoutResponse(): Result(NULL), soap(NULL) { _ns2__logoutResponse::soap_default(NULL); }
	virtual ~_ns2__logoutResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__keepAlive
#define SOAP_TYPE__ns2__keepAlive (120)
/* ns2:keepAlive */
class SOAP_CMAC _ns2__keepAlive
{
public:
	class ns1__KeepAliveReq *request;	/* required element of type ns1:KeepAliveReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE__ns2__keepAlive */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__keepAlive(): request(NULL), soap(NULL) { _ns2__keepAlive::soap_default(NULL); }
	virtual ~_ns2__keepAlive() { }
};
#endif

#ifndef SOAP_TYPE__ns2__keepAliveResponse
#define SOAP_TYPE__ns2__keepAliveResponse (121)
/* ns2:keepAliveResponse */
class SOAP_CMAC _ns2__keepAliveResponse
{
public:
	class ns1__KeepAliveResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:KeepAliveResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE__ns2__keepAliveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__keepAliveResponse(): Result(NULL), soap(NULL) { _ns2__keepAliveResponse::soap_default(NULL); }
	virtual ~_ns2__keepAliveResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getEvents
#define SOAP_TYPE__ns2__getEvents (122)
/* ns2:getEvents */
class SOAP_CMAC _ns2__getEvents
{
public:
	class ns1__GetEventsReq *request;	/* required element of type ns1:GetEventsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE__ns2__getEvents */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getEvents(): request(NULL), soap(NULL) { _ns2__getEvents::soap_default(NULL); }
	virtual ~_ns2__getEvents() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getEventsResponse
#define SOAP_TYPE__ns2__getEventsResponse (123)
/* ns2:getEventsResponse */
class SOAP_CMAC _ns2__getEventsResponse
{
public:
	class ns1__GetEventsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GetEventsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE__ns2__getEventsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getEventsResponse(): Result(NULL), soap(NULL) { _ns2__getEventsResponse::soap_default(NULL); }
	virtual ~_ns2__getEventsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getActiveEventTypes
#define SOAP_TYPE__ns2__getActiveEventTypes (124)
/* ns2:getActiveEventTypes */
class SOAP_CMAC _ns2__getActiveEventTypes
{
public:
	class ns1__GetEventTypesReq *request;	/* required element of type ns1:GetEventTypesReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE__ns2__getActiveEventTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getActiveEventTypes(): request(NULL), soap(NULL) { _ns2__getActiveEventTypes::soap_default(NULL); }
	virtual ~_ns2__getActiveEventTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getActiveEventTypesResponse
#define SOAP_TYPE__ns2__getActiveEventTypesResponse (125)
/* ns2:getActiveEventTypesResponse */
class SOAP_CMAC _ns2__getActiveEventTypesResponse
{
public:
	class ns1__GetEventTypesResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GetEventTypesResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 125; } /* = unique id SOAP_TYPE__ns2__getActiveEventTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getActiveEventTypesResponse(): Result(NULL), soap(NULL) { _ns2__getActiveEventTypesResponse::soap_default(NULL); }
	virtual ~_ns2__getActiveEventTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getAllEventTypes
#define SOAP_TYPE__ns2__getAllEventTypes (126)
/* ns2:getAllEventTypes */
class SOAP_CMAC _ns2__getAllEventTypes
{
public:
	ns1__GetEventTypesReq *request;	/* required element of type ns1:GetEventTypesReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 126; } /* = unique id SOAP_TYPE__ns2__getAllEventTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getAllEventTypes(): request(NULL), soap(NULL) { _ns2__getAllEventTypes::soap_default(NULL); }
	virtual ~_ns2__getAllEventTypes() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getAllEventTypesResponse
#define SOAP_TYPE__ns2__getAllEventTypesResponse (127)
/* ns2:getAllEventTypesResponse */
class SOAP_CMAC _ns2__getAllEventTypesResponse
{
public:
	ns1__GetEventTypesResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GetEventTypesResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 127; } /* = unique id SOAP_TYPE__ns2__getAllEventTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getAllEventTypesResponse(): Result(NULL), soap(NULL) { _ns2__getAllEventTypesResponse::soap_default(NULL); }
	virtual ~_ns2__getAllEventTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getSubscriptionInfo
#define SOAP_TYPE__ns2__getSubscriptionInfo (128)
/* ns2:getSubscriptionInfo */
class SOAP_CMAC _ns2__getSubscriptionInfo
{
public:
	class ns1__GetSubscriptionInfoReq *request;	/* required element of type ns1:GetSubscriptionInfoReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 128; } /* = unique id SOAP_TYPE__ns2__getSubscriptionInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getSubscriptionInfo(): request(NULL), soap(NULL) { _ns2__getSubscriptionInfo::soap_default(NULL); }
	virtual ~_ns2__getSubscriptionInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getSubscriptionInfoResponse
#define SOAP_TYPE__ns2__getSubscriptionInfoResponse (129)
/* ns2:getSubscriptionInfoResponse */
class SOAP_CMAC _ns2__getSubscriptionInfoResponse
{
public:
	class ns1__GetSubscriptionInfoResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GetSubscriptionInfoResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 129; } /* = unique id SOAP_TYPE__ns2__getSubscriptionInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getSubscriptionInfoResponse(): Result(NULL), soap(NULL) { _ns2__getSubscriptionInfoResponse::soap_default(NULL); }
	virtual ~_ns2__getSubscriptionInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__depositFromPaymentCard
#define SOAP_TYPE__ns2__depositFromPaymentCard (130)
/* ns2:depositFromPaymentCard */
class SOAP_CMAC _ns2__depositFromPaymentCard
{
public:
	class ns1__DepositFromPaymentCardReq *request;	/* required element of type ns1:DepositFromPaymentCardReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 130; } /* = unique id SOAP_TYPE__ns2__depositFromPaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__depositFromPaymentCard(): request(NULL), soap(NULL) { _ns2__depositFromPaymentCard::soap_default(NULL); }
	virtual ~_ns2__depositFromPaymentCard() { }
};
#endif

#ifndef SOAP_TYPE__ns2__depositFromPaymentCardResponse
#define SOAP_TYPE__ns2__depositFromPaymentCardResponse (131)
/* ns2:depositFromPaymentCardResponse */
class SOAP_CMAC _ns2__depositFromPaymentCardResponse
{
public:
	class ns1__DepositFromPaymentCardResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:DepositFromPaymentCardResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 131; } /* = unique id SOAP_TYPE__ns2__depositFromPaymentCardResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__depositFromPaymentCardResponse(): Result(NULL), soap(NULL) { _ns2__depositFromPaymentCardResponse::soap_default(NULL); }
	virtual ~_ns2__depositFromPaymentCardResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__addPaymentCard
#define SOAP_TYPE__ns2__addPaymentCard (132)
/* ns2:addPaymentCard */
class SOAP_CMAC _ns2__addPaymentCard
{
public:
	class ns1__AddPaymentCardReq *request;	/* required element of type ns1:AddPaymentCardReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique id SOAP_TYPE__ns2__addPaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__addPaymentCard(): request(NULL), soap(NULL) { _ns2__addPaymentCard::soap_default(NULL); }
	virtual ~_ns2__addPaymentCard() { }
};
#endif

#ifndef SOAP_TYPE__ns2__addPaymentCardResponse
#define SOAP_TYPE__ns2__addPaymentCardResponse (133)
/* ns2:addPaymentCardResponse */
class SOAP_CMAC _ns2__addPaymentCardResponse
{
public:
	class ns1__AddPaymentCardResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:AddPaymentCardResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 133; } /* = unique id SOAP_TYPE__ns2__addPaymentCardResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__addPaymentCardResponse(): Result(NULL), soap(NULL) { _ns2__addPaymentCardResponse::soap_default(NULL); }
	virtual ~_ns2__addPaymentCardResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__deletePaymentCard
#define SOAP_TYPE__ns2__deletePaymentCard (134)
/* ns2:deletePaymentCard */
class SOAP_CMAC _ns2__deletePaymentCard
{
public:
	class ns1__DeletePaymentCardReq *request;	/* required element of type ns1:DeletePaymentCardReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 134; } /* = unique id SOAP_TYPE__ns2__deletePaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__deletePaymentCard(): request(NULL), soap(NULL) { _ns2__deletePaymentCard::soap_default(NULL); }
	virtual ~_ns2__deletePaymentCard() { }
};
#endif

#ifndef SOAP_TYPE__ns2__deletePaymentCardResponse
#define SOAP_TYPE__ns2__deletePaymentCardResponse (135)
/* ns2:deletePaymentCardResponse */
class SOAP_CMAC _ns2__deletePaymentCardResponse
{
public:
	class ns1__DeletePaymentCardResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:DeletePaymentCardResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 135; } /* = unique id SOAP_TYPE__ns2__deletePaymentCardResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__deletePaymentCardResponse(): Result(NULL), soap(NULL) { _ns2__deletePaymentCardResponse::soap_default(NULL); }
	virtual ~_ns2__deletePaymentCardResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__updatePaymentCard
#define SOAP_TYPE__ns2__updatePaymentCard (136)
/* ns2:updatePaymentCard */
class SOAP_CMAC _ns2__updatePaymentCard
{
public:
	class ns1__UpdatePaymentCardReq *request;	/* required element of type ns1:UpdatePaymentCardReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 136; } /* = unique id SOAP_TYPE__ns2__updatePaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__updatePaymentCard(): request(NULL), soap(NULL) { _ns2__updatePaymentCard::soap_default(NULL); }
	virtual ~_ns2__updatePaymentCard() { }
};
#endif

#ifndef SOAP_TYPE__ns2__updatePaymentCardResponse
#define SOAP_TYPE__ns2__updatePaymentCardResponse (137)
/* ns2:updatePaymentCardResponse */
class SOAP_CMAC _ns2__updatePaymentCardResponse
{
public:
	class ns1__UpdatePaymentCardResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:UpdatePaymentCardResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 137; } /* = unique id SOAP_TYPE__ns2__updatePaymentCardResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__updatePaymentCardResponse(): Result(NULL), soap(NULL) { _ns2__updatePaymentCardResponse::soap_default(NULL); }
	virtual ~_ns2__updatePaymentCardResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getPaymentCard
#define SOAP_TYPE__ns2__getPaymentCard (138)
/* ns2:getPaymentCard */
class SOAP_CMAC _ns2__getPaymentCard
{
public:
	class ns1__GetPaymentCardReq *request;	/* required element of type ns1:GetPaymentCardReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique id SOAP_TYPE__ns2__getPaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getPaymentCard(): request(NULL), soap(NULL) { _ns2__getPaymentCard::soap_default(NULL); }
	virtual ~_ns2__getPaymentCard() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getPaymentCardResponse
#define SOAP_TYPE__ns2__getPaymentCardResponse (139)
/* ns2:getPaymentCardResponse */
class SOAP_CMAC _ns2__getPaymentCardResponse
{
public:
	class ns1__GetPaymentCardResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GetPaymentCardResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 139; } /* = unique id SOAP_TYPE__ns2__getPaymentCardResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getPaymentCardResponse(): Result(NULL), soap(NULL) { _ns2__getPaymentCardResponse::soap_default(NULL); }
	virtual ~_ns2__getPaymentCardResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__withdrawToPaymentCard
#define SOAP_TYPE__ns2__withdrawToPaymentCard (140)
/* ns2:withdrawToPaymentCard */
class SOAP_CMAC _ns2__withdrawToPaymentCard
{
public:
	class ns1__WithdrawToPaymentCardReq *request;	/* required element of type ns1:WithdrawToPaymentCardReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 140; } /* = unique id SOAP_TYPE__ns2__withdrawToPaymentCard */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__withdrawToPaymentCard(): request(NULL), soap(NULL) { _ns2__withdrawToPaymentCard::soap_default(NULL); }
	virtual ~_ns2__withdrawToPaymentCard() { }
};
#endif

#ifndef SOAP_TYPE__ns2__withdrawToPaymentCardResponse
#define SOAP_TYPE__ns2__withdrawToPaymentCardResponse (141)
/* ns2:withdrawToPaymentCardResponse */
class SOAP_CMAC _ns2__withdrawToPaymentCardResponse
{
public:
	class ns1__WithdrawToPaymentCardResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:WithdrawToPaymentCardResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 141; } /* = unique id SOAP_TYPE__ns2__withdrawToPaymentCardResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__withdrawToPaymentCardResponse(): Result(NULL), soap(NULL) { _ns2__withdrawToPaymentCardResponse::soap_default(NULL); }
	virtual ~_ns2__withdrawToPaymentCardResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__selfExclude
#define SOAP_TYPE__ns2__selfExclude (142)
/* ns2:selfExclude */
class SOAP_CMAC _ns2__selfExclude
{
public:
	class ns1__SelfExcludeReq *request;	/* required element of type ns1:SelfExcludeReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 142; } /* = unique id SOAP_TYPE__ns2__selfExclude */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__selfExclude(): request(NULL), soap(NULL) { _ns2__selfExclude::soap_default(NULL); }
	virtual ~_ns2__selfExclude() { }
};
#endif

#ifndef SOAP_TYPE__ns2__selfExcludeResponse
#define SOAP_TYPE__ns2__selfExcludeResponse (143)
/* ns2:selfExcludeResponse */
class SOAP_CMAC _ns2__selfExcludeResponse
{
public:
	class ns1__SelfExcludeResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:SelfExcludeResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 143; } /* = unique id SOAP_TYPE__ns2__selfExcludeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__selfExcludeResponse(): Result(NULL), soap(NULL) { _ns2__selfExcludeResponse::soap_default(NULL); }
	virtual ~_ns2__selfExcludeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__convertCurrency
#define SOAP_TYPE__ns2__convertCurrency (144)
/* ns2:convertCurrency */
class SOAP_CMAC _ns2__convertCurrency
{
public:
	class ns1__ConvertCurrencyReq *request;	/* required element of type ns1:ConvertCurrencyReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 144; } /* = unique id SOAP_TYPE__ns2__convertCurrency */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__convertCurrency(): request(NULL), soap(NULL) { _ns2__convertCurrency::soap_default(NULL); }
	virtual ~_ns2__convertCurrency() { }
};
#endif

#ifndef SOAP_TYPE__ns2__convertCurrencyResponse
#define SOAP_TYPE__ns2__convertCurrencyResponse (145)
/* ns2:convertCurrencyResponse */
class SOAP_CMAC _ns2__convertCurrencyResponse
{
public:
	class ns1__ConvertCurrencyResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ConvertCurrencyResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 145; } /* = unique id SOAP_TYPE__ns2__convertCurrencyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__convertCurrencyResponse(): Result(NULL), soap(NULL) { _ns2__convertCurrencyResponse::soap_default(NULL); }
	virtual ~_ns2__convertCurrencyResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getAllCurrencies
#define SOAP_TYPE__ns2__getAllCurrencies (146)
/* ns2:getAllCurrencies */
class SOAP_CMAC _ns2__getAllCurrencies
{
public:
	class ns1__GetCurrenciesReq *request;	/* required element of type ns1:GetCurrenciesReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 146; } /* = unique id SOAP_TYPE__ns2__getAllCurrencies */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getAllCurrencies(): request(NULL), soap(NULL) { _ns2__getAllCurrencies::soap_default(NULL); }
	virtual ~_ns2__getAllCurrencies() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getAllCurrenciesResponse
#define SOAP_TYPE__ns2__getAllCurrenciesResponse (147)
/* ns2:getAllCurrenciesResponse */
class SOAP_CMAC _ns2__getAllCurrenciesResponse
{
public:
	class ns1__GetCurrenciesResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GetCurrenciesResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 147; } /* = unique id SOAP_TYPE__ns2__getAllCurrenciesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getAllCurrenciesResponse(): Result(NULL), soap(NULL) { _ns2__getAllCurrenciesResponse::soap_default(NULL); }
	virtual ~_ns2__getAllCurrenciesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getAllCurrenciesV2
#define SOAP_TYPE__ns2__getAllCurrenciesV2 (148)
/* ns2:getAllCurrenciesV2 */
class SOAP_CMAC _ns2__getAllCurrenciesV2
{
public:
	class ns1__GetCurrenciesV2Req *request;	/* required element of type ns1:GetCurrenciesV2Req */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 148; } /* = unique id SOAP_TYPE__ns2__getAllCurrenciesV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getAllCurrenciesV2(): request(NULL), soap(NULL) { _ns2__getAllCurrenciesV2::soap_default(NULL); }
	virtual ~_ns2__getAllCurrenciesV2() { }
};
#endif

#ifndef SOAP_TYPE__ns2__getAllCurrenciesV2Response
#define SOAP_TYPE__ns2__getAllCurrenciesV2Response (149)
/* ns2:getAllCurrenciesV2Response */
class SOAP_CMAC _ns2__getAllCurrenciesV2Response
{
public:
	class ns1__GetCurrenciesV2Resp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:GetCurrenciesV2Resp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique id SOAP_TYPE__ns2__getAllCurrenciesV2Response */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__getAllCurrenciesV2Response(): Result(NULL), soap(NULL) { _ns2__getAllCurrenciesV2Response::soap_default(NULL); }
	virtual ~_ns2__getAllCurrenciesV2Response() { }
};
#endif

#ifndef SOAP_TYPE__ns2__viewReferAndEarn
#define SOAP_TYPE__ns2__viewReferAndEarn (150)
/* ns2:viewReferAndEarn */
class SOAP_CMAC _ns2__viewReferAndEarn
{
public:
	class ns1__ViewReferAndEarnReq *request;	/* required element of type ns1:ViewReferAndEarnReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 150; } /* = unique id SOAP_TYPE__ns2__viewReferAndEarn */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__viewReferAndEarn(): request(NULL), soap(NULL) { _ns2__viewReferAndEarn::soap_default(NULL); }
	virtual ~_ns2__viewReferAndEarn() { }
};
#endif

#ifndef SOAP_TYPE__ns2__viewReferAndEarnResponse
#define SOAP_TYPE__ns2__viewReferAndEarnResponse (151)
/* ns2:viewReferAndEarnResponse */
class SOAP_CMAC _ns2__viewReferAndEarnResponse
{
public:
	class ns1__ViewReferAndEarnResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ViewReferAndEarnResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 151; } /* = unique id SOAP_TYPE__ns2__viewReferAndEarnResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__viewReferAndEarnResponse(): Result(NULL), soap(NULL) { _ns2__viewReferAndEarnResponse::soap_default(NULL); }
	virtual ~_ns2__viewReferAndEarnResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__viewProfile
#define SOAP_TYPE__ns2__viewProfile (152)
/* ns2:viewProfile */
class SOAP_CMAC _ns2__viewProfile
{
public:
	class ns1__ViewProfileReq *request;	/* required element of type ns1:ViewProfileReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 152; } /* = unique id SOAP_TYPE__ns2__viewProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__viewProfile(): request(NULL), soap(NULL) { _ns2__viewProfile::soap_default(NULL); }
	virtual ~_ns2__viewProfile() { }
};
#endif

#ifndef SOAP_TYPE__ns2__viewProfileResponse
#define SOAP_TYPE__ns2__viewProfileResponse (153)
/* ns2:viewProfileResponse */
class SOAP_CMAC _ns2__viewProfileResponse
{
public:
	class ns1__ViewProfileResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ViewProfileResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 153; } /* = unique id SOAP_TYPE__ns2__viewProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__viewProfileResponse(): Result(NULL), soap(NULL) { _ns2__viewProfileResponse::soap_default(NULL); }
	virtual ~_ns2__viewProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__withdrawByBankTransfer
#define SOAP_TYPE__ns2__withdrawByBankTransfer (154)
/* ns2:withdrawByBankTransfer */
class SOAP_CMAC _ns2__withdrawByBankTransfer
{
public:
	class ns1__WithdrawByBankTransferReq *request;	/* required element of type ns1:WithdrawByBankTransferReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 154; } /* = unique id SOAP_TYPE__ns2__withdrawByBankTransfer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__withdrawByBankTransfer(): request(NULL), soap(NULL) { _ns2__withdrawByBankTransfer::soap_default(NULL); }
	virtual ~_ns2__withdrawByBankTransfer() { }
};
#endif

#ifndef SOAP_TYPE__ns2__withdrawByBankTransferResponse
#define SOAP_TYPE__ns2__withdrawByBankTransferResponse (155)
/* ns2:withdrawByBankTransferResponse */
class SOAP_CMAC _ns2__withdrawByBankTransferResponse
{
public:
	class ns1__WithdrawByBankTransferResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:WithdrawByBankTransferResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 155; } /* = unique id SOAP_TYPE__ns2__withdrawByBankTransferResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__withdrawByBankTransferResponse(): Result(NULL), soap(NULL) { _ns2__withdrawByBankTransferResponse::soap_default(NULL); }
	virtual ~_ns2__withdrawByBankTransferResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__viewProfileV2
#define SOAP_TYPE__ns2__viewProfileV2 (156)
/* ns2:viewProfileV2 */
class SOAP_CMAC _ns2__viewProfileV2
{
public:
	class ns1__ViewProfileV2Req *request;	/* required element of type ns1:ViewProfileV2Req */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 156; } /* = unique id SOAP_TYPE__ns2__viewProfileV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__viewProfileV2(): request(NULL), soap(NULL) { _ns2__viewProfileV2::soap_default(NULL); }
	virtual ~_ns2__viewProfileV2() { }
};
#endif

#ifndef SOAP_TYPE__ns2__viewProfileV2Response
#define SOAP_TYPE__ns2__viewProfileV2Response (157)
/* ns2:viewProfileV2Response */
class SOAP_CMAC _ns2__viewProfileV2Response
{
public:
	class ns1__ViewProfileV2Resp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ViewProfileV2Resp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 157; } /* = unique id SOAP_TYPE__ns2__viewProfileV2Response */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__viewProfileV2Response(): Result(NULL), soap(NULL) { _ns2__viewProfileV2Response::soap_default(NULL); }
	virtual ~_ns2__viewProfileV2Response() { }
};
#endif

#ifndef SOAP_TYPE__ns2__modifyProfile
#define SOAP_TYPE__ns2__modifyProfile (158)
/* ns2:modifyProfile */
class SOAP_CMAC _ns2__modifyProfile
{
public:
	class ns1__ModifyProfileReq *request;	/* required element of type ns1:ModifyProfileReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 158; } /* = unique id SOAP_TYPE__ns2__modifyProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__modifyProfile(): request(NULL), soap(NULL) { _ns2__modifyProfile::soap_default(NULL); }
	virtual ~_ns2__modifyProfile() { }
};
#endif

#ifndef SOAP_TYPE__ns2__modifyProfileResponse
#define SOAP_TYPE__ns2__modifyProfileResponse (159)
/* ns2:modifyProfileResponse */
class SOAP_CMAC _ns2__modifyProfileResponse
{
public:
	class ns1__ModifyProfileResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ModifyProfileResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 159; } /* = unique id SOAP_TYPE__ns2__modifyProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__modifyProfileResponse(): Result(NULL), soap(NULL) { _ns2__modifyProfileResponse::soap_default(NULL); }
	virtual ~_ns2__modifyProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__createAccount
#define SOAP_TYPE__ns2__createAccount (160)
/* ns2:createAccount */
class SOAP_CMAC _ns2__createAccount
{
public:
	class ns1__CreateAccountReq *request;	/* required element of type ns1:CreateAccountReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 160; } /* = unique id SOAP_TYPE__ns2__createAccount */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__createAccount(): request(NULL), soap(NULL) { _ns2__createAccount::soap_default(NULL); }
	virtual ~_ns2__createAccount() { }
};
#endif

#ifndef SOAP_TYPE__ns2__createAccountResponse
#define SOAP_TYPE__ns2__createAccountResponse (161)
/* ns2:createAccountResponse */
class SOAP_CMAC _ns2__createAccountResponse
{
public:
	class ns1__CreateAccountResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:CreateAccountResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 161; } /* = unique id SOAP_TYPE__ns2__createAccountResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__createAccountResponse(): Result(NULL), soap(NULL) { _ns2__createAccountResponse::soap_default(NULL); }
	virtual ~_ns2__createAccountResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__forgotPassword
#define SOAP_TYPE__ns2__forgotPassword (162)
/* ns2:forgotPassword */
class SOAP_CMAC _ns2__forgotPassword
{
public:
	class ns1__ForgotPasswordReq *request;	/* required element of type ns1:ForgotPasswordReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 162; } /* = unique id SOAP_TYPE__ns2__forgotPassword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__forgotPassword(): request(NULL), soap(NULL) { _ns2__forgotPassword::soap_default(NULL); }
	virtual ~_ns2__forgotPassword() { }
};
#endif

#ifndef SOAP_TYPE__ns2__forgotPasswordResponse
#define SOAP_TYPE__ns2__forgotPasswordResponse (163)
/* ns2:forgotPasswordResponse */
class SOAP_CMAC _ns2__forgotPasswordResponse
{
public:
	class ns1__ForgotPasswordResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ForgotPasswordResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 163; } /* = unique id SOAP_TYPE__ns2__forgotPasswordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__forgotPasswordResponse(): Result(NULL), soap(NULL) { _ns2__forgotPasswordResponse::soap_default(NULL); }
	virtual ~_ns2__forgotPasswordResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__modifyPassword
#define SOAP_TYPE__ns2__modifyPassword (164)
/* ns2:modifyPassword */
class SOAP_CMAC _ns2__modifyPassword
{
public:
	class ns1__ModifyPasswordReq *request;	/* required element of type ns1:ModifyPasswordReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique id SOAP_TYPE__ns2__modifyPassword */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__modifyPassword(): request(NULL), soap(NULL) { _ns2__modifyPassword::soap_default(NULL); }
	virtual ~_ns2__modifyPassword() { }
};
#endif

#ifndef SOAP_TYPE__ns2__modifyPasswordResponse
#define SOAP_TYPE__ns2__modifyPasswordResponse (165)
/* ns2:modifyPasswordResponse */
class SOAP_CMAC _ns2__modifyPasswordResponse
{
public:
	class ns1__ModifyPasswordResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ModifyPasswordResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 165; } /* = unique id SOAP_TYPE__ns2__modifyPasswordResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__modifyPasswordResponse(): Result(NULL), soap(NULL) { _ns2__modifyPasswordResponse::soap_default(NULL); }
	virtual ~_ns2__modifyPasswordResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__setChatName
#define SOAP_TYPE__ns2__setChatName (166)
/* ns2:setChatName */
class SOAP_CMAC _ns2__setChatName
{
public:
	class ns1__SetChatNameReq *request;	/* required element of type ns1:SetChatNameReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique id SOAP_TYPE__ns2__setChatName */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__setChatName(): request(NULL), soap(NULL) { _ns2__setChatName::soap_default(NULL); }
	virtual ~_ns2__setChatName() { }
};
#endif

#ifndef SOAP_TYPE__ns2__setChatNameResponse
#define SOAP_TYPE__ns2__setChatNameResponse (167)
/* ns2:setChatNameResponse */
class SOAP_CMAC _ns2__setChatNameResponse
{
public:
	class ns1__SetChatNameResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:SetChatNameResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique id SOAP_TYPE__ns2__setChatNameResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__setChatNameResponse(): Result(NULL), soap(NULL) { _ns2__setChatNameResponse::soap_default(NULL); }
	virtual ~_ns2__setChatNameResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns2__transferFunds
#define SOAP_TYPE__ns2__transferFunds (168)
/* ns2:transferFunds */
class SOAP_CMAC _ns2__transferFunds
{
public:
	class ns1__TransferFundsReq *request;	/* required element of type ns1:TransferFundsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique id SOAP_TYPE__ns2__transferFunds */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__transferFunds(): request(NULL), soap(NULL) { _ns2__transferFunds::soap_default(NULL); }
	virtual ~_ns2__transferFunds() { }
};
#endif

#ifndef SOAP_TYPE__ns2__transferFundsResponse
#define SOAP_TYPE__ns2__transferFundsResponse (169)
/* ns2:transferFundsResponse */
class SOAP_CMAC _ns2__transferFundsResponse
{
public:
	class ns1__TransferFundsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:TransferFundsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique id SOAP_TYPE__ns2__transferFundsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__transferFundsResponse(): Result(NULL), soap(NULL) { _ns2__transferFundsResponse::soap_default(NULL); }
	virtual ~_ns2__transferFundsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns3__APIResponse
#define SOAP_TYPE_ns3__APIResponse (170)
/* ns3:APIResponse */
class SOAP_CMAC ns3__APIResponse
{
public:
	class ns3__APIResponseHeader *header;	/* optional element of type ns3:APIResponseHeader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique id SOAP_TYPE_ns3__APIResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__APIResponse(): header(NULL), soap(NULL) { ns3__APIResponse::soap_default(NULL); }
	virtual ~ns3__APIResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns3__APIResponseHeader
#define SOAP_TYPE_ns3__APIResponseHeader (171)
/* ns3:APIResponseHeader */
class SOAP_CMAC ns3__APIResponseHeader
{
public:
	enum ns3__APIErrorEnum errorCode;	/* required element of type ns3:APIErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	std::string *sessionToken;	/* optional element of type xsd:string */
	time_t timestamp;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique id SOAP_TYPE_ns3__APIResponseHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__APIResponseHeader(): minorErrorCode(NULL), sessionToken(NULL), soap(NULL) { ns3__APIResponseHeader::soap_default(NULL); }
	virtual ~ns3__APIResponseHeader() { }
};
#endif

#ifndef SOAP_TYPE_ns3__APIRequest
#define SOAP_TYPE_ns3__APIRequest (172)
/* ns3:APIRequest */
class SOAP_CMAC ns3__APIRequest
{
public:
	class ns3__APIRequestHeader *header;	/* optional element of type ns3:APIRequestHeader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique id SOAP_TYPE_ns3__APIRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__APIRequest(): header(NULL), soap(NULL) { ns3__APIRequest::soap_default(NULL); }
	virtual ~ns3__APIRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns3__APIRequestHeader
#define SOAP_TYPE_ns3__APIRequestHeader (173)
/* ns3:APIRequestHeader */
class SOAP_CMAC ns3__APIRequestHeader
{
public:
	LONG64 clientStamp;	/* required element of type xsd:long */
	std::string *sessionToken;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique id SOAP_TYPE_ns3__APIRequestHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__APIRequestHeader(): sessionToken(NULL), soap(NULL) { ns3__APIRequestHeader::soap_default(NULL); }
	virtual ~ns3__APIRequestHeader() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MarketDisplayDetail
#define SOAP_TYPE_ns3__MarketDisplayDetail (177)
/* ns3:MarketDisplayDetail */
class SOAP_CMAC ns3__MarketDisplayDetail
{
public:
	int marketId;	/* required element of type xsd:int */
	class ns3__ArrayOfRacingSilk *racingSilks;	/* optional element of type ns3:ArrayOfRacingSilk */
	enum ns3__MarketDisplayErrorEnum errorCode;	/* required element of type ns3:MarketDisplayErrorEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique id SOAP_TYPE_ns3__MarketDisplayDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MarketDisplayDetail(): racingSilks(NULL), soap(NULL) { ns3__MarketDisplayDetail::soap_default(NULL); }
	virtual ~ns3__MarketDisplayDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfMarketDisplayDetail
#define SOAP_TYPE_ns3__ArrayOfMarketDisplayDetail (178)
/* ns3:ArrayOfMarketDisplayDetail */
class SOAP_CMAC ns3__ArrayOfMarketDisplayDetail
{
public:
	std::vector<ns3__MarketDisplayDetail * >ns3__MarketDisplayDetail_;	/* optional element of type ns3:MarketDisplayDetail */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique id SOAP_TYPE_ns3__ArrayOfMarketDisplayDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfMarketDisplayDetail(): soap(NULL) { ns3__ArrayOfMarketDisplayDetail::soap_default(NULL); }
	virtual ~ns3__ArrayOfMarketDisplayDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns3__RacingSilk
#define SOAP_TYPE_ns3__RacingSilk (179)
/* ns3:RacingSilk */
class SOAP_CMAC ns3__RacingSilk
{
public:
	int selectionId;	/* required element of type xsd:int */
	std::string *silksURL;	/* optional element of type xsd:string */
	std::string *silksText;	/* optional element of type xsd:string */
	std::string *trainerName;	/* optional element of type xsd:string */
	std::string *ageWeight;	/* optional element of type xsd:string */
	std::string *form;	/* optional element of type xsd:string */
	int daysSince;	/* required element of type xsd:int */
	int jockeyClaim;	/* required element of type xsd:int */
	std::string *wearing;	/* optional element of type xsd:string */
	int saddleCloth;	/* required element of type xsd:int */
	int stallDraw;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique id SOAP_TYPE_ns3__RacingSilk */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__RacingSilk(): silksURL(NULL), silksText(NULL), trainerName(NULL), ageWeight(NULL), form(NULL), wearing(NULL), soap(NULL) { ns3__RacingSilk::soap_default(NULL); }
	virtual ~ns3__RacingSilk() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfRacingSilk
#define SOAP_TYPE_ns3__ArrayOfRacingSilk (180)
/* ns3:ArrayOfRacingSilk */
class SOAP_CMAC ns3__ArrayOfRacingSilk
{
public:
	std::vector<ns3__RacingSilk * >ns3__RacingSilk_;	/* optional element of type ns3:RacingSilk */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique id SOAP_TYPE_ns3__ArrayOfRacingSilk */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfRacingSilk(): soap(NULL) { ns3__ArrayOfRacingSilk::soap_default(NULL); }
	virtual ~ns3__ArrayOfRacingSilk() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MarketDisplayDetailV2
#define SOAP_TYPE_ns3__MarketDisplayDetailV2 (183)
/* ns3:MarketDisplayDetailV2 */
class SOAP_CMAC ns3__MarketDisplayDetailV2
{
public:
	int marketId;	/* required element of type xsd:int */
	class ns3__ArrayOfRacingSilkV2 *racingSilks;	/* optional element of type ns3:ArrayOfRacingSilkV2 */
	enum ns3__MarketDisplayErrorEnum errorCode;	/* required element of type ns3:MarketDisplayErrorEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique id SOAP_TYPE_ns3__MarketDisplayDetailV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MarketDisplayDetailV2(): racingSilks(NULL), soap(NULL) { ns3__MarketDisplayDetailV2::soap_default(NULL); }
	virtual ~ns3__MarketDisplayDetailV2() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfMarketDisplayDetailV2
#define SOAP_TYPE_ns3__ArrayOfMarketDisplayDetailV2 (184)
/* ns3:ArrayOfMarketDisplayDetailV2 */
class SOAP_CMAC ns3__ArrayOfMarketDisplayDetailV2
{
public:
	std::vector<ns3__MarketDisplayDetailV2 * >ns3__MarketDisplayDetail_;	/* optional element of type ns3:MarketDisplayDetailV2 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique id SOAP_TYPE_ns3__ArrayOfMarketDisplayDetailV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfMarketDisplayDetailV2(): soap(NULL) { ns3__ArrayOfMarketDisplayDetailV2::soap_default(NULL); }
	virtual ~ns3__ArrayOfMarketDisplayDetailV2() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Breeding
#define SOAP_TYPE_ns3__Breeding (185)
/* ns3:Breeding */
class SOAP_CMAC ns3__Breeding
{
public:
	std::string *name;	/* optional element of type xsd:string */
	std::string *bred;	/* optional element of type xsd:string */
	std::string *yearBorn;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique id SOAP_TYPE_ns3__Breeding */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Breeding(): name(NULL), bred(NULL), yearBorn(NULL), soap(NULL) { ns3__Breeding::soap_default(NULL); }
	virtual ~ns3__Breeding() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfRacingSilkV2
#define SOAP_TYPE_ns3__ArrayOfRacingSilkV2 (187)
/* ns3:ArrayOfRacingSilkV2 */
class SOAP_CMAC ns3__ArrayOfRacingSilkV2
{
public:
	std::vector<class ns3__RacingSilkV2 * >ns3__RacingSilk_;	/* optional element of type ns3:RacingSilkV2 */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 187; } /* = unique id SOAP_TYPE_ns3__ArrayOfRacingSilkV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfRacingSilkV2(): soap(NULL) { ns3__ArrayOfRacingSilkV2::soap_default(NULL); }
	virtual ~ns3__ArrayOfRacingSilkV2() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsResult
#define SOAP_TYPE_ns3__CancelBetsResult (190)
/* ns3:CancelBetsResult */
class SOAP_CMAC ns3__CancelBetsResult
{
public:
	LONG64 betId;	/* required element of type xsd:long */
	enum ns3__CancelBetsResultEnum resultCode;	/* required element of type ns3:CancelBetsResultEnum */
	double sizeCancelled;	/* required element of type xsd:double */
	double sizeMatched;	/* required element of type xsd:double */
	bool success;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 190; } /* = unique id SOAP_TYPE_ns3__CancelBetsResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CancelBetsResult(): soap(NULL) { ns3__CancelBetsResult::soap_default(NULL); }
	virtual ~ns3__CancelBetsResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfCancelBetsResult
#define SOAP_TYPE_ns3__ArrayOfCancelBetsResult (191)
/* ns3:ArrayOfCancelBetsResult */
class SOAP_CMAC ns3__ArrayOfCancelBetsResult
{
public:
	std::vector<ns3__CancelBetsResult * >ns3__CancelBetsResult_;	/* optional element of type ns3:CancelBetsResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 191; } /* = unique id SOAP_TYPE_ns3__ArrayOfCancelBetsResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfCancelBetsResult(): soap(NULL) { ns3__ArrayOfCancelBetsResult::soap_default(NULL); }
	virtual ~ns3__ArrayOfCancelBetsResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CancelBets
#define SOAP_TYPE_ns3__CancelBets (193)
/* ns3:CancelBets */
class SOAP_CMAC ns3__CancelBets
{
public:
	LONG64 betId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 193; } /* = unique id SOAP_TYPE_ns3__CancelBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CancelBets(): soap(NULL) { ns3__CancelBets::soap_default(NULL); }
	virtual ~ns3__CancelBets() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfCancelBets
#define SOAP_TYPE_ns3__ArrayOfCancelBets (194)
/* ns3:ArrayOfCancelBets */
class SOAP_CMAC ns3__ArrayOfCancelBets
{
public:
	std::vector<ns3__CancelBets * >ns3__CancelBets_;	/* optional element of type ns3:CancelBets */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 194; } /* = unique id SOAP_TYPE_ns3__ArrayOfCancelBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfCancelBets(): soap(NULL) { ns3__ArrayOfCancelBets::soap_default(NULL); }
	virtual ~ns3__ArrayOfCancelBets() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfCancelBetsByMarketResult
#define SOAP_TYPE_ns3__ArrayOfCancelBetsByMarketResult (197)
/* ns3:ArrayOfCancelBetsByMarketResult */
class SOAP_CMAC ns3__ArrayOfCancelBetsByMarketResult
{
public:
	std::vector<class ns3__CancelBetsByMarketResult * >ns3__CancelBetsByMarketResult_;	/* optional element of type ns3:CancelBetsByMarketResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 197; } /* = unique id SOAP_TYPE_ns3__ArrayOfCancelBetsByMarketResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfCancelBetsByMarketResult(): soap(NULL) { ns3__ArrayOfCancelBetsByMarketResult::soap_default(NULL); }
	virtual ~ns3__ArrayOfCancelBetsByMarketResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsByMarketResult
#define SOAP_TYPE_ns3__CancelBetsByMarketResult (198)
/* ns3:CancelBetsByMarketResult */
class SOAP_CMAC ns3__CancelBetsByMarketResult
{
public:
	int marketId;	/* required element of type xsd:int */
	enum ns3__CancelBetsByMarketResultEnum resultCode;	/* required element of type ns3:CancelBetsByMarketResultEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 198; } /* = unique id SOAP_TYPE_ns3__CancelBetsByMarketResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CancelBetsByMarketResult(): soap(NULL) { ns3__CancelBetsByMarketResult::soap_default(NULL); }
	virtual ~ns3__CancelBetsByMarketResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UpdateBetsResult
#define SOAP_TYPE_ns3__UpdateBetsResult (200)
/* ns3:UpdateBetsResult */
class SOAP_CMAC ns3__UpdateBetsResult
{
public:
	LONG64 betId;	/* required element of type xsd:long */
	LONG64 *newBetId;	/* optional element of type xsd:long */
	double *sizeCancelled;	/* optional element of type xsd:double */
	double *newSize;	/* optional element of type xsd:double */
	double *newPrice;	/* optional element of type xsd:double */
	enum ns3__UpdateBetsResultEnum resultCode;	/* required element of type ns3:UpdateBetsResultEnum */
	bool success;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 200; } /* = unique id SOAP_TYPE_ns3__UpdateBetsResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UpdateBetsResult(): newBetId(NULL), sizeCancelled(NULL), newSize(NULL), newPrice(NULL), soap(NULL) { ns3__UpdateBetsResult::soap_default(NULL); }
	virtual ~ns3__UpdateBetsResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfUpdateBetsResult
#define SOAP_TYPE_ns3__ArrayOfUpdateBetsResult (201)
/* ns3:ArrayOfUpdateBetsResult */
class SOAP_CMAC ns3__ArrayOfUpdateBetsResult
{
public:
	std::vector<ns3__UpdateBetsResult * >ns3__UpdateBetsResult_;	/* optional element of type ns3:UpdateBetsResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 201; } /* = unique id SOAP_TYPE_ns3__ArrayOfUpdateBetsResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfUpdateBetsResult(): soap(NULL) { ns3__ArrayOfUpdateBetsResult::soap_default(NULL); }
	virtual ~ns3__ArrayOfUpdateBetsResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UpdateBets
#define SOAP_TYPE_ns3__UpdateBets (203)
/* ns3:UpdateBets */
class SOAP_CMAC ns3__UpdateBets
{
public:
	LONG64 betId;	/* required element of type xsd:long */
	double *newPrice;	/* optional element of type xsd:double */
	double newSize;	/* required element of type xsd:double */
	double *oldPrice;	/* optional element of type xsd:double */
	double oldSize;	/* required element of type xsd:double */
	enum ns3__BetPersistenceTypeEnum oldBetPersistenceType;	/* required element of type ns3:BetPersistenceTypeEnum */
	enum ns3__BetPersistenceTypeEnum newBetPersistenceType;	/* required element of type ns3:BetPersistenceTypeEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 203; } /* = unique id SOAP_TYPE_ns3__UpdateBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UpdateBets(): newPrice(NULL), oldPrice(NULL), soap(NULL) { ns3__UpdateBets::soap_default(NULL); }
	virtual ~ns3__UpdateBets() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfUpdateBets
#define SOAP_TYPE_ns3__ArrayOfUpdateBets (204)
/* ns3:ArrayOfUpdateBets */
class SOAP_CMAC ns3__ArrayOfUpdateBets
{
public:
	std::vector<ns3__UpdateBets * >ns3__UpdateBets_;	/* optional element of type ns3:UpdateBets */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 204; } /* = unique id SOAP_TYPE_ns3__ArrayOfUpdateBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfUpdateBets(): soap(NULL) { ns3__ArrayOfUpdateBets::soap_default(NULL); }
	virtual ~ns3__ArrayOfUpdateBets() { }
};
#endif

#ifndef SOAP_TYPE_ns3__PlaceBetsResult
#define SOAP_TYPE_ns3__PlaceBetsResult (206)
/* ns3:PlaceBetsResult */
class SOAP_CMAC ns3__PlaceBetsResult
{
public:
	double averagePriceMatched;	/* required element of type xsd:double */
	LONG64 betId;	/* required element of type xsd:long */
	enum ns3__PlaceBetsResultEnum resultCode;	/* required element of type ns3:PlaceBetsResultEnum */
	double sizeMatched;	/* required element of type xsd:double */
	bool success;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 206; } /* = unique id SOAP_TYPE_ns3__PlaceBetsResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__PlaceBetsResult(): soap(NULL) { ns3__PlaceBetsResult::soap_default(NULL); }
	virtual ~ns3__PlaceBetsResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfPlaceBetsResult
#define SOAP_TYPE_ns3__ArrayOfPlaceBetsResult (207)
/* ns3:ArrayOfPlaceBetsResult */
class SOAP_CMAC ns3__ArrayOfPlaceBetsResult
{
public:
	std::vector<ns3__PlaceBetsResult * >ns3__PlaceBetsResult_;	/* optional element of type ns3:PlaceBetsResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 207; } /* = unique id SOAP_TYPE_ns3__ArrayOfPlaceBetsResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfPlaceBetsResult(): soap(NULL) { ns3__ArrayOfPlaceBetsResult::soap_default(NULL); }
	virtual ~ns3__ArrayOfPlaceBetsResult() { }
};
#endif

#ifndef SOAP_TYPE_ns3__PlaceBets
#define SOAP_TYPE_ns3__PlaceBets (209)
/* ns3:PlaceBets */
class SOAP_CMAC ns3__PlaceBets
{
public:
	int asianLineId;	/* required element of type xsd:int */
	enum ns3__BetTypeEnum betType;	/* required element of type ns3:BetTypeEnum */
	enum ns3__BetCategoryTypeEnum betCategoryType;	/* required element of type ns3:BetCategoryTypeEnum */
	enum ns3__BetPersistenceTypeEnum betPersistenceType;	/* required element of type ns3:BetPersistenceTypeEnum */
	int marketId;	/* required element of type xsd:int */
	double price;	/* required element of type xsd:double */
	int selectionId;	/* required element of type xsd:int */
	double *size;	/* optional element of type xsd:double */
	double *bspLiability;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 209; } /* = unique id SOAP_TYPE_ns3__PlaceBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__PlaceBets(): size(NULL), bspLiability(NULL), soap(NULL) { ns3__PlaceBets::soap_default(NULL); }
	virtual ~ns3__PlaceBets() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfPlaceBets
#define SOAP_TYPE_ns3__ArrayOfPlaceBets (210)
/* ns3:ArrayOfPlaceBets */
class SOAP_CMAC ns3__ArrayOfPlaceBets
{
public:
	std::vector<ns3__PlaceBets * >ns3__PlaceBets_;	/* optional element of type ns3:PlaceBets */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 210; } /* = unique id SOAP_TYPE_ns3__ArrayOfPlaceBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfPlaceBets(): soap(NULL) { ns3__ArrayOfPlaceBets::soap_default(NULL); }
	virtual ~ns3__ArrayOfPlaceBets() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CouponMarket
#define SOAP_TYPE_ns3__CouponMarket (212)
/* ns3:CouponMarket */
class SOAP_CMAC ns3__CouponMarket
{
public:
	int marketId;	/* required element of type xsd:int */
	std::string *marketName;	/* optional element of type xsd:string */
	int exchangeId;	/* required element of type xsd:int */
	std::string *parentEventName;	/* optional element of type xsd:string */
	enum ns3__MarketStatusEnum marketStatus;	/* required element of type ns3:MarketStatusEnum */
	enum ns3__MarketTypeEnum marketType;	/* required element of type ns3:MarketTypeEnum */
	enum ns3__MarketTypeVariantEnum marketTypeVariant;	/* required element of type ns3:MarketTypeVariantEnum */
	std::string *marketInfo;	/* optional element of type xsd:string */
	time_t startTime;	/* required element of type xsd:dateTime */
	int betDelay;	/* required element of type xsd:int */
	class ns3__ArrayOfCouponSelection *couponSelectionItems;	/* optional element of type ns3:ArrayOfCouponSelection */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 212; } /* = unique id SOAP_TYPE_ns3__CouponMarket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CouponMarket(): marketName(NULL), parentEventName(NULL), marketInfo(NULL), couponSelectionItems(NULL), soap(NULL) { ns3__CouponMarket::soap_default(NULL); }
	virtual ~ns3__CouponMarket() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CouponSelection
#define SOAP_TYPE_ns3__CouponSelection (213)
/* ns3:CouponSelection */
class SOAP_CMAC ns3__CouponSelection
{
public:
	class ns3__Runner *runner;	/* required element of type ns3:Runner */
	double *backOdds;	/* optional element of type xsd:double */
	double *layOdds;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 213; } /* = unique id SOAP_TYPE_ns3__CouponSelection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CouponSelection(): runner(NULL), backOdds(NULL), layOdds(NULL), soap(NULL) { ns3__CouponSelection::soap_default(NULL); }
	virtual ~ns3__CouponSelection() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfCouponSelection
#define SOAP_TYPE_ns3__ArrayOfCouponSelection (214)
/* ns3:ArrayOfCouponSelection */
class SOAP_CMAC ns3__ArrayOfCouponSelection
{
public:
	std::vector<ns3__CouponSelection * >ns3__CouponSelection_;	/* optional element of type ns3:CouponSelection */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 214; } /* = unique id SOAP_TYPE_ns3__ArrayOfCouponSelection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfCouponSelection(): soap(NULL) { ns3__ArrayOfCouponSelection::soap_default(NULL); }
	virtual ~ns3__ArrayOfCouponSelection() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfCouponMarket
#define SOAP_TYPE_ns3__ArrayOfCouponMarket (215)
/* ns3:ArrayOfCouponMarket */
class SOAP_CMAC ns3__ArrayOfCouponMarket
{
public:
	std::vector<ns3__CouponMarket * >ns3__CouponMarket_;	/* optional element of type ns3:CouponMarket */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 215; } /* = unique id SOAP_TYPE_ns3__ArrayOfCouponMarket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfCouponMarket(): soap(NULL) { ns3__ArrayOfCouponMarket::soap_default(NULL); }
	virtual ~ns3__ArrayOfCouponMarket() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CouponLink
#define SOAP_TYPE_ns3__CouponLink (217)
/* ns3:CouponLink */
class SOAP_CMAC ns3__CouponLink
{
public:
	int couponId;	/* required element of type xsd:int */
	std::string *couponName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 217; } /* = unique id SOAP_TYPE_ns3__CouponLink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CouponLink(): couponName(NULL), soap(NULL) { ns3__CouponLink::soap_default(NULL); }
	virtual ~ns3__CouponLink() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfCouponLinks
#define SOAP_TYPE_ns3__ArrayOfCouponLinks (218)
/* ns3:ArrayOfCouponLinks */
class SOAP_CMAC ns3__ArrayOfCouponLinks
{
public:
	std::vector<ns3__CouponLink * >ns3__CouponLink_;	/* optional element of type ns3:CouponLink */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 218; } /* = unique id SOAP_TYPE_ns3__ArrayOfCouponLinks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfCouponLinks(): soap(NULL) { ns3__ArrayOfCouponLinks::soap_default(NULL); }
	virtual ~ns3__ArrayOfCouponLinks() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Market
#define SOAP_TYPE_ns3__Market (222)
/* ns3:Market */
class SOAP_CMAC ns3__Market
{
public:
	std::string *countryISO3;	/* optional element of type xsd:string */
	bool discountAllowed;	/* required element of type xsd:boolean */
	int eventTypeId;	/* required element of type xsd:int */
	LONG64 lastRefresh;	/* required element of type xsd:long */
	float marketBaseRate;	/* required element of type xsd:float */
	std::string *marketDescription;	/* optional element of type xsd:string */
	bool marketDescriptionHasDate;	/* required element of type xsd:boolean */
	time_t marketDisplayTime;	/* required element of type xsd:dateTime */
	int marketId;	/* required element of type xsd:int */
	enum ns3__MarketStatusEnum marketStatus;	/* required element of type ns3:MarketStatusEnum */
	time_t marketSuspendTime;	/* required element of type xsd:dateTime */
	time_t marketTime;	/* required element of type xsd:dateTime */
	enum ns3__MarketTypeEnum marketType;	/* required element of type ns3:MarketTypeEnum */
	enum ns3__MarketTypeVariantEnum marketTypeVariant;	/* required element of type ns3:MarketTypeVariantEnum */
	std::string *menuPath;	/* optional element of type xsd:string */
	class ns3__ArrayOfEventId *eventHierarchy;	/* optional element of type ns3:ArrayOfEventId */
	std::string *name;	/* optional element of type xsd:string */
	int numberOfWinners;	/* required element of type xsd:int */
	int parentEventId;	/* required element of type xsd:int */
	class ns3__ArrayOfRunner *runners;	/* optional element of type ns3:ArrayOfRunner */
	std::string *unit;	/* optional element of type xsd:string */
	double *maxUnitValue;	/* optional element of type xsd:double */
	double *minUnitValue;	/* optional element of type xsd:double */
	double *interval;	/* optional element of type xsd:double */
	bool runnersMayBeAdded;	/* required element of type xsd:boolean */
	std::string *timezone;	/* optional element of type xsd:string */
	int licenceId;	/* required element of type xsd:int */
	ns3__ArrayOfCouponLinks *couponLinks;	/* optional element of type ns3:ArrayOfCouponLinks */
	bool bspMarket;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 222; } /* = unique id SOAP_TYPE_ns3__Market */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Market(): countryISO3(NULL), marketDescription(NULL), menuPath(NULL), eventHierarchy(NULL), name(NULL), runners(NULL), unit(NULL), maxUnitValue(NULL), minUnitValue(NULL), interval(NULL), timezone(NULL), couponLinks(NULL), soap(NULL) { ns3__Market::soap_default(NULL); }
	virtual ~ns3__Market() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfEventId
#define SOAP_TYPE_ns3__ArrayOfEventId (223)
/* ns3:ArrayOfEventId */
class SOAP_CMAC ns3__ArrayOfEventId
{
public:
	std::vector<int >ns3__EventId;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 223; } /* = unique id SOAP_TYPE_ns3__ArrayOfEventId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfEventId(): soap(NULL) { ns3__ArrayOfEventId::soap_default(NULL); }
	virtual ~ns3__ArrayOfEventId() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Runner
#define SOAP_TYPE_ns3__Runner (224)
/* ns3:Runner */
class SOAP_CMAC ns3__Runner
{
public:
	int asianLineId;	/* required element of type xsd:int */
	double handicap;	/* required element of type xsd:double */
	std::string *name;	/* optional element of type xsd:string */
	int selectionId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 224; } /* = unique id SOAP_TYPE_ns3__Runner */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Runner(): name(NULL), soap(NULL) { ns3__Runner::soap_default(NULL); }
	virtual ~ns3__Runner() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfRunner
#define SOAP_TYPE_ns3__ArrayOfRunner (225)
/* ns3:ArrayOfRunner */
class SOAP_CMAC ns3__ArrayOfRunner
{
public:
	std::vector<ns3__Runner * >ns3__Runner_;	/* optional element of type ns3:Runner */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 225; } /* = unique id SOAP_TYPE_ns3__ArrayOfRunner */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfRunner(): soap(NULL) { ns3__ArrayOfRunner::soap_default(NULL); }
	virtual ~ns3__ArrayOfRunner() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MarketPrices
#define SOAP_TYPE_ns3__MarketPrices (228)
/* ns3:MarketPrices */
class SOAP_CMAC ns3__MarketPrices
{
public:
	std::string *currencyCode;	/* optional element of type xsd:string */
	int delay;	/* required element of type xsd:int */
	bool discountAllowed;	/* required element of type xsd:boolean */
	LONG64 lastRefresh;	/* required element of type xsd:long */
	float marketBaseRate;	/* required element of type xsd:float */
	int marketId;	/* required element of type xsd:int */
	std::string *marketInfo;	/* optional element of type xsd:string */
	std::string *removedRunners;	/* optional element of type xsd:string */
	enum ns3__MarketStatusEnum marketStatus;	/* required element of type ns3:MarketStatusEnum */
	int numberOfWinners;	/* required element of type xsd:int */
	bool bspMarket;	/* required element of type xsd:boolean */
	class ns3__ArrayOfRunnerPrices *runnerPrices;	/* optional element of type ns3:ArrayOfRunnerPrices */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 228; } /* = unique id SOAP_TYPE_ns3__MarketPrices */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MarketPrices(): currencyCode(NULL), marketInfo(NULL), removedRunners(NULL), runnerPrices(NULL), soap(NULL) { ns3__MarketPrices::soap_default(NULL); }
	virtual ~ns3__MarketPrices() { }
};
#endif

#ifndef SOAP_TYPE_ns3__RunnerPrices
#define SOAP_TYPE_ns3__RunnerPrices (229)
/* ns3:RunnerPrices */
class SOAP_CMAC ns3__RunnerPrices
{
public:
	int *asianLineId;	/* optional element of type xsd:int */
	class ns3__ArrayOfPrice *bestPricesToBack;	/* optional element of type ns3:ArrayOfPrice */
	ns3__ArrayOfPrice *bestPricesToLay;	/* optional element of type ns3:ArrayOfPrice */
	double *handicap;	/* optional element of type xsd:double */
	double lastPriceMatched;	/* required element of type xsd:double */
	double reductionFactor;	/* required element of type xsd:double */
	int selectionId;	/* required element of type xsd:int */
	int sortOrder;	/* required element of type xsd:int */
	double totalAmountMatched;	/* required element of type xsd:double */
	bool *vacant;	/* optional element of type xsd:boolean */
	double *farBSP;	/* optional element of type xsd:double */
	double *nearBSP;	/* optional element of type xsd:double */
	double *actualBSP;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 229; } /* = unique id SOAP_TYPE_ns3__RunnerPrices */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__RunnerPrices(): asianLineId(NULL), bestPricesToBack(NULL), bestPricesToLay(NULL), handicap(NULL), vacant(NULL), farBSP(NULL), nearBSP(NULL), actualBSP(NULL), soap(NULL) { ns3__RunnerPrices::soap_default(NULL); }
	virtual ~ns3__RunnerPrices() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Price
#define SOAP_TYPE_ns3__Price (230)
/* ns3:Price */
class SOAP_CMAC ns3__Price
{
public:
	double amountAvailable;	/* required element of type xsd:double */
	enum ns3__BetTypeEnum betType;	/* required element of type ns3:BetTypeEnum */
	int depth;	/* required element of type xsd:int */
	double price;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 230; } /* = unique id SOAP_TYPE_ns3__Price */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Price(): soap(NULL) { ns3__Price::soap_default(NULL); }
	virtual ~ns3__Price() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfPrice
#define SOAP_TYPE_ns3__ArrayOfPrice (231)
/* ns3:ArrayOfPrice */
class SOAP_CMAC ns3__ArrayOfPrice
{
public:
	std::vector<ns3__Price * >ns3__Price_;	/* optional element of type ns3:Price */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 231; } /* = unique id SOAP_TYPE_ns3__ArrayOfPrice */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfPrice(): soap(NULL) { ns3__ArrayOfPrice::soap_default(NULL); }
	virtual ~ns3__ArrayOfPrice() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfRunnerPrices
#define SOAP_TYPE_ns3__ArrayOfRunnerPrices (232)
/* ns3:ArrayOfRunnerPrices */
class SOAP_CMAC ns3__ArrayOfRunnerPrices
{
public:
	std::vector<ns3__RunnerPrices * >ns3__RunnerPrices_;	/* optional element of type ns3:RunnerPrices */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 232; } /* = unique id SOAP_TYPE_ns3__ArrayOfRunnerPrices */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfRunnerPrices(): soap(NULL) { ns3__ArrayOfRunnerPrices::soap_default(NULL); }
	virtual ~ns3__ArrayOfRunnerPrices() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfCountryCode
#define SOAP_TYPE_ns3__ArrayOfCountryCode (236)
/* ns3:ArrayOfCountryCode */
class SOAP_CMAC ns3__ArrayOfCountryCode
{
public:
	std::vector<std::string >ns3__Country;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 236; } /* = unique id SOAP_TYPE_ns3__ArrayOfCountryCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfCountryCode(): soap(NULL) { ns3__ArrayOfCountryCode::soap_default(NULL); }
	virtual ~ns3__ArrayOfCountryCode() { }
};
#endif

#ifndef SOAP_TYPE_ns3__PrivateMarket
#define SOAP_TYPE_ns3__PrivateMarket (241)
/* ns3:PrivateMarket */
class SOAP_CMAC ns3__PrivateMarket
{
public:
	std::string *name;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
	std::string *menuPath;	/* optional element of type xsd:string */
	ns3__ArrayOfEventId *eventHierarchy;	/* optional element of type ns3:ArrayOfEventId */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 241; } /* = unique id SOAP_TYPE_ns3__PrivateMarket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__PrivateMarket(): name(NULL), menuPath(NULL), eventHierarchy(NULL), soap(NULL) { ns3__PrivateMarket::soap_default(NULL); }
	virtual ~ns3__PrivateMarket() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfPrivateMarket
#define SOAP_TYPE_ns3__ArrayOfPrivateMarket (242)
/* ns3:ArrayOfPrivateMarket */
class SOAP_CMAC ns3__ArrayOfPrivateMarket
{
public:
	std::vector<ns3__PrivateMarket * >ns3__PrivateMarket_;	/* optional element of type ns3:PrivateMarket */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 242; } /* = unique id SOAP_TYPE_ns3__ArrayOfPrivateMarket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfPrivateMarket(): soap(NULL) { ns3__ArrayOfPrivateMarket::soap_default(NULL); }
	virtual ~ns3__ArrayOfPrivateMarket() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MUBet
#define SOAP_TYPE_ns3__MUBet (251)
/* ns3:MUBet */
class SOAP_CMAC ns3__MUBet
{
public:
	int asianLineId;	/* required element of type xsd:int */
	LONG64 betId;	/* required element of type xsd:long */
	LONG64 transactionId;	/* required element of type xsd:long */
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	enum ns3__BetTypeEnum betType;	/* required element of type ns3:BetTypeEnum */
	enum ns3__BetCategoryTypeEnum betCategoryType;	/* required element of type ns3:BetCategoryTypeEnum */
	enum ns3__BetPersistenceTypeEnum betPersistenceType;	/* required element of type ns3:BetPersistenceTypeEnum */
	int marketId;	/* required element of type xsd:int */
	time_t matchedDate;	/* required element of type xsd:dateTime */
	double size;	/* required element of type xsd:double */
	double *bspLiability;	/* optional element of type xsd:double */
	time_t placedDate;	/* required element of type xsd:dateTime */
	double price;	/* required element of type xsd:double */
	int selectionId;	/* required element of type xsd:int */
	double handicap;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 251; } /* = unique id SOAP_TYPE_ns3__MUBet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MUBet(): bspLiability(NULL), soap(NULL) { ns3__MUBet::soap_default(NULL); }
	virtual ~ns3__MUBet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfMUBet
#define SOAP_TYPE_ns3__ArrayOfMUBet (252)
/* ns3:ArrayOfMUBet */
class SOAP_CMAC ns3__ArrayOfMUBet
{
public:
	std::vector<ns3__MUBet * >ns3__MUBet_;	/* optional element of type ns3:MUBet */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 252; } /* = unique id SOAP_TYPE_ns3__ArrayOfMUBet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfMUBet(): soap(NULL) { ns3__ArrayOfMUBet::soap_default(NULL); }
	virtual ~ns3__ArrayOfMUBet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfBetId
#define SOAP_TYPE_ns3__ArrayOfBetId (254)
/* ns3:ArrayOfBetId */
class SOAP_CMAC ns3__ArrayOfBetId
{
public:
	std::vector<LONG64 >ns3__betId;	/* sequence of 0 to 1000 elements */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 254; } /* = unique id SOAP_TYPE_ns3__ArrayOfBetId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfBetId(): soap(NULL) { ns3__ArrayOfBetId::soap_default(NULL); }
	virtual ~ns3__ArrayOfBetId() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Bet
#define SOAP_TYPE_ns3__Bet (255)
/* ns3:Bet */
class SOAP_CMAC ns3__Bet
{
public:
	int asianLineId;	/* required element of type xsd:int */
	double avgPrice;	/* required element of type xsd:double */
	LONG64 betId;	/* required element of type xsd:long */
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	enum ns3__BetTypeEnum betType;	/* required element of type ns3:BetTypeEnum */
	enum ns3__BetCategoryTypeEnum betCategoryType;	/* required element of type ns3:BetCategoryTypeEnum */
	enum ns3__BetPersistenceTypeEnum betPersistenceType;	/* required element of type ns3:BetPersistenceTypeEnum */
	time_t cancelledDate;	/* required element of type xsd:dateTime */
	time_t lapsedDate;	/* required element of type xsd:dateTime */
	int marketId;	/* required element of type xsd:int */
	std::string *marketName;	/* optional element of type xsd:string */
	std::string *fullMarketName;	/* optional element of type xsd:string */
	enum ns3__MarketTypeEnum marketType;	/* required element of type ns3:MarketTypeEnum */
	enum ns3__MarketTypeVariantEnum marketTypeVariant;	/* required element of type ns3:MarketTypeVariantEnum */
	time_t matchedDate;	/* required element of type xsd:dateTime */
	double matchedSize;	/* required element of type xsd:double */
	class ns3__ArrayOfMatch *matches;	/* optional element of type ns3:ArrayOfMatch */
	time_t placedDate;	/* required element of type xsd:dateTime */
	double price;	/* required element of type xsd:double */
	double *bspLiability;	/* optional element of type xsd:double */
	double profitAndLoss;	/* required element of type xsd:double */
	int selectionId;	/* required element of type xsd:int */
	std::string *selectionName;	/* optional element of type xsd:string */
	time_t settledDate;	/* required element of type xsd:dateTime */
	double remainingSize;	/* required element of type xsd:double */
	double requestedSize;	/* required element of type xsd:double */
	time_t voidedDate;	/* required element of type xsd:dateTime */
	double handicap;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 255; } /* = unique id SOAP_TYPE_ns3__Bet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Bet(): marketName(NULL), fullMarketName(NULL), matches(NULL), bspLiability(NULL), selectionName(NULL), soap(NULL) { ns3__Bet::soap_default(NULL); }
	virtual ~ns3__Bet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__Match
#define SOAP_TYPE_ns3__Match (256)
/* ns3:Match */
class SOAP_CMAC ns3__Match
{
public:
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	time_t matchedDate;	/* required element of type xsd:dateTime */
	double priceMatched;	/* required element of type xsd:double */
	double profitLoss;	/* required element of type xsd:double */
	time_t settledDate;	/* required element of type xsd:dateTime */
	double sizeMatched;	/* required element of type xsd:double */
	LONG64 transactionId;	/* required element of type xsd:long */
	time_t voidedDate;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 256; } /* = unique id SOAP_TYPE_ns3__Match */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__Match(): soap(NULL) { ns3__Match::soap_default(NULL); }
	virtual ~ns3__Match() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfMatch
#define SOAP_TYPE_ns3__ArrayOfMatch (257)
/* ns3:ArrayOfMatch */
class SOAP_CMAC ns3__ArrayOfMatch
{
public:
	std::vector<ns3__Match * >ns3__Match_;	/* optional element of type ns3:Match */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 257; } /* = unique id SOAP_TYPE_ns3__ArrayOfMatch */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfMatch(): soap(NULL) { ns3__ArrayOfMatch::soap_default(NULL); }
	virtual ~ns3__ArrayOfMatch() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfBet
#define SOAP_TYPE_ns3__ArrayOfBet (258)
/* ns3:ArrayOfBet */
class SOAP_CMAC ns3__ArrayOfBet
{
public:
	std::vector<ns3__Bet * >ns3__Bet_;	/* optional element of type ns3:Bet */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 258; } /* = unique id SOAP_TYPE_ns3__ArrayOfBet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfBet(): soap(NULL) { ns3__ArrayOfBet::soap_default(NULL); }
	virtual ~ns3__ArrayOfBet() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AvailabilityInfo
#define SOAP_TYPE_ns3__AvailabilityInfo (261)
/* ns3:AvailabilityInfo */
class SOAP_CMAC ns3__AvailabilityInfo
{
public:
	double odds;	/* required element of type xsd:double */
	double totalAvailableBackAmount;	/* required element of type xsd:double */
	double totalAvailableLayAmount;	/* required element of type xsd:double */
	double totalBspBackAmount;	/* required element of type xsd:double */
	double totalBspLayAmount;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 261; } /* = unique id SOAP_TYPE_ns3__AvailabilityInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AvailabilityInfo(): soap(NULL) { ns3__AvailabilityInfo::soap_default(NULL); }
	virtual ~ns3__AvailabilityInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfAvailabilityInfo
#define SOAP_TYPE_ns3__ArrayOfAvailabilityInfo (262)
/* ns3:ArrayOfAvailabilityInfo */
class SOAP_CMAC ns3__ArrayOfAvailabilityInfo
{
public:
	std::vector<ns3__AvailabilityInfo * >ns3__AvailabilityInfo_;	/* optional element of type ns3:AvailabilityInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 262; } /* = unique id SOAP_TYPE_ns3__ArrayOfAvailabilityInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfAvailabilityInfo(): soap(NULL) { ns3__ArrayOfAvailabilityInfo::soap_default(NULL); }
	virtual ~ns3__ArrayOfAvailabilityInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__VolumeInfo
#define SOAP_TYPE_ns3__VolumeInfo (265)
/* ns3:VolumeInfo */
class SOAP_CMAC ns3__VolumeInfo
{
public:
	double odds;	/* required element of type xsd:double */
	double totalMatchedAmount;	/* required element of type xsd:double */
	double totalBspBackMatchedAmount;	/* required element of type xsd:double */
	double totalBspLiabilityMatchedAmount;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 265; } /* = unique id SOAP_TYPE_ns3__VolumeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__VolumeInfo(): soap(NULL) { ns3__VolumeInfo::soap_default(NULL); }
	virtual ~ns3__VolumeInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfVolumeInfo
#define SOAP_TYPE_ns3__ArrayOfVolumeInfo (266)
/* ns3:ArrayOfVolumeInfo */
class SOAP_CMAC ns3__ArrayOfVolumeInfo
{
public:
	std::vector<ns3__VolumeInfo * >ns3__VolumeInfo_;	/* optional element of type ns3:VolumeInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 266; } /* = unique id SOAP_TYPE_ns3__ArrayOfVolumeInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfVolumeInfo(): soap(NULL) { ns3__ArrayOfVolumeInfo::soap_default(NULL); }
	virtual ~ns3__ArrayOfVolumeInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfMarketTypeEnum
#define SOAP_TYPE_ns3__ArrayOfMarketTypeEnum (270)
/* ns3:ArrayOfMarketTypeEnum */
class SOAP_CMAC ns3__ArrayOfMarketTypeEnum
{
public:
	std::vector<enum ns3__MarketTypeEnum >ns3__MarketTypeEnum;	/* optional element of type ns3:MarketTypeEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 270; } /* = unique id SOAP_TYPE_ns3__ArrayOfMarketTypeEnum */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfMarketTypeEnum(): soap(NULL) { ns3__ArrayOfMarketTypeEnum::soap_default(NULL); }
	virtual ~ns3__ArrayOfMarketTypeEnum() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfInt
#define SOAP_TYPE_ns3__ArrayOfInt (271)
/* ns3:ArrayOfInt */
class SOAP_CMAC ns3__ArrayOfInt
{
public:
	std::vector<int >ns3__int;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 271; } /* = unique id SOAP_TYPE_ns3__ArrayOfInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfInt(): soap(NULL) { ns3__ArrayOfInt::soap_default(NULL); }
	virtual ~ns3__ArrayOfInt() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AccountStatementItem
#define SOAP_TYPE_ns3__AccountStatementItem (273)
/* ns3:AccountStatementItem */
class SOAP_CMAC ns3__AccountStatementItem
{
public:
	double accountBalance;	/* required element of type xsd:double */
	double amount;	/* required element of type xsd:double */
	double avgPrice;	/* required element of type xsd:double */
	LONG64 betId;	/* required element of type xsd:long */
	double betSize;	/* required element of type xsd:double */
	enum ns3__BetTypeEnum betType;	/* required element of type ns3:BetTypeEnum */
	enum ns3__BetCategoryTypeEnum betCategoryType;	/* required element of type ns3:BetCategoryTypeEnum */
	std::string *commissionRate;	/* optional element of type xsd:string */
	int eventId;	/* required element of type xsd:int */
	int eventTypeId;	/* required element of type xsd:int */
	std::string *fullMarketName;	/* optional element of type xsd:string */
	double grossBetAmount;	/* required element of type xsd:double */
	std::string *marketName;	/* optional element of type xsd:string */
	enum ns3__MarketTypeEnum marketType;	/* required element of type ns3:MarketTypeEnum */
	time_t placedDate;	/* required element of type xsd:dateTime */
	int selectionId;	/* required element of type xsd:int */
	std::string *selectionName;	/* optional element of type xsd:string */
	time_t settledDate;	/* required element of type xsd:dateTime */
	time_t startDate;	/* required element of type xsd:dateTime */
	enum ns3__AccountStatementEnum transactionType;	/* required element of type ns3:AccountStatementEnum */
	LONG64 transactionId;	/* required element of type xsd:long */
	enum ns3__AccountStatementEnum winLose;	/* required element of type ns3:AccountStatementEnum */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 273; } /* = unique id SOAP_TYPE_ns3__AccountStatementItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AccountStatementItem(): commissionRate(NULL), fullMarketName(NULL), marketName(NULL), selectionName(NULL), soap(NULL) { ns3__AccountStatementItem::soap_default(NULL); }
	virtual ~ns3__AccountStatementItem() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfAccountStatementItem
#define SOAP_TYPE_ns3__ArrayOfAccountStatementItem (274)
/* ns3:ArrayOfAccountStatementItem */
class SOAP_CMAC ns3__ArrayOfAccountStatementItem
{
public:
	std::vector<ns3__AccountStatementItem * >ns3__AccountStatementItem_;	/* optional element of type ns3:AccountStatementItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 274; } /* = unique id SOAP_TYPE_ns3__ArrayOfAccountStatementItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfAccountStatementItem(): soap(NULL) { ns3__ArrayOfAccountStatementItem::soap_default(NULL); }
	virtual ~ns3__ArrayOfAccountStatementItem() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ProfitAndLoss
#define SOAP_TYPE_ns3__ProfitAndLoss (277)
/* ns3:ProfitAndLoss */
class SOAP_CMAC ns3__ProfitAndLoss
{
public:
	double futureIfWin;	/* required element of type xsd:double */
	double ifWin;	/* required element of type xsd:double */
	int selectionId;	/* required element of type xsd:int */
	std::string *selectionName;	/* optional element of type xsd:string */
	double worstcaseIfWin;	/* required element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 277; } /* = unique id SOAP_TYPE_ns3__ProfitAndLoss */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ProfitAndLoss(): selectionName(NULL), soap(NULL) { ns3__ProfitAndLoss::soap_default(NULL); }
	virtual ~ns3__ProfitAndLoss() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfProfitAndLoss
#define SOAP_TYPE_ns3__ArrayOfProfitAndLoss (278)
/* ns3:ArrayOfProfitAndLoss */
class SOAP_CMAC ns3__ArrayOfProfitAndLoss
{
public:
	std::vector<ns3__ProfitAndLoss * >ns3__ProfitAndLoss_;	/* optional element of type ns3:ProfitAndLoss */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 278; } /* = unique id SOAP_TYPE_ns3__ArrayOfProfitAndLoss */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfProfitAndLoss(): soap(NULL) { ns3__ArrayOfProfitAndLoss::soap_default(NULL); }
	virtual ~ns3__ArrayOfProfitAndLoss() { }
};
#endif

#ifndef SOAP_TYPE_ns3__BetLite
#define SOAP_TYPE_ns3__BetLite (283)
/* ns3:BetLite */
class SOAP_CMAC ns3__BetLite
{
public:
	LONG64 betId;	/* required element of type xsd:long */
	int marketId;	/* required element of type xsd:int */
	double matchedSize;	/* required element of type xsd:double */
	double remainingSize;	/* required element of type xsd:double */
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	enum ns3__BetCategoryTypeEnum betCategoryType;	/* required element of type ns3:BetCategoryTypeEnum */
	enum ns3__BetPersistenceTypeEnum betPersistenceType;	/* required element of type ns3:BetPersistenceTypeEnum */
	double *bspLiability;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 283; } /* = unique id SOAP_TYPE_ns3__BetLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__BetLite(): bspLiability(NULL), soap(NULL) { ns3__BetLite::soap_default(NULL); }
	virtual ~ns3__BetLite() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfBetLite
#define SOAP_TYPE_ns3__ArrayOfBetLite (284)
/* ns3:ArrayOfBetLite */
class SOAP_CMAC ns3__ArrayOfBetLite
{
public:
	std::vector<ns3__BetLite * >ns3__BetLite_;	/* optional element of type ns3:BetLite */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 284; } /* = unique id SOAP_TYPE_ns3__ArrayOfBetLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfBetLite(): soap(NULL) { ns3__ArrayOfBetLite::soap_default(NULL); }
	virtual ~ns3__ArrayOfBetLite() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MatchLite
#define SOAP_TYPE_ns3__MatchLite (288)
/* ns3:MatchLite */
class SOAP_CMAC ns3__MatchLite
{
public:
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	time_t matchedDate;	/* required element of type xsd:dateTime */
	double priceMatched;	/* required element of type xsd:double */
	double sizeMatched;	/* required element of type xsd:double */
	LONG64 transactionId;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 288; } /* = unique id SOAP_TYPE_ns3__MatchLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MatchLite(): soap(NULL) { ns3__MatchLite::soap_default(NULL); }
	virtual ~ns3__MatchLite() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfMatchLite
#define SOAP_TYPE_ns3__ArrayOfMatchLite (289)
/* ns3:ArrayOfMatchLite */
class SOAP_CMAC ns3__ArrayOfMatchLite
{
public:
	std::vector<ns3__MatchLite * >ns3__MatchLite_;	/* optional element of type ns3:MatchLite */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 289; } /* = unique id SOAP_TYPE_ns3__ArrayOfMatchLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfMatchLite(): soap(NULL) { ns3__ArrayOfMatchLite::soap_default(NULL); }
	virtual ~ns3__ArrayOfMatchLite() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MUBetLite
#define SOAP_TYPE_ns3__MUBetLite (292)
/* ns3:MUBetLite */
class SOAP_CMAC ns3__MUBetLite
{
public:
	LONG64 betId;	/* required element of type xsd:long */
	LONG64 transactionId;	/* required element of type xsd:long */
	int marketId;	/* required element of type xsd:int */
	double size;	/* required element of type xsd:double */
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	enum ns3__BetCategoryTypeEnum betCategoryType;	/* required element of type ns3:BetCategoryTypeEnum */
	enum ns3__BetPersistenceTypeEnum betPersistenceType;	/* required element of type ns3:BetPersistenceTypeEnum */
	double *bspLiability;	/* optional element of type xsd:double */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 292; } /* = unique id SOAP_TYPE_ns3__MUBetLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MUBetLite(): bspLiability(NULL), soap(NULL) { ns3__MUBetLite::soap_default(NULL); }
	virtual ~ns3__MUBetLite() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ArrayOfMUBetLite
#define SOAP_TYPE_ns3__ArrayOfMUBetLite (293)
/* ns3:ArrayOfMUBetLite */
class SOAP_CMAC ns3__ArrayOfMUBetLite
{
public:
	std::vector<ns3__MUBetLite * >ns3__MUBetLite_;	/* optional element of type ns3:MUBetLite */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 293; } /* = unique id SOAP_TYPE_ns3__ArrayOfMUBetLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ArrayOfMUBetLite(): soap(NULL) { ns3__ArrayOfMUBetLite::soap_default(NULL); }
	virtual ~ns3__ArrayOfMUBetLite() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MarketLite
#define SOAP_TYPE_ns3__MarketLite (297)
/* ns3:MarketLite */
class SOAP_CMAC ns3__MarketLite
{
public:
	enum ns3__MarketStatusEnum marketStatus;	/* required element of type ns3:MarketStatusEnum */
	time_t marketSuspendTime;	/* required element of type xsd:dateTime */
	time_t marketTime;	/* required element of type xsd:dateTime */
	int numberOfRunners;	/* required element of type xsd:int */
	int delay;	/* required element of type xsd:int */
	bool reconciled;	/* required element of type xsd:boolean */
	bool openForBspBetting;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 297; } /* = unique id SOAP_TYPE_ns3__MarketLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MarketLite(): soap(NULL) { ns3__MarketLite::soap_default(NULL); }
	virtual ~ns3__MarketLite() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getAccountFunds
#define SOAP_TYPE__ns4__getAccountFunds (301)
/* ns4:getAccountFunds */
class SOAP_CMAC _ns4__getAccountFunds
{
public:
	class ns3__GetAccountFundsReq *request;	/* required element of type ns3:GetAccountFundsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 301; } /* = unique id SOAP_TYPE__ns4__getAccountFunds */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getAccountFunds(): request(NULL), soap(NULL) { _ns4__getAccountFunds::soap_default(NULL); }
	virtual ~_ns4__getAccountFunds() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getAccountFundsResponse
#define SOAP_TYPE__ns4__getAccountFundsResponse (302)
/* ns4:getAccountFundsResponse */
class SOAP_CMAC _ns4__getAccountFundsResponse
{
public:
	class ns3__GetAccountFundsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetAccountFundsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 302; } /* = unique id SOAP_TYPE__ns4__getAccountFundsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getAccountFundsResponse(): Result(NULL), soap(NULL) { _ns4__getAccountFundsResponse::soap_default(NULL); }
	virtual ~_ns4__getAccountFundsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__cancelBets
#define SOAP_TYPE__ns4__cancelBets (303)
/* ns4:cancelBets */
class SOAP_CMAC _ns4__cancelBets
{
public:
	class ns3__CancelBetsReq *request;	/* required element of type ns3:CancelBetsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 303; } /* = unique id SOAP_TYPE__ns4__cancelBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__cancelBets(): request(NULL), soap(NULL) { _ns4__cancelBets::soap_default(NULL); }
	virtual ~_ns4__cancelBets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__cancelBetsResponse
#define SOAP_TYPE__ns4__cancelBetsResponse (304)
/* ns4:cancelBetsResponse */
class SOAP_CMAC _ns4__cancelBetsResponse
{
public:
	class ns3__CancelBetsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:CancelBetsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 304; } /* = unique id SOAP_TYPE__ns4__cancelBetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__cancelBetsResponse(): Result(NULL), soap(NULL) { _ns4__cancelBetsResponse::soap_default(NULL); }
	virtual ~_ns4__cancelBetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__cancelBetsByMarket
#define SOAP_TYPE__ns4__cancelBetsByMarket (305)
/* ns4:cancelBetsByMarket */
class SOAP_CMAC _ns4__cancelBetsByMarket
{
public:
	class ns3__CancelBetsByMarketReq *request;	/* required element of type ns3:CancelBetsByMarketReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 305; } /* = unique id SOAP_TYPE__ns4__cancelBetsByMarket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__cancelBetsByMarket(): request(NULL), soap(NULL) { _ns4__cancelBetsByMarket::soap_default(NULL); }
	virtual ~_ns4__cancelBetsByMarket() { }
};
#endif

#ifndef SOAP_TYPE__ns4__cancelBetsByMarketResponse
#define SOAP_TYPE__ns4__cancelBetsByMarketResponse (306)
/* ns4:cancelBetsByMarketResponse */
class SOAP_CMAC _ns4__cancelBetsByMarketResponse
{
public:
	class ns3__CancelBetsByMarketResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:CancelBetsByMarketResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 306; } /* = unique id SOAP_TYPE__ns4__cancelBetsByMarketResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__cancelBetsByMarketResponse(): Result(NULL), soap(NULL) { _ns4__cancelBetsByMarketResponse::soap_default(NULL); }
	virtual ~_ns4__cancelBetsByMarketResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__heartbeat
#define SOAP_TYPE__ns4__heartbeat (307)
/* ns4:heartbeat */
class SOAP_CMAC _ns4__heartbeat
{
public:
	class ns3__HeartbeatReq *request;	/* required element of type ns3:HeartbeatReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 307; } /* = unique id SOAP_TYPE__ns4__heartbeat */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__heartbeat(): request(NULL), soap(NULL) { _ns4__heartbeat::soap_default(NULL); }
	virtual ~_ns4__heartbeat() { }
};
#endif

#ifndef SOAP_TYPE__ns4__heartbeatResponse
#define SOAP_TYPE__ns4__heartbeatResponse (308)
/* ns4:heartbeatResponse */
class SOAP_CMAC _ns4__heartbeatResponse
{
public:
	class ns3__HeartbeatResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:HeartbeatResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 308; } /* = unique id SOAP_TYPE__ns4__heartbeatResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__heartbeatResponse(): Result(NULL), soap(NULL) { _ns4__heartbeatResponse::soap_default(NULL); }
	virtual ~_ns4__heartbeatResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getSilks
#define SOAP_TYPE__ns4__getSilks (309)
/* ns4:getSilks */
class SOAP_CMAC _ns4__getSilks
{
public:
	class ns3__GetSilksReq *request;	/* required element of type ns3:GetSilksReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 309; } /* = unique id SOAP_TYPE__ns4__getSilks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getSilks(): request(NULL), soap(NULL) { _ns4__getSilks::soap_default(NULL); }
	virtual ~_ns4__getSilks() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getSilksResponse
#define SOAP_TYPE__ns4__getSilksResponse (310)
/* ns4:getSilksResponse */
class SOAP_CMAC _ns4__getSilksResponse
{
public:
	class ns3__GetSilksResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetSilksResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 310; } /* = unique id SOAP_TYPE__ns4__getSilksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getSilksResponse(): Result(NULL), soap(NULL) { _ns4__getSilksResponse::soap_default(NULL); }
	virtual ~_ns4__getSilksResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getSilksV2
#define SOAP_TYPE__ns4__getSilksV2 (311)
/* ns4:getSilksV2 */
class SOAP_CMAC _ns4__getSilksV2
{
public:
	class ns3__GetSilksV2Req *request;	/* required element of type ns3:GetSilksV2Req */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 311; } /* = unique id SOAP_TYPE__ns4__getSilksV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getSilksV2(): request(NULL), soap(NULL) { _ns4__getSilksV2::soap_default(NULL); }
	virtual ~_ns4__getSilksV2() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getSilksV2Response
#define SOAP_TYPE__ns4__getSilksV2Response (312)
/* ns4:getSilksV2Response */
class SOAP_CMAC _ns4__getSilksV2Response
{
public:
	class ns3__GetSilksV2Resp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetSilksV2Resp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 312; } /* = unique id SOAP_TYPE__ns4__getSilksV2Response */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getSilksV2Response(): Result(NULL), soap(NULL) { _ns4__getSilksV2Response::soap_default(NULL); }
	virtual ~_ns4__getSilksV2Response() { }
};
#endif

#ifndef SOAP_TYPE__ns4__updateBets
#define SOAP_TYPE__ns4__updateBets (313)
/* ns4:updateBets */
class SOAP_CMAC _ns4__updateBets
{
public:
	class ns3__UpdateBetsReq *request;	/* required element of type ns3:UpdateBetsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 313; } /* = unique id SOAP_TYPE__ns4__updateBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__updateBets(): request(NULL), soap(NULL) { _ns4__updateBets::soap_default(NULL); }
	virtual ~_ns4__updateBets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__updateBetsResponse
#define SOAP_TYPE__ns4__updateBetsResponse (314)
/* ns4:updateBetsResponse */
class SOAP_CMAC _ns4__updateBetsResponse
{
public:
	class ns3__UpdateBetsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:UpdateBetsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 314; } /* = unique id SOAP_TYPE__ns4__updateBetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__updateBetsResponse(): Result(NULL), soap(NULL) { _ns4__updateBetsResponse::soap_default(NULL); }
	virtual ~_ns4__updateBetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__placeBets
#define SOAP_TYPE__ns4__placeBets (315)
/* ns4:placeBets */
class SOAP_CMAC _ns4__placeBets
{
public:
	class ns3__PlaceBetsReq *request;	/* required element of type ns3:PlaceBetsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 315; } /* = unique id SOAP_TYPE__ns4__placeBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__placeBets(): request(NULL), soap(NULL) { _ns4__placeBets::soap_default(NULL); }
	virtual ~_ns4__placeBets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__placeBetsResponse
#define SOAP_TYPE__ns4__placeBetsResponse (316)
/* ns4:placeBetsResponse */
class SOAP_CMAC _ns4__placeBetsResponse
{
public:
	class ns3__PlaceBetsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:PlaceBetsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 316; } /* = unique id SOAP_TYPE__ns4__placeBetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__placeBetsResponse(): Result(NULL), soap(NULL) { _ns4__placeBetsResponse::soap_default(NULL); }
	virtual ~_ns4__placeBetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCoupon
#define SOAP_TYPE__ns4__getCoupon (317)
/* ns4:getCoupon */
class SOAP_CMAC _ns4__getCoupon
{
public:
	class ns3__GetCouponReq *request;	/* required element of type ns3:GetCouponReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 317; } /* = unique id SOAP_TYPE__ns4__getCoupon */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCoupon(): request(NULL), soap(NULL) { _ns4__getCoupon::soap_default(NULL); }
	virtual ~_ns4__getCoupon() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCouponResponse
#define SOAP_TYPE__ns4__getCouponResponse (318)
/* ns4:getCouponResponse */
class SOAP_CMAC _ns4__getCouponResponse
{
public:
	class ns3__GetCouponResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetCouponResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 318; } /* = unique id SOAP_TYPE__ns4__getCouponResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCouponResponse(): Result(NULL), soap(NULL) { _ns4__getCouponResponse::soap_default(NULL); }
	virtual ~_ns4__getCouponResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarket
#define SOAP_TYPE__ns4__getMarket (319)
/* ns4:getMarket */
class SOAP_CMAC _ns4__getMarket
{
public:
	class ns3__GetMarketReq *request;	/* required element of type ns3:GetMarketReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 319; } /* = unique id SOAP_TYPE__ns4__getMarket */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarket(): request(NULL), soap(NULL) { _ns4__getMarket::soap_default(NULL); }
	virtual ~_ns4__getMarket() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketInfo
#define SOAP_TYPE__ns4__getMarketInfo (320)
/* ns4:getMarketInfo */
class SOAP_CMAC _ns4__getMarketInfo
{
public:
	class ns3__GetMarketInfoReq *request;	/* required element of type ns3:GetMarketInfoReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 320; } /* = unique id SOAP_TYPE__ns4__getMarketInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketInfo(): request(NULL), soap(NULL) { _ns4__getMarketInfo::soap_default(NULL); }
	virtual ~_ns4__getMarketInfo() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketInfoResponse
#define SOAP_TYPE__ns4__getMarketInfoResponse (321)
/* ns4:getMarketInfoResponse */
class SOAP_CMAC _ns4__getMarketInfoResponse
{
public:
	class ns3__GetMarketInfoResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMarketInfoResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 321; } /* = unique id SOAP_TYPE__ns4__getMarketInfoResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketInfoResponse(): Result(NULL), soap(NULL) { _ns4__getMarketInfoResponse::soap_default(NULL); }
	virtual ~_ns4__getMarketInfoResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketResponse
#define SOAP_TYPE__ns4__getMarketResponse (322)
/* ns4:getMarketResponse */
class SOAP_CMAC _ns4__getMarketResponse
{
public:
	class ns3__GetMarketResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMarketResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 322; } /* = unique id SOAP_TYPE__ns4__getMarketResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketResponse(): Result(NULL), soap(NULL) { _ns4__getMarketResponse::soap_default(NULL); }
	virtual ~_ns4__getMarketResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketPrices
#define SOAP_TYPE__ns4__getMarketPrices (323)
/* ns4:getMarketPrices */
class SOAP_CMAC _ns4__getMarketPrices
{
public:
	class ns3__GetMarketPricesReq *request;	/* required element of type ns3:GetMarketPricesReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 323; } /* = unique id SOAP_TYPE__ns4__getMarketPrices */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketPrices(): request(NULL), soap(NULL) { _ns4__getMarketPrices::soap_default(NULL); }
	virtual ~_ns4__getMarketPrices() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketPricesResponse
#define SOAP_TYPE__ns4__getMarketPricesResponse (324)
/* ns4:getMarketPricesResponse */
class SOAP_CMAC _ns4__getMarketPricesResponse
{
public:
	class ns3__GetMarketPricesResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMarketPricesResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 324; } /* = unique id SOAP_TYPE__ns4__getMarketPricesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketPricesResponse(): Result(NULL), soap(NULL) { _ns4__getMarketPricesResponse::soap_default(NULL); }
	virtual ~_ns4__getMarketPricesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCompleteMarketPricesCompressed
#define SOAP_TYPE__ns4__getCompleteMarketPricesCompressed (325)
/* ns4:getCompleteMarketPricesCompressed */
class SOAP_CMAC _ns4__getCompleteMarketPricesCompressed
{
public:
	class ns3__GetCompleteMarketPricesCompressedReq *request;	/* required element of type ns3:GetCompleteMarketPricesCompressedReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 325; } /* = unique id SOAP_TYPE__ns4__getCompleteMarketPricesCompressed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCompleteMarketPricesCompressed(): request(NULL), soap(NULL) { _ns4__getCompleteMarketPricesCompressed::soap_default(NULL); }
	virtual ~_ns4__getCompleteMarketPricesCompressed() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCompleteMarketPricesCompressedResponse
#define SOAP_TYPE__ns4__getCompleteMarketPricesCompressedResponse (326)
/* ns4:getCompleteMarketPricesCompressedResponse */
class SOAP_CMAC _ns4__getCompleteMarketPricesCompressedResponse
{
public:
	class ns3__GetCompleteMarketPricesCompressedResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetCompleteMarketPricesCompressedResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 326; } /* = unique id SOAP_TYPE__ns4__getCompleteMarketPricesCompressedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCompleteMarketPricesCompressedResponse(): Result(NULL), soap(NULL) { _ns4__getCompleteMarketPricesCompressedResponse::soap_default(NULL); }
	virtual ~_ns4__getCompleteMarketPricesCompressedResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketTradedVolumeCompressed
#define SOAP_TYPE__ns4__getMarketTradedVolumeCompressed (327)
/* ns4:getMarketTradedVolumeCompressed */
class SOAP_CMAC _ns4__getMarketTradedVolumeCompressed
{
public:
	class ns3__GetMarketTradedVolumeCompressedReq *request;	/* required element of type ns3:GetMarketTradedVolumeCompressedReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 327; } /* = unique id SOAP_TYPE__ns4__getMarketTradedVolumeCompressed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketTradedVolumeCompressed(): request(NULL), soap(NULL) { _ns4__getMarketTradedVolumeCompressed::soap_default(NULL); }
	virtual ~_ns4__getMarketTradedVolumeCompressed() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketTradedVolumeCompressedResponse
#define SOAP_TYPE__ns4__getMarketTradedVolumeCompressedResponse (328)
/* ns4:getMarketTradedVolumeCompressedResponse */
class SOAP_CMAC _ns4__getMarketTradedVolumeCompressedResponse
{
public:
	class ns3__GetMarketTradedVolumeCompressedResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMarketTradedVolumeCompressedResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 328; } /* = unique id SOAP_TYPE__ns4__getMarketTradedVolumeCompressedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketTradedVolumeCompressedResponse(): Result(NULL), soap(NULL) { _ns4__getMarketTradedVolumeCompressedResponse::soap_default(NULL); }
	virtual ~_ns4__getMarketTradedVolumeCompressedResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketPricesCompressed
#define SOAP_TYPE__ns4__getMarketPricesCompressed (329)
/* ns4:getMarketPricesCompressed */
class SOAP_CMAC _ns4__getMarketPricesCompressed
{
public:
	class ns3__GetMarketPricesCompressedReq *request;	/* required element of type ns3:GetMarketPricesCompressedReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 329; } /* = unique id SOAP_TYPE__ns4__getMarketPricesCompressed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketPricesCompressed(): request(NULL), soap(NULL) { _ns4__getMarketPricesCompressed::soap_default(NULL); }
	virtual ~_ns4__getMarketPricesCompressed() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketPricesCompressedResponse
#define SOAP_TYPE__ns4__getMarketPricesCompressedResponse (330)
/* ns4:getMarketPricesCompressedResponse */
class SOAP_CMAC _ns4__getMarketPricesCompressedResponse
{
public:
	class ns3__GetMarketPricesCompressedResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMarketPricesCompressedResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 330; } /* = unique id SOAP_TYPE__ns4__getMarketPricesCompressedResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketPricesCompressedResponse(): Result(NULL), soap(NULL) { _ns4__getMarketPricesCompressedResponse::soap_default(NULL); }
	virtual ~_ns4__getMarketPricesCompressedResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getAllMarkets
#define SOAP_TYPE__ns4__getAllMarkets (331)
/* ns4:getAllMarkets */
class SOAP_CMAC _ns4__getAllMarkets
{
public:
	class ns3__GetAllMarketsReq *request;	/* required element of type ns3:GetAllMarketsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 331; } /* = unique id SOAP_TYPE__ns4__getAllMarkets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getAllMarkets(): request(NULL), soap(NULL) { _ns4__getAllMarkets::soap_default(NULL); }
	virtual ~_ns4__getAllMarkets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getAllMarketsResponse
#define SOAP_TYPE__ns4__getAllMarketsResponse (332)
/* ns4:getAllMarketsResponse */
class SOAP_CMAC _ns4__getAllMarketsResponse
{
public:
	class ns3__GetAllMarketsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetAllMarketsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 332; } /* = unique id SOAP_TYPE__ns4__getAllMarketsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getAllMarketsResponse(): Result(NULL), soap(NULL) { _ns4__getAllMarketsResponse::soap_default(NULL); }
	virtual ~_ns4__getAllMarketsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getInPlayMarkets
#define SOAP_TYPE__ns4__getInPlayMarkets (333)
/* ns4:getInPlayMarkets */
class SOAP_CMAC _ns4__getInPlayMarkets
{
public:
	class ns3__GetInPlayMarketsReq *request;	/* required element of type ns3:GetInPlayMarketsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 333; } /* = unique id SOAP_TYPE__ns4__getInPlayMarkets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getInPlayMarkets(): request(NULL), soap(NULL) { _ns4__getInPlayMarkets::soap_default(NULL); }
	virtual ~_ns4__getInPlayMarkets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getInPlayMarketsResponse
#define SOAP_TYPE__ns4__getInPlayMarketsResponse (334)
/* ns4:getInPlayMarketsResponse */
class SOAP_CMAC _ns4__getInPlayMarketsResponse
{
public:
	class ns3__GetInPlayMarketsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetInPlayMarketsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 334; } /* = unique id SOAP_TYPE__ns4__getInPlayMarketsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getInPlayMarketsResponse(): Result(NULL), soap(NULL) { _ns4__getInPlayMarketsResponse::soap_default(NULL); }
	virtual ~_ns4__getInPlayMarketsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getPrivateMarkets
#define SOAP_TYPE__ns4__getPrivateMarkets (335)
/* ns4:getPrivateMarkets */
class SOAP_CMAC _ns4__getPrivateMarkets
{
public:
	class ns3__GetPrivateMarketsReq *request;	/* required element of type ns3:GetPrivateMarketsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 335; } /* = unique id SOAP_TYPE__ns4__getPrivateMarkets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getPrivateMarkets(): request(NULL), soap(NULL) { _ns4__getPrivateMarkets::soap_default(NULL); }
	virtual ~_ns4__getPrivateMarkets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getPrivateMarketsResponse
#define SOAP_TYPE__ns4__getPrivateMarketsResponse (336)
/* ns4:getPrivateMarketsResponse */
class SOAP_CMAC _ns4__getPrivateMarketsResponse
{
public:
	class ns3__GetPrivateMarketsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetPrivateMarketsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 336; } /* = unique id SOAP_TYPE__ns4__getPrivateMarketsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getPrivateMarketsResponse(): Result(NULL), soap(NULL) { _ns4__getPrivateMarketsResponse::soap_default(NULL); }
	virtual ~_ns4__getPrivateMarketsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCurrentBets
#define SOAP_TYPE__ns4__getCurrentBets (337)
/* ns4:getCurrentBets */
class SOAP_CMAC _ns4__getCurrentBets
{
public:
	class ns3__GetCurrentBetsReq *request;	/* required element of type ns3:GetCurrentBetsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 337; } /* = unique id SOAP_TYPE__ns4__getCurrentBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCurrentBets(): request(NULL), soap(NULL) { _ns4__getCurrentBets::soap_default(NULL); }
	virtual ~_ns4__getCurrentBets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCurrentBetsResponse
#define SOAP_TYPE__ns4__getCurrentBetsResponse (338)
/* ns4:getCurrentBetsResponse */
class SOAP_CMAC _ns4__getCurrentBetsResponse
{
public:
	class ns3__GetCurrentBetsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetCurrentBetsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 338; } /* = unique id SOAP_TYPE__ns4__getCurrentBetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCurrentBetsResponse(): Result(NULL), soap(NULL) { _ns4__getCurrentBetsResponse::soap_default(NULL); }
	virtual ~_ns4__getCurrentBetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCurrentBetsLite
#define SOAP_TYPE__ns4__getCurrentBetsLite (339)
/* ns4:getCurrentBetsLite */
class SOAP_CMAC _ns4__getCurrentBetsLite
{
public:
	class ns3__GetCurrentBetsLiteReq *request;	/* required element of type ns3:GetCurrentBetsLiteReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 339; } /* = unique id SOAP_TYPE__ns4__getCurrentBetsLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCurrentBetsLite(): request(NULL), soap(NULL) { _ns4__getCurrentBetsLite::soap_default(NULL); }
	virtual ~_ns4__getCurrentBetsLite() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getCurrentBetsLiteResponse
#define SOAP_TYPE__ns4__getCurrentBetsLiteResponse (340)
/* ns4:getCurrentBetsLiteResponse */
class SOAP_CMAC _ns4__getCurrentBetsLiteResponse
{
public:
	class ns3__GetCurrentBetsLiteResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetCurrentBetsLiteResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 340; } /* = unique id SOAP_TYPE__ns4__getCurrentBetsLiteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getCurrentBetsLiteResponse(): Result(NULL), soap(NULL) { _ns4__getCurrentBetsLiteResponse::soap_default(NULL); }
	virtual ~_ns4__getCurrentBetsLiteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMUBets
#define SOAP_TYPE__ns4__getMUBets (341)
/* ns4:getMUBets */
class SOAP_CMAC _ns4__getMUBets
{
public:
	class ns3__GetMUBetsReq *request;	/* required element of type ns3:GetMUBetsReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 341; } /* = unique id SOAP_TYPE__ns4__getMUBets */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMUBets(): request(NULL), soap(NULL) { _ns4__getMUBets::soap_default(NULL); }
	virtual ~_ns4__getMUBets() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMUBetsResponse
#define SOAP_TYPE__ns4__getMUBetsResponse (342)
/* ns4:getMUBetsResponse */
class SOAP_CMAC _ns4__getMUBetsResponse
{
public:
	class ns3__GetMUBetsResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMUBetsResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 342; } /* = unique id SOAP_TYPE__ns4__getMUBetsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMUBetsResponse(): Result(NULL), soap(NULL) { _ns4__getMUBetsResponse::soap_default(NULL); }
	virtual ~_ns4__getMUBetsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMUBetsLite
#define SOAP_TYPE__ns4__getMUBetsLite (343)
/* ns4:getMUBetsLite */
class SOAP_CMAC _ns4__getMUBetsLite
{
public:
	class ns3__GetMUBetsLiteReq *request;	/* required element of type ns3:GetMUBetsLiteReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 343; } /* = unique id SOAP_TYPE__ns4__getMUBetsLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMUBetsLite(): request(NULL), soap(NULL) { _ns4__getMUBetsLite::soap_default(NULL); }
	virtual ~_ns4__getMUBetsLite() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMUBetsLiteResponse
#define SOAP_TYPE__ns4__getMUBetsLiteResponse (344)
/* ns4:getMUBetsLiteResponse */
class SOAP_CMAC _ns4__getMUBetsLiteResponse
{
public:
	class ns3__GetMUBetsLiteResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMUBetsLiteResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 344; } /* = unique id SOAP_TYPE__ns4__getMUBetsLiteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMUBetsLiteResponse(): Result(NULL), soap(NULL) { _ns4__getMUBetsLiteResponse::soap_default(NULL); }
	virtual ~_ns4__getMUBetsLiteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getDetailAvailableMktDepth
#define SOAP_TYPE__ns4__getDetailAvailableMktDepth (345)
/* ns4:getDetailAvailableMktDepth */
class SOAP_CMAC _ns4__getDetailAvailableMktDepth
{
public:
	class ns3__GetDetailedAvailableMktDepthReq *request;	/* required element of type ns3:GetDetailedAvailableMktDepthReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 345; } /* = unique id SOAP_TYPE__ns4__getDetailAvailableMktDepth */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getDetailAvailableMktDepth(): request(NULL), soap(NULL) { _ns4__getDetailAvailableMktDepth::soap_default(NULL); }
	virtual ~_ns4__getDetailAvailableMktDepth() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getDetailAvailableMktDepthResponse
#define SOAP_TYPE__ns4__getDetailAvailableMktDepthResponse (346)
/* ns4:getDetailAvailableMktDepthResponse */
class SOAP_CMAC _ns4__getDetailAvailableMktDepthResponse
{
public:
	class ns3__GetDetailedAvailableMktDepthResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetDetailedAvailableMktDepthResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 346; } /* = unique id SOAP_TYPE__ns4__getDetailAvailableMktDepthResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getDetailAvailableMktDepthResponse(): Result(NULL), soap(NULL) { _ns4__getDetailAvailableMktDepthResponse::soap_default(NULL); }
	virtual ~_ns4__getDetailAvailableMktDepthResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketTradedVolume
#define SOAP_TYPE__ns4__getMarketTradedVolume (347)
/* ns4:getMarketTradedVolume */
class SOAP_CMAC _ns4__getMarketTradedVolume
{
public:
	class ns3__GetMarketTradedVolumeReq *request;	/* required element of type ns3:GetMarketTradedVolumeReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 347; } /* = unique id SOAP_TYPE__ns4__getMarketTradedVolume */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketTradedVolume(): request(NULL), soap(NULL) { _ns4__getMarketTradedVolume::soap_default(NULL); }
	virtual ~_ns4__getMarketTradedVolume() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketTradedVolumeResponse
#define SOAP_TYPE__ns4__getMarketTradedVolumeResponse (348)
/* ns4:getMarketTradedVolumeResponse */
class SOAP_CMAC _ns4__getMarketTradedVolumeResponse
{
public:
	class ns3__GetMarketTradedVolumeResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMarketTradedVolumeResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 348; } /* = unique id SOAP_TYPE__ns4__getMarketTradedVolumeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketTradedVolumeResponse(): Result(NULL), soap(NULL) { _ns4__getMarketTradedVolumeResponse::soap_default(NULL); }
	virtual ~_ns4__getMarketTradedVolumeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBetHistory
#define SOAP_TYPE__ns4__getBetHistory (349)
/* ns4:getBetHistory */
class SOAP_CMAC _ns4__getBetHistory
{
public:
	class ns3__GetBetHistoryReq *request;	/* required element of type ns3:GetBetHistoryReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 349; } /* = unique id SOAP_TYPE__ns4__getBetHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBetHistory(): request(NULL), soap(NULL) { _ns4__getBetHistory::soap_default(NULL); }
	virtual ~_ns4__getBetHistory() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBetHistoryResponse
#define SOAP_TYPE__ns4__getBetHistoryResponse (350)
/* ns4:getBetHistoryResponse */
class SOAP_CMAC _ns4__getBetHistoryResponse
{
public:
	class ns3__GetBetHistoryResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetBetHistoryResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 350; } /* = unique id SOAP_TYPE__ns4__getBetHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBetHistoryResponse(): Result(NULL), soap(NULL) { _ns4__getBetHistoryResponse::soap_default(NULL); }
	virtual ~_ns4__getBetHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getAccountStatement
#define SOAP_TYPE__ns4__getAccountStatement (351)
/* ns4:getAccountStatement */
class SOAP_CMAC _ns4__getAccountStatement
{
public:
	class ns3__GetAccountStatementReq *req;	/* required element of type ns3:GetAccountStatementReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 351; } /* = unique id SOAP_TYPE__ns4__getAccountStatement */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getAccountStatement(): req(NULL), soap(NULL) { _ns4__getAccountStatement::soap_default(NULL); }
	virtual ~_ns4__getAccountStatement() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getAccountStatementResponse
#define SOAP_TYPE__ns4__getAccountStatementResponse (352)
/* ns4:getAccountStatementResponse */
class SOAP_CMAC _ns4__getAccountStatementResponse
{
public:
	class ns3__GetAccountStatementResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetAccountStatementResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 352; } /* = unique id SOAP_TYPE__ns4__getAccountStatementResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getAccountStatementResponse(): Result(NULL), soap(NULL) { _ns4__getAccountStatementResponse::soap_default(NULL); }
	virtual ~_ns4__getAccountStatementResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketProfitAndLoss
#define SOAP_TYPE__ns4__getMarketProfitAndLoss (353)
/* ns4:getMarketProfitAndLoss */
class SOAP_CMAC _ns4__getMarketProfitAndLoss
{
public:
	class ns3__GetMarketProfitAndLossReq *request;	/* required element of type ns3:GetMarketProfitAndLossReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 353; } /* = unique id SOAP_TYPE__ns4__getMarketProfitAndLoss */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketProfitAndLoss(): request(NULL), soap(NULL) { _ns4__getMarketProfitAndLoss::soap_default(NULL); }
	virtual ~_ns4__getMarketProfitAndLoss() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getMarketProfitAndLossResponse
#define SOAP_TYPE__ns4__getMarketProfitAndLossResponse (354)
/* ns4:getMarketProfitAndLossResponse */
class SOAP_CMAC _ns4__getMarketProfitAndLossResponse
{
public:
	class ns3__GetMarketProfitAndLossResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetMarketProfitAndLossResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 354; } /* = unique id SOAP_TYPE__ns4__getMarketProfitAndLossResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getMarketProfitAndLossResponse(): Result(NULL), soap(NULL) { _ns4__getMarketProfitAndLossResponse::soap_default(NULL); }
	virtual ~_ns4__getMarketProfitAndLossResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBet
#define SOAP_TYPE__ns4__getBet (355)
/* ns4:getBet */
class SOAP_CMAC _ns4__getBet
{
public:
	class ns3__GetBetReq *request;	/* required element of type ns3:GetBetReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 355; } /* = unique id SOAP_TYPE__ns4__getBet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBet(): request(NULL), soap(NULL) { _ns4__getBet::soap_default(NULL); }
	virtual ~_ns4__getBet() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBetResponse
#define SOAP_TYPE__ns4__getBetResponse (356)
/* ns4:getBetResponse */
class SOAP_CMAC _ns4__getBetResponse
{
public:
	class ns3__GetBetResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetBetResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 356; } /* = unique id SOAP_TYPE__ns4__getBetResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBetResponse(): Result(NULL), soap(NULL) { _ns4__getBetResponse::soap_default(NULL); }
	virtual ~_ns4__getBetResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBetLite
#define SOAP_TYPE__ns4__getBetLite (357)
/* ns4:getBetLite */
class SOAP_CMAC _ns4__getBetLite
{
public:
	class ns3__GetBetLiteReq *request;	/* required element of type ns3:GetBetLiteReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 357; } /* = unique id SOAP_TYPE__ns4__getBetLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBetLite(): request(NULL), soap(NULL) { _ns4__getBetLite::soap_default(NULL); }
	virtual ~_ns4__getBetLite() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBetLiteResponse
#define SOAP_TYPE__ns4__getBetLiteResponse (358)
/* ns4:getBetLiteResponse */
class SOAP_CMAC _ns4__getBetLiteResponse
{
public:
	class ns3__GetBetLiteResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetBetLiteResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 358; } /* = unique id SOAP_TYPE__ns4__getBetLiteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBetLiteResponse(): Result(NULL), soap(NULL) { _ns4__getBetLiteResponse::soap_default(NULL); }
	virtual ~_ns4__getBetLiteResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBetMatchesLite
#define SOAP_TYPE__ns4__getBetMatchesLite (359)
/* ns4:getBetMatchesLite */
class SOAP_CMAC _ns4__getBetMatchesLite
{
public:
	class ns3__GetBetMatchesLiteReq *request;	/* required element of type ns3:GetBetMatchesLiteReq */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 359; } /* = unique id SOAP_TYPE__ns4__getBetMatchesLite */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBetMatchesLite(): request(NULL), soap(NULL) { _ns4__getBetMatchesLite::soap_default(NULL); }
	virtual ~_ns4__getBetMatchesLite() { }
};
#endif

#ifndef SOAP_TYPE__ns4__getBetMatchesLiteResponse
#define SOAP_TYPE__ns4__getBetMatchesLiteResponse (360)
/* ns4:getBetMatchesLiteResponse */
class SOAP_CMAC _ns4__getBetMatchesLiteResponse
{
public:
	class ns3__GetBetMatchesLiteResp *Result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns3:GetBetMatchesLiteResp */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 360; } /* = unique id SOAP_TYPE__ns4__getBetMatchesLiteResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__getBetMatchesLiteResponse(): Result(NULL), soap(NULL) { _ns4__getBetMatchesLiteResponse::soap_default(NULL); }
	virtual ~_ns4__getBetMatchesLiteResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LoginResp
#define SOAP_TYPE_ns1__LoginResp (8)
/* ns1:LoginResp */
class SOAP_CMAC ns1__LoginResp : public ns1__APIResponse
{
public:
	std::string *currency;	/* optional element of type xsd:string */
	enum ns1__LoginErrorEnum errorCode;	/* required element of type ns1:LoginErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	time_t validUntil;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns1__LoginResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LoginResp(): currency(NULL), minorErrorCode(NULL) { ns1__LoginResp::soap_default(NULL); }
	virtual ~ns1__LoginResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveLIMBMessageReq
#define SOAP_TYPE_ns1__RetrieveLIMBMessageReq (12)
/* ns1:RetrieveLIMBMessageReq */
class SOAP_CMAC ns1__RetrieveLIMBMessageReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__RetrieveLIMBMessageReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveLIMBMessageReq() { ns1__RetrieveLIMBMessageReq::soap_default(NULL); }
	virtual ~ns1__RetrieveLIMBMessageReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RetrieveLIMBMessageResp
#define SOAP_TYPE_ns1__RetrieveLIMBMessageResp (13)
/* ns1:RetrieveLIMBMessageResp */
class SOAP_CMAC ns1__RetrieveLIMBMessageResp : public ns1__APIResponse
{
public:
	enum ns1__RetrieveLIMBMessageErrorEnum errorCode;	/* required element of type ns1:RetrieveLIMBMessageErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	int totalMessagesCount;	/* required element of type xsd:int */
	ns1__RetrievePersonalLIMBMessage *retrievePersonalMessage;	/* required element of type ns1:RetrievePersonalLIMBMessage */
	ns1__RetrieveTCPrivacyPolicyChangeLIMBMessage *retrieveTCPrivacyPolicyChangeMessage;	/* required element of type ns1:RetrieveTCPrivacyPolicyChangeLIMBMessage */
	ns1__RetrievePasswordChangeLIMBMessage *retrievePasswordChangeMessage;	/* required element of type ns1:RetrievePasswordChangeLIMBMessage */
	ns1__RetrieveBirthDateCheckLIMBMessage *retrieveBirthDateCheckMessage;	/* required element of type ns1:RetrieveBirthDateCheckLIMBMessage */
	ns1__RetrieveAddressCheckLIMBMessage *retrieveAddressCheckMessage;	/* required element of type ns1:RetrieveAddressCheckLIMBMessage */
	ns1__RetrieveContactDetailsCheckLIMBMessage *retrieveContactDetailsCheckMessage;	/* required element of type ns1:RetrieveContactDetailsCheckLIMBMessage */
	ns1__RetrieveChatNameChangeLIMBMessage *retrieveChatNameChangeMessage;	/* required element of type ns1:RetrieveChatNameChangeLIMBMessage */
	ns1__ArrayOfRetrieveCardBillingAddressCheckLIMBMessage *retrieveCardBillingAddressCheckItems;	/* optional element of type ns1:ArrayOfRetrieveCardBillingAddressCheckLIMBMessage */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__RetrieveLIMBMessageResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RetrieveLIMBMessageResp(): minorErrorCode(NULL), retrievePersonalMessage(NULL), retrieveTCPrivacyPolicyChangeMessage(NULL), retrievePasswordChangeMessage(NULL), retrieveBirthDateCheckMessage(NULL), retrieveAddressCheckMessage(NULL), retrieveContactDetailsCheckMessage(NULL), retrieveChatNameChangeMessage(NULL), retrieveCardBillingAddressCheckItems(NULL) { ns1__RetrieveLIMBMessageResp::soap_default(NULL); }
	virtual ~ns1__RetrieveLIMBMessageResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitLIMBMessageReq
#define SOAP_TYPE_ns1__SubmitLIMBMessageReq (23)
/* ns1:SubmitLIMBMessageReq */
class SOAP_CMAC ns1__SubmitLIMBMessageReq : public ns1__APIRequest
{
public:
	std::string password;	/* required element of type xsd:string */
	ns1__SubmitPersonalLIMBMessage *submitPersonalMessage;	/* required element of type ns1:SubmitPersonalLIMBMessage */
	ns1__SubmitTCPrivacyPolicyChangeLIMBMessage *submitTCPrivacyPolicyChangeMessage;	/* required element of type ns1:SubmitTCPrivacyPolicyChangeLIMBMessage */
	ns1__SubmitPasswordChangeLIMBMessage *submitPasswordChangeMessage;	/* required element of type ns1:SubmitPasswordChangeLIMBMessage */
	ns1__SubmitBirthDateCheckLIMBMessage *submitBirthDateCheckMessage;	/* required element of type ns1:SubmitBirthDateCheckLIMBMessage */
	ns1__SubmitAddressCheckLIMBMessage *submitAddressCheckMessage;	/* required element of type ns1:SubmitAddressCheckLIMBMessage */
	ns1__SubmitContactDetailsCheckLIMBMessage *submitContactDetailsCheckMessage;	/* required element of type ns1:SubmitContactDetailsCheckLIMBMessage */
	ns1__SubmitChatNameChangeLIMBMessage *submitChatNameChangeMessage;	/* required element of type ns1:SubmitChatNameChangeLIMBMessage */
	ns1__ArrayOfSubmitCardBillingAddressCheckLIMBMessage *submitCardBillingAddressCheckItems;	/* optional element of type ns1:ArrayOfSubmitCardBillingAddressCheckLIMBMessage */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__SubmitLIMBMessageReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitLIMBMessageReq(): submitPersonalMessage(NULL), submitTCPrivacyPolicyChangeMessage(NULL), submitPasswordChangeMessage(NULL), submitBirthDateCheckMessage(NULL), submitAddressCheckMessage(NULL), submitContactDetailsCheckMessage(NULL), submitChatNameChangeMessage(NULL), submitCardBillingAddressCheckItems(NULL) { ns1__SubmitLIMBMessageReq::soap_default(NULL); }
	virtual ~ns1__SubmitLIMBMessageReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SubmitLIMBMessageResp
#define SOAP_TYPE_ns1__SubmitLIMBMessageResp (33)
/* ns1:SubmitLIMBMessageResp */
class SOAP_CMAC ns1__SubmitLIMBMessageResp : public ns1__APIResponse
{
public:
	enum ns1__SubmitLIMBMessageErrorEnum errorCode;	/* required element of type ns1:SubmitLIMBMessageErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns1__ArrayOfLIMBValidationErrorsEnum *validationErrors;	/* optional element of type ns1:ArrayOfLIMBValidationErrorsEnum */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__SubmitLIMBMessageResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SubmitLIMBMessageResp(): minorErrorCode(NULL), validationErrors(NULL) { ns1__SubmitLIMBMessageResp::soap_default(NULL); }
	virtual ~ns1__SubmitLIMBMessageResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LogoutResp
#define SOAP_TYPE_ns1__LogoutResp (35)
/* ns1:LogoutResp */
class SOAP_CMAC ns1__LogoutResp : public ns1__APIResponse
{
public:
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	enum ns1__LogoutErrorEnum errorCode;	/* required element of type ns1:LogoutErrorEnum */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__LogoutResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LogoutResp(): minorErrorCode(NULL) { ns1__LogoutResp::soap_default(NULL); }
	virtual ~ns1__LogoutResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LogoutReq
#define SOAP_TYPE_ns1__LogoutReq (36)
/* ns1:LogoutReq */
class SOAP_CMAC ns1__LogoutReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__LogoutReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LogoutReq() { ns1__LogoutReq::soap_default(NULL); }
	virtual ~ns1__LogoutReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__KeepAliveResp
#define SOAP_TYPE_ns1__KeepAliveResp (37)
/* ns1:KeepAliveResp */
class SOAP_CMAC ns1__KeepAliveResp : public ns1__APIResponse
{
public:
	std::string *apiVersion;	/* optional element of type xsd:string */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__KeepAliveResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__KeepAliveResp(): apiVersion(NULL), minorErrorCode(NULL) { ns1__KeepAliveResp::soap_default(NULL); }
	virtual ~ns1__KeepAliveResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__KeepAliveReq
#define SOAP_TYPE_ns1__KeepAliveReq (38)
/* ns1:KeepAliveReq */
class SOAP_CMAC ns1__KeepAliveReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__KeepAliveReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__KeepAliveReq() { ns1__KeepAliveReq::soap_default(NULL); }
	virtual ~ns1__KeepAliveReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetEventsResp
#define SOAP_TYPE_ns1__GetEventsResp (41)
/* ns1:GetEventsResp */
class SOAP_CMAC ns1__GetEventsResp : public ns1__APIResponse
{
public:
	enum ns1__GetEventsErrorEnum errorCode;	/* required element of type ns1:GetEventsErrorEnum */
	ns1__ArrayOfBFEvent *eventItems;	/* optional element of type ns1:ArrayOfBFEvent */
	int eventParentId;	/* required element of type xsd:int */
	ns1__ArrayOfMarketSummary *marketItems;	/* optional element of type ns1:ArrayOfMarketSummary */
	ns1__ArrayOfCouponLinks *couponLinks;	/* optional element of type ns1:ArrayOfCouponLinks */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__GetEventsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetEventsResp(): eventItems(NULL), marketItems(NULL), couponLinks(NULL), minorErrorCode(NULL) { ns1__GetEventsResp::soap_default(NULL); }
	virtual ~ns1__GetEventsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetEventsReq
#define SOAP_TYPE_ns1__GetEventsReq (48)
/* ns1:GetEventsReq */
class SOAP_CMAC ns1__GetEventsReq : public ns1__APIRequest
{
public:
	int eventParentId;	/* required element of type xsd:int */
	std::string *locale;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__GetEventsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetEventsReq(): locale(NULL) { ns1__GetEventsReq::soap_default(NULL); }
	virtual ~ns1__GetEventsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetEventTypesResp
#define SOAP_TYPE_ns1__GetEventTypesResp (49)
/* ns1:GetEventTypesResp */
class SOAP_CMAC ns1__GetEventTypesResp : public ns1__APIResponse
{
public:
	ns1__ArrayOfEventType *eventTypeItems;	/* optional element of type ns1:ArrayOfEventType */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	enum ns1__GetEventsErrorEnum errorCode;	/* required element of type ns1:GetEventsErrorEnum */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns1__GetEventTypesResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetEventTypesResp(): eventTypeItems(NULL), minorErrorCode(NULL) { ns1__GetEventTypesResp::soap_default(NULL); }
	virtual ~ns1__GetEventTypesResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetEventTypesReq
#define SOAP_TYPE_ns1__GetEventTypesReq (52)
/* ns1:GetEventTypesReq */
class SOAP_CMAC ns1__GetEventTypesReq : public ns1__APIRequest
{
public:
	std::string *locale;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__GetEventTypesReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetEventTypesReq(): locale(NULL) { ns1__GetEventTypesReq::soap_default(NULL); }
	virtual ~ns1__GetEventTypesReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetSubscriptionInfoResp
#define SOAP_TYPE_ns1__GetSubscriptionInfoResp (54)
/* ns1:GetSubscriptionInfoResp */
class SOAP_CMAC ns1__GetSubscriptionInfoResp : public ns1__APIResponse
{
public:
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns1__ArrayOfSubscription *subscriptions;	/* optional element of type ns1:ArrayOfSubscription */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns1__GetSubscriptionInfoResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetSubscriptionInfoResp(): minorErrorCode(NULL), subscriptions(NULL) { ns1__GetSubscriptionInfoResp::soap_default(NULL); }
	virtual ~ns1__GetSubscriptionInfoResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetSubscriptionInfoReq
#define SOAP_TYPE_ns1__GetSubscriptionInfoReq (59)
/* ns1:GetSubscriptionInfoReq */
class SOAP_CMAC ns1__GetSubscriptionInfoReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__GetSubscriptionInfoReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetSubscriptionInfoReq() { ns1__GetSubscriptionInfoReq::soap_default(NULL); }
	virtual ~ns1__GetSubscriptionInfoReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DepositFromPaymentCardResp
#define SOAP_TYPE_ns1__DepositFromPaymentCardResp (60)
/* ns1:DepositFromPaymentCardResp */
class SOAP_CMAC ns1__DepositFromPaymentCardResp : public ns1__APIResponse
{
public:
	enum ns1__PaymentsErrorEnum errorCode;	/* required element of type ns1:PaymentsErrorEnum */
	double fee;	/* required element of type xsd:double */
	double maxAmount;	/* required element of type xsd:double */
	double minAmount;	/* required element of type xsd:double */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	double netAmount;	/* required element of type xsd:double */
	std::string transactionId;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns1__DepositFromPaymentCardResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DepositFromPaymentCardResp(): minorErrorCode(NULL) { ns1__DepositFromPaymentCardResp::soap_default(NULL); }
	virtual ~ns1__DepositFromPaymentCardResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DepositFromPaymentCardReq
#define SOAP_TYPE_ns1__DepositFromPaymentCardReq (61)
/* ns1:DepositFromPaymentCardReq */
class SOAP_CMAC ns1__DepositFromPaymentCardReq : public ns1__APIRequest
{
public:
	double amount;	/* required element of type xsd:double */
	std::string *cardIdentifier;	/* optional element of type xsd:string */
	std::string *cv2;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__DepositFromPaymentCardReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DepositFromPaymentCardReq(): cardIdentifier(NULL), cv2(NULL), password(NULL) { ns1__DepositFromPaymentCardReq::soap_default(NULL); }
	virtual ~ns1__DepositFromPaymentCardReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AddPaymentCardReq
#define SOAP_TYPE_ns1__AddPaymentCardReq (62)
/* ns1:AddPaymentCardReq */
class SOAP_CMAC ns1__AddPaymentCardReq : public ns1__APIRequest
{
public:
	std::string cardNumber;	/* required element of type xsd:string */
	enum ns1__CardTypeEnum cardType;	/* required element of type ns1:CardTypeEnum */
	std::string *startDate;	/* optional element of type xsd:string */
	std::string expiryDate;	/* required element of type xsd:string */
	std::string *issueNumber;	/* optional element of type xsd:string */
	std::string billingName;	/* required element of type xsd:string */
	std::string nickName;	/* required element of type xsd:string */
	std::string password;	/* required element of type xsd:string */
	std::string address1;	/* required element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string *address4;	/* optional element of type xsd:string */
	std::string *town;	/* optional element of type xsd:string */
	std::string *county;	/* optional element of type xsd:string */
	std::string *zipCode;	/* optional element of type xsd:string */
	std::string *country;	/* optional element of type xsd:string */
	enum ns1__PaymentCardStatusEnum cardStatus;	/* required element of type ns1:PaymentCardStatusEnum */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns1__AddPaymentCardReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AddPaymentCardReq(): startDate(NULL), issueNumber(NULL), address2(NULL), address3(NULL), address4(NULL), town(NULL), county(NULL), zipCode(NULL), country(NULL) { ns1__AddPaymentCardReq::soap_default(NULL); }
	virtual ~ns1__AddPaymentCardReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DeletePaymentCardReq
#define SOAP_TYPE_ns1__DeletePaymentCardReq (63)
/* ns1:DeletePaymentCardReq */
class SOAP_CMAC ns1__DeletePaymentCardReq : public ns1__APIRequest
{
public:
	std::string nickName;	/* required element of type xsd:string */
	std::string password;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns1__DeletePaymentCardReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DeletePaymentCardReq() { ns1__DeletePaymentCardReq::soap_default(NULL); }
	virtual ~ns1__DeletePaymentCardReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetPaymentCardReq
#define SOAP_TYPE_ns1__GetPaymentCardReq (64)
/* ns1:GetPaymentCardReq */
class SOAP_CMAC ns1__GetPaymentCardReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__GetPaymentCardReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetPaymentCardReq() { ns1__GetPaymentCardReq::soap_default(NULL); }
	virtual ~ns1__GetPaymentCardReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UpdatePaymentCardReq
#define SOAP_TYPE_ns1__UpdatePaymentCardReq (65)
/* ns1:UpdatePaymentCardReq */
class SOAP_CMAC ns1__UpdatePaymentCardReq : public ns1__APIRequest
{
public:
	std::string nickName;	/* required element of type xsd:string */
	std::string password;	/* required element of type xsd:string */
	std::string *expiryDate;	/* optional element of type xsd:string */
	std::string *startDate;	/* optional element of type xsd:string */
	std::string *issueNumber;	/* optional element of type xsd:string */
	std::string *address1;	/* optional element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string *address4;	/* optional element of type xsd:string */
	std::string *town;	/* optional element of type xsd:string */
	std::string *county;	/* optional element of type xsd:string */
	std::string *zipCode;	/* optional element of type xsd:string */
	std::string *country;	/* optional element of type xsd:string */
	enum ns1__PaymentCardStatusEnum cardStatus;	/* required element of type ns1:PaymentCardStatusEnum */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns1__UpdatePaymentCardReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UpdatePaymentCardReq(): expiryDate(NULL), startDate(NULL), issueNumber(NULL), address1(NULL), address2(NULL), address3(NULL), address4(NULL), town(NULL), county(NULL), zipCode(NULL), country(NULL) { ns1__UpdatePaymentCardReq::soap_default(NULL); }
	virtual ~ns1__UpdatePaymentCardReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AddPaymentCardResp
#define SOAP_TYPE_ns1__AddPaymentCardResp (66)
/* ns1:AddPaymentCardResp */
class SOAP_CMAC ns1__AddPaymentCardResp : public ns1__APIResponse
{
public:
	enum ns1__AddPaymentCardErrorEnum errorCode;	/* required element of type ns1:AddPaymentCardErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns1__PaymentCard *paymentCard;	/* required element of type ns1:PaymentCard */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns1__AddPaymentCardResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AddPaymentCardResp(): minorErrorCode(NULL), paymentCard(NULL) { ns1__AddPaymentCardResp::soap_default(NULL); }
	virtual ~ns1__AddPaymentCardResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DeletePaymentCardResp
#define SOAP_TYPE_ns1__DeletePaymentCardResp (67)
/* ns1:DeletePaymentCardResp */
class SOAP_CMAC ns1__DeletePaymentCardResp : public ns1__APIResponse
{
public:
	enum ns1__DeletePaymentCardErrorEnum errorCode;	/* required element of type ns1:DeletePaymentCardErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	std::string nickName;	/* required element of type xsd:string */
	std::string billingName;	/* required element of type xsd:string */
	std::string cardShortNumber;	/* required element of type xsd:string */
	enum ns1__CardTypeEnum cardType;	/* required element of type ns1:CardTypeEnum */
	std::string *issuingCountry;	/* optional element of type xsd:string */
	std::string expiryDate;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns1__DeletePaymentCardResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DeletePaymentCardResp(): minorErrorCode(NULL), issuingCountry(NULL) { ns1__DeletePaymentCardResp::soap_default(NULL); }
	virtual ~ns1__DeletePaymentCardResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UpdatePaymentCardResp
#define SOAP_TYPE_ns1__UpdatePaymentCardResp (68)
/* ns1:UpdatePaymentCardResp */
class SOAP_CMAC ns1__UpdatePaymentCardResp : public ns1__APIResponse
{
public:
	enum ns1__UpdatePaymentCardErrorEnum errorCode;	/* required element of type ns1:UpdatePaymentCardErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	std::string nickName;	/* required element of type xsd:string */
	std::string billingName;	/* required element of type xsd:string */
	enum ns1__CardTypeEnum cardType;	/* required element of type ns1:CardTypeEnum */
	std::string expiryDate;	/* required element of type xsd:string */
	std::string *startDate;	/* optional element of type xsd:string */
	std::string address1;	/* required element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string *address4;	/* optional element of type xsd:string */
	std::string *zipCode;	/* optional element of type xsd:string */
	std::string *country;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__UpdatePaymentCardResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UpdatePaymentCardResp(): minorErrorCode(NULL), startDate(NULL), address2(NULL), address3(NULL), address4(NULL), zipCode(NULL), country(NULL) { ns1__UpdatePaymentCardResp::soap_default(NULL); }
	virtual ~ns1__UpdatePaymentCardResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetPaymentCardResp
#define SOAP_TYPE_ns1__GetPaymentCardResp (69)
/* ns1:GetPaymentCardResp */
class SOAP_CMAC ns1__GetPaymentCardResp : public ns1__APIResponse
{
public:
	enum ns1__GetPaymentCardErrorEnum errorCode;	/* required element of type ns1:GetPaymentCardErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns1__ArrayOfPaymentCard *paymentCardItems;	/* optional element of type ns1:ArrayOfPaymentCard */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns1__GetPaymentCardResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetPaymentCardResp(): minorErrorCode(NULL), paymentCardItems(NULL) { ns1__GetPaymentCardResp::soap_default(NULL); }
	virtual ~ns1__GetPaymentCardResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__WithdrawToPaymentCardResp
#define SOAP_TYPE_ns1__WithdrawToPaymentCardResp (72)
/* ns1:WithdrawToPaymentCardResp */
class SOAP_CMAC ns1__WithdrawToPaymentCardResp : public ns1__APIResponse
{
public:
	double amountWithdrawn;	/* required element of type xsd:double */
	enum ns1__PaymentsErrorEnum errorCode;	/* required element of type ns1:PaymentsErrorEnum */
	double maxAmount;	/* required element of type xsd:double */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns1__WithdrawToPaymentCardResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__WithdrawToPaymentCardResp(): minorErrorCode(NULL) { ns1__WithdrawToPaymentCardResp::soap_default(NULL); }
	virtual ~ns1__WithdrawToPaymentCardResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__WithdrawToPaymentCardReq
#define SOAP_TYPE_ns1__WithdrawToPaymentCardReq (73)
/* ns1:WithdrawToPaymentCardReq */
class SOAP_CMAC ns1__WithdrawToPaymentCardReq : public ns1__APIRequest
{
public:
	double amount;	/* required element of type xsd:double */
	std::string *cardIdentifier;	/* optional element of type xsd:string */
	std::string *password;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns1__WithdrawToPaymentCardReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__WithdrawToPaymentCardReq(): cardIdentifier(NULL), password(NULL) { ns1__WithdrawToPaymentCardReq::soap_default(NULL); }
	virtual ~ns1__WithdrawToPaymentCardReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__WithdrawByBankTransferReq
#define SOAP_TYPE_ns1__WithdrawByBankTransferReq (74)
/* ns1:WithdrawByBankTransferReq */
class SOAP_CMAC ns1__WithdrawByBankTransferReq : public ns1__APIRequest
{
public:
	enum ns1__WithdrawByBankTransferModeEnum mode;	/* required element of type ns1:WithdrawByBankTransferModeEnum */
	double amount;	/* required element of type xsd:double */
	class ns1__BankAccountDetails *bankAccountDetails;	/* required element of type ns1:BankAccountDetails */
	bool expressTransfer;	/* required element of type xsd:boolean */
	std::string *password;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns1__WithdrawByBankTransferReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__WithdrawByBankTransferReq(): bankAccountDetails(NULL), password(NULL) { ns1__WithdrawByBankTransferReq::soap_default(NULL); }
	virtual ~ns1__WithdrawByBankTransferReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__WithdrawByBankTransferResp
#define SOAP_TYPE_ns1__WithdrawByBankTransferResp (75)
/* ns1:WithdrawByBankTransferResp */
class SOAP_CMAC ns1__WithdrawByBankTransferResp : public ns1__APIResponse
{
public:
	enum ns1__PaymentsErrorEnum errorCode;	/* required element of type ns1:PaymentsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	double amountWithdrawn;	/* required element of type xsd:double */
	double minAmount;	/* required element of type xsd:double */
	double maxAmount;	/* required element of type xsd:double */
	double *amountAvailable;	/* optional element of type xsd:double */
	double *transferFee;	/* optional element of type xsd:double */
	double *expressTransferFee;	/* optional element of type xsd:double */
	bool *expressTransferAvailable;	/* optional element of type xsd:boolean */
	ns1__BankAccountDetails *lastBankAccountDetails;	/* optional element of type ns1:BankAccountDetails */
	ns1__ArrayOfBankAccountDetailsField *requiredBankAccountDetailsFields;	/* optional element of type ns1:ArrayOfBankAccountDetailsField */
	std::string *transactionId;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ns1__WithdrawByBankTransferResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__WithdrawByBankTransferResp(): minorErrorCode(NULL), amountAvailable(NULL), transferFee(NULL), expressTransferFee(NULL), expressTransferAvailable(NULL), lastBankAccountDetails(NULL), requiredBankAccountDetailsFields(NULL), transactionId(NULL) { ns1__WithdrawByBankTransferResp::soap_default(NULL); }
	virtual ~ns1__WithdrawByBankTransferResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BankAccountDetailsField
#define SOAP_TYPE_ns1__BankAccountDetailsField (77)
/* ns1:BankAccountDetailsField */
class SOAP_CMAC ns1__BankAccountDetailsField : public ns1__AbstractField
{
public:
	enum ns1__BankAccountDetailsFieldEnum type;	/* required element of type ns1:BankAccountDetailsFieldEnum */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns1__BankAccountDetailsField */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BankAccountDetailsField() { ns1__BankAccountDetailsField::soap_default(NULL); }
	virtual ~ns1__BankAccountDetailsField() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BankAccountDetails
#define SOAP_TYPE_ns1__BankAccountDetails (80)
/* ns1:BankAccountDetails */
class SOAP_CMAC ns1__BankAccountDetails : public ns1__BasicBankAccountDetails
{
public:
	std::string *payee;	/* optional element of type xsd:string */
	enum ns1__BankAccountTypeEnum accountType;	/* required element of type ns1:BankAccountTypeEnum */
	std::string *bankKey;	/* optional element of type xsd:string */
	std::string *routing;	/* optional element of type xsd:string */
	std::string *abiCab;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns1__BankAccountDetails */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BankAccountDetails(): payee(NULL), bankKey(NULL), routing(NULL), abiCab(NULL) { ns1__BankAccountDetails::soap_default(NULL); }
	virtual ~ns1__BankAccountDetails() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TransferFundsReq
#define SOAP_TYPE_ns1__TransferFundsReq (81)
/* ns1:TransferFundsReq */
class SOAP_CMAC ns1__TransferFundsReq : public ns1__APIRequest
{
public:
	int sourceWalletId;	/* required element of type xsd:int */
	int targetWalletId;	/* required element of type xsd:int */
	double amount;	/* required element of type xsd:double */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns1__TransferFundsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TransferFundsReq() { ns1__TransferFundsReq::soap_default(NULL); }
	virtual ~ns1__TransferFundsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TransferFundsResp
#define SOAP_TYPE_ns1__TransferFundsResp (82)
/* ns1:TransferFundsResp */
class SOAP_CMAC ns1__TransferFundsResp : public ns1__APIResponse
{
public:
	enum ns1__TransferFundsErrorEnum errorCode;	/* required element of type ns1:TransferFundsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	double *monthlyDepositTotal;	/* optional element of type xsd:double */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ns1__TransferFundsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TransferFundsResp(): minorErrorCode(NULL), monthlyDepositTotal(NULL) { ns1__TransferFundsResp::soap_default(NULL); }
	virtual ~ns1__TransferFundsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SelfExcludeReq
#define SOAP_TYPE_ns1__SelfExcludeReq (83)
/* ns1:SelfExcludeReq */
class SOAP_CMAC ns1__SelfExcludeReq : public ns1__APIRequest
{
public:
	bool selfExclude;	/* required element of type xsd:boolean */
	std::string *password;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns1__SelfExcludeReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SelfExcludeReq(): password(NULL) { ns1__SelfExcludeReq::soap_default(NULL); }
	virtual ~ns1__SelfExcludeReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SelfExcludeResp
#define SOAP_TYPE_ns1__SelfExcludeResp (84)
/* ns1:SelfExcludeResp */
class SOAP_CMAC ns1__SelfExcludeResp : public ns1__APIResponse
{
public:
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	enum ns1__SelfExcludeErrorEnum errorCode;	/* required element of type ns1:SelfExcludeErrorEnum */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ns1__SelfExcludeResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SelfExcludeResp(): minorErrorCode(NULL) { ns1__SelfExcludeResp::soap_default(NULL); }
	virtual ~ns1__SelfExcludeResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ConvertCurrencyResp
#define SOAP_TYPE_ns1__ConvertCurrencyResp (85)
/* ns1:ConvertCurrencyResp */
class SOAP_CMAC ns1__ConvertCurrencyResp : public ns1__APIResponse
{
public:
	double convertedAmount;	/* required element of type xsd:double */
	enum ns1__ConvertCurrencyErrorEnum errorCode;	/* required element of type ns1:ConvertCurrencyErrorEnum */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns1__ConvertCurrencyResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ConvertCurrencyResp() { ns1__ConvertCurrencyResp::soap_default(NULL); }
	virtual ~ns1__ConvertCurrencyResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ConvertCurrencyReq
#define SOAP_TYPE_ns1__ConvertCurrencyReq (86)
/* ns1:ConvertCurrencyReq */
class SOAP_CMAC ns1__ConvertCurrencyReq : public ns1__APIRequest
{
public:
	double amount;	/* required element of type xsd:double */
	std::string *fromCurrency;	/* optional element of type xsd:string */
	std::string *toCurrency;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ns1__ConvertCurrencyReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ConvertCurrencyReq(): fromCurrency(NULL), toCurrency(NULL) { ns1__ConvertCurrencyReq::soap_default(NULL); }
	virtual ~ns1__ConvertCurrencyReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetCurrenciesResp
#define SOAP_TYPE_ns1__GetCurrenciesResp (87)
/* ns1:GetCurrenciesResp */
class SOAP_CMAC ns1__GetCurrenciesResp : public ns1__APIResponse
{
public:
	ns1__ArrayOfCurrency *currencyItems;	/* optional element of type ns1:ArrayOfCurrency */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ns1__GetCurrenciesResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetCurrenciesResp(): currencyItems(NULL) { ns1__GetCurrenciesResp::soap_default(NULL); }
	virtual ~ns1__GetCurrenciesResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetCurrenciesReq
#define SOAP_TYPE_ns1__GetCurrenciesReq (90)
/* ns1:GetCurrenciesReq */
class SOAP_CMAC ns1__GetCurrenciesReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ns1__GetCurrenciesReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetCurrenciesReq() { ns1__GetCurrenciesReq::soap_default(NULL); }
	virtual ~ns1__GetCurrenciesReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetCurrenciesV2Resp
#define SOAP_TYPE_ns1__GetCurrenciesV2Resp (91)
/* ns1:GetCurrenciesV2Resp */
class SOAP_CMAC ns1__GetCurrenciesV2Resp : public ns1__APIResponse
{
public:
	ns1__ArrayOfCurrencyV2 *currencyItems;	/* optional element of type ns1:ArrayOfCurrencyV2 */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ns1__GetCurrenciesV2Resp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetCurrenciesV2Resp(): currencyItems(NULL) { ns1__GetCurrenciesV2Resp::soap_default(NULL); }
	virtual ~ns1__GetCurrenciesV2Resp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CurrencyV2
#define SOAP_TYPE_ns1__CurrencyV2 (92)
/* ns1:CurrencyV2 */
class SOAP_CMAC ns1__CurrencyV2 : public ns1__Currency
{
public:
	double *minimumStake;	/* optional element of type xsd:double */
	double *minimumRangeStake;	/* optional element of type xsd:double */
	double *minimumBSPLayLiability;	/* optional element of type xsd:double */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns1__CurrencyV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CurrencyV2(): minimumStake(NULL), minimumRangeStake(NULL), minimumBSPLayLiability(NULL) { ns1__CurrencyV2::soap_default(NULL); }
	virtual ~ns1__CurrencyV2() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GetCurrenciesV2Req
#define SOAP_TYPE_ns1__GetCurrenciesV2Req (94)
/* ns1:GetCurrenciesV2Req */
class SOAP_CMAC ns1__GetCurrenciesV2Req : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns1__GetCurrenciesV2Req */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GetCurrenciesV2Req() { ns1__GetCurrenciesV2Req::soap_default(NULL); }
	virtual ~ns1__GetCurrenciesV2Req() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ViewReferAndEarnReq
#define SOAP_TYPE_ns1__ViewReferAndEarnReq (95)
/* ns1:ViewReferAndEarnReq */
class SOAP_CMAC ns1__ViewReferAndEarnReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns1__ViewReferAndEarnReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ViewReferAndEarnReq() { ns1__ViewReferAndEarnReq::soap_default(NULL); }
	virtual ~ns1__ViewReferAndEarnReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ViewReferAndEarnResp
#define SOAP_TYPE_ns1__ViewReferAndEarnResp (96)
/* ns1:ViewReferAndEarnResp */
class SOAP_CMAC ns1__ViewReferAndEarnResp : public ns1__APIResponse
{
public:
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	enum ns1__ViewReferAndEarnErrorEnum errorCode;	/* required element of type ns1:ViewReferAndEarnErrorEnum */
	std::string *referAndEarnCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns1__ViewReferAndEarnResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ViewReferAndEarnResp(): minorErrorCode(NULL), referAndEarnCode(NULL) { ns1__ViewReferAndEarnResp::soap_default(NULL); }
	virtual ~ns1__ViewReferAndEarnResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ViewProfileReq
#define SOAP_TYPE_ns1__ViewProfileReq (97)
/* ns1:ViewProfileReq */
class SOAP_CMAC ns1__ViewProfileReq : public ns1__APIRequest
{
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns1__ViewProfileReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ViewProfileReq() { ns1__ViewProfileReq::soap_default(NULL); }
	virtual ~ns1__ViewProfileReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ViewProfileResp
#define SOAP_TYPE_ns1__ViewProfileResp (98)
/* ns1:ViewProfileResp */
class SOAP_CMAC ns1__ViewProfileResp : public ns1__APIResponse
{
public:
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	enum ns1__ViewProfileErrorEnum errorCode;	/* required element of type ns1:ViewProfileErrorEnum */
	enum ns1__TitleEnum title;	/* required element of type ns1:TitleEnum */
	std::string *firstName;	/* optional element of type xsd:string */
	std::string *surname;	/* optional element of type xsd:string */
	std::string *userName;	/* optional element of type xsd:string */
	std::string *forumName;	/* optional element of type xsd:string */
	std::string *address1;	/* optional element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string *townCity;	/* optional element of type xsd:string */
	std::string *countyState;	/* optional element of type xsd:string */
	std::string *postCode;	/* optional element of type xsd:string */
	std::string *countryOfResidence;	/* optional element of type xsd:string */
	std::string *homeTelephone;	/* optional element of type xsd:string */
	std::string *workTelephone;	/* optional element of type xsd:string */
	std::string *mobileTelephone;	/* optional element of type xsd:string */
	std::string *emailAddress;	/* optional element of type xsd:string */
	std::string *timeZone;	/* optional element of type xsd:string */
	std::string *currency;	/* optional element of type xsd:string */
	int *gamcareLimit;	/* optional element of type xsd:int */
	enum ns1__GamcareLimitFreqEnum gamcareFrequency;	/* required element of type ns1:GamcareLimitFreqEnum */
	int *gamcareLossLimit;	/* optional element of type xsd:int */
	enum ns1__GamcareLimitFreqEnum gamcareLossLimitFrequency;	/* required element of type ns1:GamcareLimitFreqEnum */
	time_t gamcareUpdateDate;	/* required element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns1__ViewProfileResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ViewProfileResp(): minorErrorCode(NULL), firstName(NULL), surname(NULL), userName(NULL), forumName(NULL), address1(NULL), address2(NULL), address3(NULL), townCity(NULL), countyState(NULL), postCode(NULL), countryOfResidence(NULL), homeTelephone(NULL), workTelephone(NULL), mobileTelephone(NULL), emailAddress(NULL), timeZone(NULL), currency(NULL), gamcareLimit(NULL), gamcareLossLimit(NULL) { ns1__ViewProfileResp::soap_default(NULL); }
	virtual ~ns1__ViewProfileResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ViewProfileV2Req
#define SOAP_TYPE_ns1__ViewProfileV2Req (99)
/* ns1:ViewProfileV2Req */
class SOAP_CMAC ns1__ViewProfileV2Req : public ns1__APIRequest
{
public:
	enum ns1__ViewProfileV2ReqVersionEnum *requestVersion;	/* optional element of type ns1:ViewProfileV2ReqVersionEnum */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns1__ViewProfileV2Req */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ViewProfileV2Req(): requestVersion(NULL) { ns1__ViewProfileV2Req::soap_default(NULL); }
	virtual ~ns1__ViewProfileV2Req() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ModifyProfileReq
#define SOAP_TYPE_ns1__ModifyProfileReq (101)
/* ns1:ModifyProfileReq */
class SOAP_CMAC ns1__ModifyProfileReq : public ns1__APIRequest
{
public:
	std::string password;	/* required element of type xsd:string */
	std::string *address1;	/* optional element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string *townCity;	/* optional element of type xsd:string */
	std::string *countyState;	/* optional element of type xsd:string */
	std::string *postCode;	/* optional element of type xsd:string */
	std::string *countryOfResidence;	/* optional element of type xsd:string */
	std::string *homeTelephone;	/* optional element of type xsd:string */
	std::string *workTelephone;	/* optional element of type xsd:string */
	std::string *mobileTelephone;	/* optional element of type xsd:string */
	std::string *emailAddress;	/* optional element of type xsd:string */
	std::string *timeZone;	/* optional element of type xsd:string */
	int *depositLimit;	/* optional element of type xsd:int */
	enum ns1__GamcareLimitFreqEnum *depositLimitFrequency;	/* optional element of type ns1:GamcareLimitFreqEnum */
	int *lossLimit;	/* optional element of type xsd:int */
	enum ns1__GamcareLimitFreqEnum *lossLimitFrequency;	/* optional element of type ns1:GamcareLimitFreqEnum */
	std::string *nationalIdentifier;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns1__ModifyProfileReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ModifyProfileReq(): address1(NULL), address2(NULL), address3(NULL), townCity(NULL), countyState(NULL), postCode(NULL), countryOfResidence(NULL), homeTelephone(NULL), workTelephone(NULL), mobileTelephone(NULL), emailAddress(NULL), timeZone(NULL), depositLimit(NULL), depositLimitFrequency(NULL), lossLimit(NULL), lossLimitFrequency(NULL), nationalIdentifier(NULL) { ns1__ModifyProfileReq::soap_default(NULL); }
	virtual ~ns1__ModifyProfileReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ModifyProfileResp
#define SOAP_TYPE_ns1__ModifyProfileResp (102)
/* ns1:ModifyProfileResp */
class SOAP_CMAC ns1__ModifyProfileResp : public ns1__APIResponse
{
public:
	enum ns1__ModifyProfileErrorEnum errorCode;	/* required element of type ns1:ModifyProfileErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns1__ArrayOfValidationErrorsEnum *validationErrors;	/* optional element of type ns1:ArrayOfValidationErrorsEnum */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns1__ModifyProfileResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ModifyProfileResp(): minorErrorCode(NULL), validationErrors(NULL) { ns1__ModifyProfileResp::soap_default(NULL); }
	virtual ~ns1__ModifyProfileResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CreateAccountResp
#define SOAP_TYPE_ns1__CreateAccountResp (103)
/* ns1:CreateAccountResp */
class SOAP_CMAC ns1__CreateAccountResp : public ns1__APIResponse
{
public:
	int accountId;	/* required element of type xsd:int */
	enum ns1__AccountStatusEnum accountStatus;	/* required element of type ns1:AccountStatusEnum */
	enum ns1__CreateAccountErrorEnum errorCode;	/* required element of type ns1:CreateAccountErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	std::string *tan;	/* optional element of type xsd:string */
	int userId;	/* required element of type xsd:int */
	ns1__ArrayOfValidationErrorsEnum *validationErrors;	/* optional element of type ns1:ArrayOfValidationErrorsEnum */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns1__CreateAccountResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CreateAccountResp(): minorErrorCode(NULL), tan(NULL), validationErrors(NULL) { ns1__CreateAccountResp::soap_default(NULL); }
	virtual ~ns1__CreateAccountResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CreateAccountReq
#define SOAP_TYPE_ns1__CreateAccountReq (105)
/* ns1:CreateAccountReq */
class SOAP_CMAC ns1__CreateAccountReq : public ns1__APIRequest
{
public:
	int acceptedPrivicyPolicyVersion;	/* required element of type xsd:int */
	int acceptedTermsAndConditionsVersion;	/* required element of type xsd:int */
	enum ns1__AccountTypeEnum accountType;	/* required element of type ns1:AccountTypeEnum */
	std::string address1;	/* required element of type xsd:string */
	std::string *address2;	/* optional element of type xsd:string */
	std::string *address3;	/* optional element of type xsd:string */
	std::string answer1;	/* required element of type xsd:string */
	std::string answer2;	/* required element of type xsd:string */
	std::string *browser;	/* optional element of type xsd:string */
	std::string *countryOfResidence;	/* optional element of type xsd:string */
	std::string *countyState;	/* optional element of type xsd:string */
	std::string *currency;	/* optional element of type xsd:string */
	time_t dateOfBirth;	/* required element of type xsd:dateTime */
	double depositLimit;	/* required element of type xsd:double */
	enum ns1__GamcareLimitFreqEnum depositLimitFrequency;	/* required element of type ns1:GamcareLimitFreqEnum */
	std::string emailAddress;	/* required element of type xsd:string */
	std::string firstName;	/* required element of type xsd:string */
	enum ns1__GenderEnum gender;	/* required element of type ns1:GenderEnum */
	std::string homeTelephone;	/* required element of type xsd:string */
	bool informProductsServices;	/* required element of type xsd:boolean */
	bool informSpecialOffers;	/* required element of type xsd:boolean */
	std::string ipAddress;	/* required element of type xsd:string */
	std::string *locale;	/* optional element of type xsd:string */
	double lossLimit;	/* required element of type xsd:double */
	enum ns1__GamcareLimitFreqEnum lossLimitFrequency;	/* required element of type ns1:GamcareLimitFreqEnum */
	bool manualAddress;	/* required element of type xsd:boolean */
	std::string mobileTelephone;	/* required element of type xsd:string */
	int partnerId;	/* required element of type xsd:int */
	std::string *password;	/* optional element of type xsd:string */
	std::string *postCode;	/* optional element of type xsd:string */
	std::string *preferredName;	/* optional element of type xsd:string */
	int productId;	/* required element of type xsd:int */
	enum ns1__SecurityQuestion1Enum question1;	/* required element of type ns1:SecurityQuestion1Enum */
	enum ns1__SecurityQuestion2Enum question2;	/* required element of type ns1:SecurityQuestion2Enum */
	std::string *referrerCode;	/* optional element of type xsd:string */
	enum ns1__RegionEnum region;	/* required element of type ns1:RegionEnum */
	int subPartnerId;	/* required element of type xsd:int */
	int superPartnerId;	/* required element of type xsd:int */
	std::string surname;	/* required element of type xsd:string */
	std::string *timeZone;	/* optional element of type xsd:string */
	enum ns1__TitleEnum title;	/* required element of type ns1:TitleEnum */
	std::string townCity;	/* required element of type xsd:string */
	std::string *username;	/* optional element of type xsd:string */
	std::string *workTelephone;	/* optional element of type xsd:string */
	std::string *nationalIdentifier;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns1__CreateAccountReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CreateAccountReq(): address2(NULL), address3(NULL), browser(NULL), countryOfResidence(NULL), countyState(NULL), currency(NULL), locale(NULL), password(NULL), postCode(NULL), preferredName(NULL), referrerCode(NULL), timeZone(NULL), username(NULL), workTelephone(NULL), nationalIdentifier(NULL) { ns1__CreateAccountReq::soap_default(NULL); }
	virtual ~ns1__CreateAccountReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ForgotPasswordReq
#define SOAP_TYPE_ns1__ForgotPasswordReq (106)
/* ns1:ForgotPasswordReq */
class SOAP_CMAC ns1__ForgotPasswordReq : public ns1__APIRequest
{
public:
	std::string username;	/* required element of type xsd:string */
	std::string emailAddress;	/* required element of type xsd:string */
	std::string countryOfResidence;	/* required element of type xsd:string */
	std::string *forgottenPasswordAnswer1;	/* optional element of type xsd:string */
	std::string *forgottenPasswordAnswer2;	/* optional element of type xsd:string */
	std::string *newPassword;	/* optional element of type xsd:string */
	std::string *newPasswordRepeat;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns1__ForgotPasswordReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ForgotPasswordReq(): forgottenPasswordAnswer1(NULL), forgottenPasswordAnswer2(NULL), newPassword(NULL), newPasswordRepeat(NULL) { ns1__ForgotPasswordReq::soap_default(NULL); }
	virtual ~ns1__ForgotPasswordReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ForgotPasswordResp
#define SOAP_TYPE_ns1__ForgotPasswordResp (107)
/* ns1:ForgotPasswordResp */
class SOAP_CMAC ns1__ForgotPasswordResp : public ns1__APIResponse
{
public:
	enum ns1__ForgotPasswordErrorEnum errorCode;	/* required element of type ns1:ForgotPasswordErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	std::string *question1;	/* optional element of type xsd:string */
	std::string *question2;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns1__ForgotPasswordResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ForgotPasswordResp(): minorErrorCode(NULL), question1(NULL), question2(NULL) { ns1__ForgotPasswordResp::soap_default(NULL); }
	virtual ~ns1__ForgotPasswordResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ModifyPasswordReq
#define SOAP_TYPE_ns1__ModifyPasswordReq (108)
/* ns1:ModifyPasswordReq */
class SOAP_CMAC ns1__ModifyPasswordReq : public ns1__APIRequest
{
public:
	std::string password;	/* required element of type xsd:string */
	std::string newPassword;	/* required element of type xsd:string */
	std::string newPasswordRepeat;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns1__ModifyPasswordReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ModifyPasswordReq() { ns1__ModifyPasswordReq::soap_default(NULL); }
	virtual ~ns1__ModifyPasswordReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ModifyPasswordResp
#define SOAP_TYPE_ns1__ModifyPasswordResp (109)
/* ns1:ModifyPasswordResp */
class SOAP_CMAC ns1__ModifyPasswordResp : public ns1__APIResponse
{
public:
	enum ns1__ModifyPasswordErrorEnum errorCode;	/* required element of type ns1:ModifyPasswordErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns1__ModifyPasswordResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ModifyPasswordResp(): minorErrorCode(NULL) { ns1__ModifyPasswordResp::soap_default(NULL); }
	virtual ~ns1__ModifyPasswordResp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SetChatNameReq
#define SOAP_TYPE_ns1__SetChatNameReq (110)
/* ns1:SetChatNameReq */
class SOAP_CMAC ns1__SetChatNameReq : public ns1__APIRequest
{
public:
	std::string password;	/* required element of type xsd:string */
	std::string chatName;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns1__SetChatNameReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SetChatNameReq() { ns1__SetChatNameReq::soap_default(NULL); }
	virtual ~ns1__SetChatNameReq() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SetChatNameResp
#define SOAP_TYPE_ns1__SetChatNameResp (111)
/* ns1:SetChatNameResp */
class SOAP_CMAC ns1__SetChatNameResp : public ns1__APIResponse
{
public:
	enum ns1__SetChatNameErrorEnum errorCode;	/* required element of type ns1:SetChatNameErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns1__SetChatNameResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SetChatNameResp(): minorErrorCode(NULL) { ns1__SetChatNameResp::soap_default(NULL); }
	virtual ~ns1__SetChatNameResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetAccountFundsResp
#define SOAP_TYPE_ns3__GetAccountFundsResp (174)
/* ns3:GetAccountFundsResp */
class SOAP_CMAC ns3__GetAccountFundsResp : public ns3__APIResponse
{
public:
	double availBalance;	/* required element of type xsd:double */
	double balance;	/* required element of type xsd:double */
	double commissionRetain;	/* required element of type xsd:double */
	double creditLimit;	/* required element of type xsd:double */
	int currentBetfairPoints;	/* required element of type xsd:int */
	double expoLimit;	/* required element of type xsd:double */
	double exposure;	/* required element of type xsd:double */
	int holidaysAvailable;	/* required element of type xsd:int */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	double nextDiscount;	/* required element of type xsd:double */
	double withdrawBalance;	/* required element of type xsd:double */
	enum ns3__GetAccountFundsErrorEnum errorCode;	/* required element of type ns3:GetAccountFundsErrorEnum */
public:
	virtual int soap_type() const { return 174; } /* = unique id SOAP_TYPE_ns3__GetAccountFundsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetAccountFundsResp(): minorErrorCode(NULL) { ns3__GetAccountFundsResp::soap_default(NULL); }
	virtual ~ns3__GetAccountFundsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetAccountFundsReq
#define SOAP_TYPE_ns3__GetAccountFundsReq (175)
/* ns3:GetAccountFundsReq */
class SOAP_CMAC ns3__GetAccountFundsReq : public ns3__APIRequest
{
public:
	virtual int soap_type() const { return 175; } /* = unique id SOAP_TYPE_ns3__GetAccountFundsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetAccountFundsReq() { ns3__GetAccountFundsReq::soap_default(NULL); }
	virtual ~ns3__GetAccountFundsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetSilksResp
#define SOAP_TYPE_ns3__GetSilksResp (176)
/* ns3:GetSilksResp */
class SOAP_CMAC ns3__GetSilksResp : public ns3__APIResponse
{
public:
	enum ns3__GetSilksErrorEnum errorCode;	/* required element of type ns3:GetSilksErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns3__ArrayOfMarketDisplayDetail *marketDisplayDetails;	/* optional element of type ns3:ArrayOfMarketDisplayDetail */
public:
	virtual int soap_type() const { return 176; } /* = unique id SOAP_TYPE_ns3__GetSilksResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetSilksResp(): minorErrorCode(NULL), marketDisplayDetails(NULL) { ns3__GetSilksResp::soap_default(NULL); }
	virtual ~ns3__GetSilksResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetSilksReq
#define SOAP_TYPE_ns3__GetSilksReq (181)
/* ns3:GetSilksReq */
class SOAP_CMAC ns3__GetSilksReq : public ns3__APIRequest
{
public:
	std::string *locale;	/* optional element of type xsd:string */
	ns3__ArrayOfInt *markets;	/* optional element of type ns3:ArrayOfInt */
public:
	virtual int soap_type() const { return 181; } /* = unique id SOAP_TYPE_ns3__GetSilksReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetSilksReq(): locale(NULL), markets(NULL) { ns3__GetSilksReq::soap_default(NULL); }
	virtual ~ns3__GetSilksReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetSilksV2Resp
#define SOAP_TYPE_ns3__GetSilksV2Resp (182)
/* ns3:GetSilksV2Resp */
class SOAP_CMAC ns3__GetSilksV2Resp : public ns3__APIResponse
{
public:
	enum ns3__GetSilksErrorEnum errorCode;	/* required element of type ns3:GetSilksErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns3__ArrayOfMarketDisplayDetailV2 *marketDisplayDetails;	/* optional element of type ns3:ArrayOfMarketDisplayDetailV2 */
public:
	virtual int soap_type() const { return 182; } /* = unique id SOAP_TYPE_ns3__GetSilksV2Resp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetSilksV2Resp(): minorErrorCode(NULL), marketDisplayDetails(NULL) { ns3__GetSilksV2Resp::soap_default(NULL); }
	virtual ~ns3__GetSilksV2Resp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__RacingSilkV2
#define SOAP_TYPE_ns3__RacingSilkV2 (186)
/* ns3:RacingSilkV2 */
class SOAP_CMAC ns3__RacingSilkV2 : public ns3__RacingSilk
{
public:
	std::string *ownerName;	/* optional element of type xsd:string */
	std::string *jockeyName;	/* optional element of type xsd:string */
	std::string *colour;	/* optional element of type xsd:string */
	std::string *sex;	/* optional element of type xsd:string */
	std::string *bred;	/* optional element of type xsd:string */
	int forecastPriceNumerator;	/* required element of type xsd:int */
	int forecastPriceDenominator;	/* required element of type xsd:int */
	int officialRating;	/* required element of type xsd:int */
	ns3__Breeding *sire;	/* optional element of type ns3:Breeding */
	ns3__Breeding *dam;	/* optional element of type ns3:Breeding */
	ns3__Breeding *damSire;	/* optional element of type ns3:Breeding */
public:
	virtual int soap_type() const { return 186; } /* = unique id SOAP_TYPE_ns3__RacingSilkV2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__RacingSilkV2(): ownerName(NULL), jockeyName(NULL), colour(NULL), sex(NULL), bred(NULL), sire(NULL), dam(NULL), damSire(NULL) { ns3__RacingSilkV2::soap_default(NULL); }
	virtual ~ns3__RacingSilkV2() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsResp
#define SOAP_TYPE_ns3__CancelBetsResp (189)
/* ns3:CancelBetsResp */
class SOAP_CMAC ns3__CancelBetsResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfCancelBetsResult *betResults;	/* optional element of type ns3:ArrayOfCancelBetsResult */
	enum ns3__CancelBetsErrorEnum errorCode;	/* required element of type ns3:CancelBetsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 189; } /* = unique id SOAP_TYPE_ns3__CancelBetsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CancelBetsResp(): betResults(NULL), minorErrorCode(NULL) { ns3__CancelBetsResp::soap_default(NULL); }
	virtual ~ns3__CancelBetsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsReq
#define SOAP_TYPE_ns3__CancelBetsReq (192)
/* ns3:CancelBetsReq */
class SOAP_CMAC ns3__CancelBetsReq : public ns3__APIRequest
{
public:
	ns3__ArrayOfCancelBets *bets;	/* optional element of type ns3:ArrayOfCancelBets */
public:
	virtual int soap_type() const { return 192; } /* = unique id SOAP_TYPE_ns3__CancelBetsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CancelBetsReq(): bets(NULL) { ns3__CancelBetsReq::soap_default(NULL); }
	virtual ~ns3__CancelBetsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsByMarketReq
#define SOAP_TYPE_ns3__CancelBetsByMarketReq (195)
/* ns3:CancelBetsByMarketReq */
class SOAP_CMAC ns3__CancelBetsByMarketReq : public ns3__APIRequest
{
public:
	ns3__ArrayOfInt *markets;	/* optional element of type ns3:ArrayOfInt */
public:
	virtual int soap_type() const { return 195; } /* = unique id SOAP_TYPE_ns3__CancelBetsByMarketReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CancelBetsByMarketReq(): markets(NULL) { ns3__CancelBetsByMarketReq::soap_default(NULL); }
	virtual ~ns3__CancelBetsByMarketReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__CancelBetsByMarketResp
#define SOAP_TYPE_ns3__CancelBetsByMarketResp (196)
/* ns3:CancelBetsByMarketResp */
class SOAP_CMAC ns3__CancelBetsByMarketResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfCancelBetsByMarketResult *results;	/* optional element of type ns3:ArrayOfCancelBetsByMarketResult */
	enum ns3__CancelBetsByMarketErrorEnum errorCode;	/* required element of type ns3:CancelBetsByMarketErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 196; } /* = unique id SOAP_TYPE_ns3__CancelBetsByMarketResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__CancelBetsByMarketResp(): results(NULL), minorErrorCode(NULL) { ns3__CancelBetsByMarketResp::soap_default(NULL); }
	virtual ~ns3__CancelBetsByMarketResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UpdateBetsResp
#define SOAP_TYPE_ns3__UpdateBetsResp (199)
/* ns3:UpdateBetsResp */
class SOAP_CMAC ns3__UpdateBetsResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfUpdateBetsResult *betResults;	/* optional element of type ns3:ArrayOfUpdateBetsResult */
	enum ns3__UpdateBetsErrorEnum errorCode;	/* required element of type ns3:UpdateBetsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 199; } /* = unique id SOAP_TYPE_ns3__UpdateBetsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UpdateBetsResp(): betResults(NULL), minorErrorCode(NULL) { ns3__UpdateBetsResp::soap_default(NULL); }
	virtual ~ns3__UpdateBetsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UpdateBetsReq
#define SOAP_TYPE_ns3__UpdateBetsReq (202)
/* ns3:UpdateBetsReq */
class SOAP_CMAC ns3__UpdateBetsReq : public ns3__APIRequest
{
public:
	ns3__ArrayOfUpdateBets *bets;	/* optional element of type ns3:ArrayOfUpdateBets */
public:
	virtual int soap_type() const { return 202; } /* = unique id SOAP_TYPE_ns3__UpdateBetsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UpdateBetsReq(): bets(NULL) { ns3__UpdateBetsReq::soap_default(NULL); }
	virtual ~ns3__UpdateBetsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__PlaceBetsResp
#define SOAP_TYPE_ns3__PlaceBetsResp (205)
/* ns3:PlaceBetsResp */
class SOAP_CMAC ns3__PlaceBetsResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfPlaceBetsResult *betResults;	/* optional element of type ns3:ArrayOfPlaceBetsResult */
	enum ns3__PlaceBetsErrorEnum errorCode;	/* required element of type ns3:PlaceBetsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 205; } /* = unique id SOAP_TYPE_ns3__PlaceBetsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__PlaceBetsResp(): betResults(NULL), minorErrorCode(NULL) { ns3__PlaceBetsResp::soap_default(NULL); }
	virtual ~ns3__PlaceBetsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__PlaceBetsReq
#define SOAP_TYPE_ns3__PlaceBetsReq (208)
/* ns3:PlaceBetsReq */
class SOAP_CMAC ns3__PlaceBetsReq : public ns3__APIRequest
{
public:
	ns3__ArrayOfPlaceBets *bets;	/* optional element of type ns3:ArrayOfPlaceBets */
public:
	virtual int soap_type() const { return 208; } /* = unique id SOAP_TYPE_ns3__PlaceBetsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__PlaceBetsReq(): bets(NULL) { ns3__PlaceBetsReq::soap_default(NULL); }
	virtual ~ns3__PlaceBetsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCouponResp
#define SOAP_TYPE_ns3__GetCouponResp (211)
/* ns3:GetCouponResp */
class SOAP_CMAC ns3__GetCouponResp : public ns3__APIResponse
{
public:
	int couponId;	/* required element of type xsd:int */
	std::string *couponName;	/* optional element of type xsd:string */
	ns3__ArrayOfCouponMarket *couponMarketItems;	/* optional element of type ns3:ArrayOfCouponMarket */
	int parentEventId;	/* required element of type xsd:int */
	enum ns3__GetCouponErrorEnum errorCode;	/* required element of type ns3:GetCouponErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 211; } /* = unique id SOAP_TYPE_ns3__GetCouponResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCouponResp(): couponName(NULL), couponMarketItems(NULL), minorErrorCode(NULL) { ns3__GetCouponResp::soap_default(NULL); }
	virtual ~ns3__GetCouponResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCouponReq
#define SOAP_TYPE_ns3__GetCouponReq (216)
/* ns3:GetCouponReq */
class SOAP_CMAC ns3__GetCouponReq : public ns3__APIRequest
{
public:
	int couponId;	/* required element of type xsd:int */
	std::string *locale;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 216; } /* = unique id SOAP_TYPE_ns3__GetCouponReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCouponReq(): locale(NULL) { ns3__GetCouponReq::soap_default(NULL); }
	virtual ~ns3__GetCouponReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__HeartbeatReq
#define SOAP_TYPE_ns3__HeartbeatReq (219)
/* ns3:HeartbeatReq */
class SOAP_CMAC ns3__HeartbeatReq : public ns3__APIRequest
{
public:
	int frequency;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 219; } /* = unique id SOAP_TYPE_ns3__HeartbeatReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__HeartbeatReq() { ns3__HeartbeatReq::soap_default(NULL); }
	virtual ~ns3__HeartbeatReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__HeartbeatResp
#define SOAP_TYPE_ns3__HeartbeatResp (220)
/* ns3:HeartbeatResp */
class SOAP_CMAC ns3__HeartbeatResp : public ns3__APIResponse
{
public:
	enum ns3__HeartbeatErrorEnum errorCode;	/* required element of type ns3:HeartbeatErrorEnum */
	int frequency;	/* required element of type xsd:int */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 220; } /* = unique id SOAP_TYPE_ns3__HeartbeatResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__HeartbeatResp(): minorErrorCode(NULL) { ns3__HeartbeatResp::soap_default(NULL); }
	virtual ~ns3__HeartbeatResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketResp
#define SOAP_TYPE_ns3__GetMarketResp (221)
/* ns3:GetMarketResp */
class SOAP_CMAC ns3__GetMarketResp : public ns3__APIResponse
{
public:
	enum ns3__GetMarketErrorEnum errorCode;	/* required element of type ns3:GetMarketErrorEnum */
	ns3__Market *market;	/* optional element of type ns3:Market */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 221; } /* = unique id SOAP_TYPE_ns3__GetMarketResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketResp(): market(NULL), minorErrorCode(NULL) { ns3__GetMarketResp::soap_default(NULL); }
	virtual ~ns3__GetMarketResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketReq
#define SOAP_TYPE_ns3__GetMarketReq (226)
/* ns3:GetMarketReq */
class SOAP_CMAC ns3__GetMarketReq : public ns3__APIRequest
{
public:
	std::string *locale;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
	bool includeCouponLinks;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 226; } /* = unique id SOAP_TYPE_ns3__GetMarketReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketReq(): locale(NULL) { ns3__GetMarketReq::soap_default(NULL); }
	virtual ~ns3__GetMarketReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketPricesResp
#define SOAP_TYPE_ns3__GetMarketPricesResp (227)
/* ns3:GetMarketPricesResp */
class SOAP_CMAC ns3__GetMarketPricesResp : public ns3__APIResponse
{
public:
	enum ns3__GetMarketPricesErrorEnum errorCode;	/* required element of type ns3:GetMarketPricesErrorEnum */
	ns3__MarketPrices *marketPrices;	/* optional element of type ns3:MarketPrices */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 227; } /* = unique id SOAP_TYPE_ns3__GetMarketPricesResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketPricesResp(): marketPrices(NULL), minorErrorCode(NULL) { ns3__GetMarketPricesResp::soap_default(NULL); }
	virtual ~ns3__GetMarketPricesResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketPricesReq
#define SOAP_TYPE_ns3__GetMarketPricesReq (233)
/* ns3:GetMarketPricesReq */
class SOAP_CMAC ns3__GetMarketPricesReq : public ns3__APIRequest
{
public:
	std::string *currencyCode;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 233; } /* = unique id SOAP_TYPE_ns3__GetMarketPricesReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketPricesReq(): currencyCode(NULL) { ns3__GetMarketPricesReq::soap_default(NULL); }
	virtual ~ns3__GetMarketPricesReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetAllMarketsResp
#define SOAP_TYPE_ns3__GetAllMarketsResp (234)
/* ns3:GetAllMarketsResp */
class SOAP_CMAC ns3__GetAllMarketsResp : public ns3__APIResponse
{
public:
	enum ns3__GetAllMarketsErrorEnum errorCode;	/* required element of type ns3:GetAllMarketsErrorEnum */
	std::string *marketData;	/* optional element of type xsd:string */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 234; } /* = unique id SOAP_TYPE_ns3__GetAllMarketsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetAllMarketsResp(): marketData(NULL), minorErrorCode(NULL) { ns3__GetAllMarketsResp::soap_default(NULL); }
	virtual ~ns3__GetAllMarketsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetAllMarketsReq
#define SOAP_TYPE_ns3__GetAllMarketsReq (235)
/* ns3:GetAllMarketsReq */
class SOAP_CMAC ns3__GetAllMarketsReq : public ns3__APIRequest
{
public:
	std::string *locale;	/* optional element of type xsd:string */
	ns3__ArrayOfInt *eventTypeIds;	/* optional element of type ns3:ArrayOfInt */
	ns3__ArrayOfCountryCode *countries;	/* optional element of type ns3:ArrayOfCountryCode */
	time_t *fromDate;	/* optional element of type xsd:dateTime */
	time_t *toDate;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 235; } /* = unique id SOAP_TYPE_ns3__GetAllMarketsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetAllMarketsReq(): locale(NULL), eventTypeIds(NULL), countries(NULL), fromDate(NULL), toDate(NULL) { ns3__GetAllMarketsReq::soap_default(NULL); }
	virtual ~ns3__GetAllMarketsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetInPlayMarketsResp
#define SOAP_TYPE_ns3__GetInPlayMarketsResp (237)
/* ns3:GetInPlayMarketsResp */
class SOAP_CMAC ns3__GetInPlayMarketsResp : public ns3__APIResponse
{
public:
	enum ns3__GetInPlayMarketsErrorEnum errorCode;	/* required element of type ns3:GetInPlayMarketsErrorEnum */
	std::string *marketData;	/* optional element of type xsd:string */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 237; } /* = unique id SOAP_TYPE_ns3__GetInPlayMarketsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetInPlayMarketsResp(): marketData(NULL), minorErrorCode(NULL) { ns3__GetInPlayMarketsResp::soap_default(NULL); }
	virtual ~ns3__GetInPlayMarketsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetInPlayMarketsReq
#define SOAP_TYPE_ns3__GetInPlayMarketsReq (238)
/* ns3:GetInPlayMarketsReq */
class SOAP_CMAC ns3__GetInPlayMarketsReq : public ns3__APIRequest
{
public:
	std::string *locale;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 238; } /* = unique id SOAP_TYPE_ns3__GetInPlayMarketsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetInPlayMarketsReq(): locale(NULL) { ns3__GetInPlayMarketsReq::soap_default(NULL); }
	virtual ~ns3__GetInPlayMarketsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetPrivateMarketsResp
#define SOAP_TYPE_ns3__GetPrivateMarketsResp (239)
/* ns3:GetPrivateMarketsResp */
class SOAP_CMAC ns3__GetPrivateMarketsResp : public ns3__APIResponse
{
public:
	enum ns3__GetPrivateMarketsErrorEnum errorCode;	/* required element of type ns3:GetPrivateMarketsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns3__ArrayOfPrivateMarket *privateMarkets;	/* optional element of type ns3:ArrayOfPrivateMarket */
	LONG64 lastRefresh;	/* required element of type xsd:long */
public:
	virtual int soap_type() const { return 239; } /* = unique id SOAP_TYPE_ns3__GetPrivateMarketsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetPrivateMarketsResp(): minorErrorCode(NULL), privateMarkets(NULL) { ns3__GetPrivateMarketsResp::soap_default(NULL); }
	virtual ~ns3__GetPrivateMarketsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetPrivateMarketsReq
#define SOAP_TYPE_ns3__GetPrivateMarketsReq (240)
/* ns3:GetPrivateMarketsReq */
class SOAP_CMAC ns3__GetPrivateMarketsReq : public ns3__APIRequest
{
public:
	std::string *locale;	/* optional element of type xsd:string */
	int eventTypeId;	/* required element of type xsd:int */
	enum ns3__MarketTypeEnum marketType;	/* required element of type ns3:MarketTypeEnum */
public:
	virtual int soap_type() const { return 240; } /* = unique id SOAP_TYPE_ns3__GetPrivateMarketsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetPrivateMarketsReq(): locale(NULL) { ns3__GetPrivateMarketsReq::soap_default(NULL); }
	virtual ~ns3__GetPrivateMarketsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCompleteMarketPricesCompressedResp
#define SOAP_TYPE_ns3__GetCompleteMarketPricesCompressedResp (243)
/* ns3:GetCompleteMarketPricesCompressedResp */
class SOAP_CMAC ns3__GetCompleteMarketPricesCompressedResp : public ns3__APIResponse
{
public:
	enum ns3__GetCompleteMarketPricesErrorEnum errorCode;	/* required element of type ns3:GetCompleteMarketPricesErrorEnum */
	std::string *completeMarketPrices;	/* optional element of type xsd:string */
	std::string *currencyCode;	/* optional element of type xsd:string */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 243; } /* = unique id SOAP_TYPE_ns3__GetCompleteMarketPricesCompressedResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCompleteMarketPricesCompressedResp(): completeMarketPrices(NULL), currencyCode(NULL), minorErrorCode(NULL) { ns3__GetCompleteMarketPricesCompressedResp::soap_default(NULL); }
	virtual ~ns3__GetCompleteMarketPricesCompressedResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCompleteMarketPricesCompressedReq
#define SOAP_TYPE_ns3__GetCompleteMarketPricesCompressedReq (244)
/* ns3:GetCompleteMarketPricesCompressedReq */
class SOAP_CMAC ns3__GetCompleteMarketPricesCompressedReq : public ns3__APIRequest
{
public:
	std::string *currencyCode;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 244; } /* = unique id SOAP_TYPE_ns3__GetCompleteMarketPricesCompressedReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCompleteMarketPricesCompressedReq(): currencyCode(NULL) { ns3__GetCompleteMarketPricesCompressedReq::soap_default(NULL); }
	virtual ~ns3__GetCompleteMarketPricesCompressedReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedResp
#define SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedResp (245)
/* ns3:GetMarketTradedVolumeCompressedResp */
class SOAP_CMAC ns3__GetMarketTradedVolumeCompressedResp : public ns3__APIResponse
{
public:
	enum ns3__GetMarketTradedVolumeCompressedErrorEnum errorCode;	/* required element of type ns3:GetMarketTradedVolumeCompressedErrorEnum */
	std::string *tradedVolume;	/* optional element of type xsd:string */
	std::string *currencyCode;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 245; } /* = unique id SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketTradedVolumeCompressedResp(): tradedVolume(NULL), currencyCode(NULL), minorErrorCode(NULL) { ns3__GetMarketTradedVolumeCompressedResp::soap_default(NULL); }
	virtual ~ns3__GetMarketTradedVolumeCompressedResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedReq
#define SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedReq (246)
/* ns3:GetMarketTradedVolumeCompressedReq */
class SOAP_CMAC ns3__GetMarketTradedVolumeCompressedReq : public ns3__APIRequest
{
public:
	std::string *currencyCode;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 246; } /* = unique id SOAP_TYPE_ns3__GetMarketTradedVolumeCompressedReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketTradedVolumeCompressedReq(): currencyCode(NULL) { ns3__GetMarketTradedVolumeCompressedReq::soap_default(NULL); }
	virtual ~ns3__GetMarketTradedVolumeCompressedReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketPricesCompressedResp
#define SOAP_TYPE_ns3__GetMarketPricesCompressedResp (247)
/* ns3:GetMarketPricesCompressedResp */
class SOAP_CMAC ns3__GetMarketPricesCompressedResp : public ns3__APIResponse
{
public:
	enum ns3__GetMarketPricesErrorEnum errorCode;	/* required element of type ns3:GetMarketPricesErrorEnum */
	std::string *marketPrices;	/* optional element of type xsd:string */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 247; } /* = unique id SOAP_TYPE_ns3__GetMarketPricesCompressedResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketPricesCompressedResp(): marketPrices(NULL), minorErrorCode(NULL) { ns3__GetMarketPricesCompressedResp::soap_default(NULL); }
	virtual ~ns3__GetMarketPricesCompressedResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketPricesCompressedReq
#define SOAP_TYPE_ns3__GetMarketPricesCompressedReq (248)
/* ns3:GetMarketPricesCompressedReq */
class SOAP_CMAC ns3__GetMarketPricesCompressedReq : public ns3__APIRequest
{
public:
	std::string *currencyCode;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 248; } /* = unique id SOAP_TYPE_ns3__GetMarketPricesCompressedReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketPricesCompressedReq(): currencyCode(NULL) { ns3__GetMarketPricesCompressedReq::soap_default(NULL); }
	virtual ~ns3__GetMarketPricesCompressedReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCurrentBetsResp
#define SOAP_TYPE_ns3__GetCurrentBetsResp (249)
/* ns3:GetCurrentBetsResp */
class SOAP_CMAC ns3__GetCurrentBetsResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfBet *bets;	/* optional element of type ns3:ArrayOfBet */
	enum ns3__GetCurrentBetsErrorEnum errorCode;	/* required element of type ns3:GetCurrentBetsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	int totalRecordCount;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 249; } /* = unique id SOAP_TYPE_ns3__GetCurrentBetsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCurrentBetsResp(): bets(NULL), minorErrorCode(NULL) { ns3__GetCurrentBetsResp::soap_default(NULL); }
	virtual ~ns3__GetCurrentBetsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMUBetsResp
#define SOAP_TYPE_ns3__GetMUBetsResp (250)
/* ns3:GetMUBetsResp */
class SOAP_CMAC ns3__GetMUBetsResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfMUBet *bets;	/* optional element of type ns3:ArrayOfMUBet */
	enum ns3__GetMUBetsErrorEnum errorCode;	/* required element of type ns3:GetMUBetsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	int totalRecordCount;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 250; } /* = unique id SOAP_TYPE_ns3__GetMUBetsResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMUBetsResp(): bets(NULL), minorErrorCode(NULL) { ns3__GetMUBetsResp::soap_default(NULL); }
	virtual ~ns3__GetMUBetsResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMUBetsReq
#define SOAP_TYPE_ns3__GetMUBetsReq (253)
/* ns3:GetMUBetsReq */
class SOAP_CMAC ns3__GetMUBetsReq : public ns3__APIRequest
{
public:
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	int marketId;	/* required element of type xsd:int */
	ns3__ArrayOfBetId *betIds;	/* optional element of type ns3:ArrayOfBetId */
	enum ns3__BetsOrderByEnum orderBy;	/* required element of type ns3:BetsOrderByEnum */
	enum ns3__SortOrderEnum sortOrder;	/* required element of type ns3:SortOrderEnum */
	int recordCount;	/* required element of type xsd:int */
	int startRecord;	/* required element of type xsd:int */
	time_t *matchedSince;	/* optional element of type xsd:dateTime */
	bool excludeLastSecond;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 253; } /* = unique id SOAP_TYPE_ns3__GetMUBetsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMUBetsReq(): betIds(NULL), matchedSince(NULL) { ns3__GetMUBetsReq::soap_default(NULL); }
	virtual ~ns3__GetMUBetsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCurrentBetsReq
#define SOAP_TYPE_ns3__GetCurrentBetsReq (259)
/* ns3:GetCurrentBetsReq */
class SOAP_CMAC ns3__GetCurrentBetsReq : public ns3__APIRequest
{
public:
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	bool detailed;	/* required element of type xsd:boolean */
	std::string *locale;	/* optional element of type xsd:string */
	std::string *timezone;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
	enum ns3__BetsOrderByEnum orderBy;	/* required element of type ns3:BetsOrderByEnum */
	int recordCount;	/* required element of type xsd:int */
	int startRecord;	/* required element of type xsd:int */
	bool noTotalRecordCount;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 259; } /* = unique id SOAP_TYPE_ns3__GetCurrentBetsReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCurrentBetsReq(): locale(NULL), timezone(NULL) { ns3__GetCurrentBetsReq::soap_default(NULL); }
	virtual ~ns3__GetCurrentBetsReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetDetailedAvailableMktDepthResp
#define SOAP_TYPE_ns3__GetDetailedAvailableMktDepthResp (260)
/* ns3:GetDetailedAvailableMktDepthResp */
class SOAP_CMAC ns3__GetDetailedAvailableMktDepthResp : public ns3__APIResponse
{
public:
	enum ns3__GetDetailedAvailMktDepthErrorEnum errorCode;	/* required element of type ns3:GetDetailedAvailMktDepthErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns3__ArrayOfAvailabilityInfo *priceItems;	/* optional element of type ns3:ArrayOfAvailabilityInfo */
public:
	virtual int soap_type() const { return 260; } /* = unique id SOAP_TYPE_ns3__GetDetailedAvailableMktDepthResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetDetailedAvailableMktDepthResp(): minorErrorCode(NULL), priceItems(NULL) { ns3__GetDetailedAvailableMktDepthResp::soap_default(NULL); }
	virtual ~ns3__GetDetailedAvailableMktDepthResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetDetailedAvailableMktDepthReq
#define SOAP_TYPE_ns3__GetDetailedAvailableMktDepthReq (263)
/* ns3:GetDetailedAvailableMktDepthReq */
class SOAP_CMAC ns3__GetDetailedAvailableMktDepthReq : public ns3__APIRequest
{
public:
	int asianLineId;	/* required element of type xsd:int */
	std::string *currencyCode;	/* optional element of type xsd:string */
	std::string *locale;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
	int selectionId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 263; } /* = unique id SOAP_TYPE_ns3__GetDetailedAvailableMktDepthReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetDetailedAvailableMktDepthReq(): currencyCode(NULL), locale(NULL) { ns3__GetDetailedAvailableMktDepthReq::soap_default(NULL); }
	virtual ~ns3__GetDetailedAvailableMktDepthReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketTradedVolumeResp
#define SOAP_TYPE_ns3__GetMarketTradedVolumeResp (264)
/* ns3:GetMarketTradedVolumeResp */
class SOAP_CMAC ns3__GetMarketTradedVolumeResp : public ns3__APIResponse
{
public:
	enum ns3__GetMarketTradedVolumeErrorEnum errorCode;	/* required element of type ns3:GetMarketTradedVolumeErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	ns3__ArrayOfVolumeInfo *priceItems;	/* optional element of type ns3:ArrayOfVolumeInfo */
	double *actualBSP;	/* optional element of type xsd:double */
public:
	virtual int soap_type() const { return 264; } /* = unique id SOAP_TYPE_ns3__GetMarketTradedVolumeResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketTradedVolumeResp(): minorErrorCode(NULL), priceItems(NULL), actualBSP(NULL) { ns3__GetMarketTradedVolumeResp::soap_default(NULL); }
	virtual ~ns3__GetMarketTradedVolumeResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketTradedVolumeReq
#define SOAP_TYPE_ns3__GetMarketTradedVolumeReq (267)
/* ns3:GetMarketTradedVolumeReq */
class SOAP_CMAC ns3__GetMarketTradedVolumeReq : public ns3__APIRequest
{
public:
	int asianLineId;	/* required element of type xsd:int */
	std::string *currencyCode;	/* optional element of type xsd:string */
	int marketId;	/* required element of type xsd:int */
	int selectionId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 267; } /* = unique id SOAP_TYPE_ns3__GetMarketTradedVolumeReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketTradedVolumeReq(): currencyCode(NULL) { ns3__GetMarketTradedVolumeReq::soap_default(NULL); }
	virtual ~ns3__GetMarketTradedVolumeReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetHistoryResp
#define SOAP_TYPE_ns3__GetBetHistoryResp (268)
/* ns3:GetBetHistoryResp */
class SOAP_CMAC ns3__GetBetHistoryResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfBet *betHistoryItems;	/* optional element of type ns3:ArrayOfBet */
	enum ns3__GetBetHistoryErrorEnum errorCode;	/* required element of type ns3:GetBetHistoryErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	int totalRecordCount;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 268; } /* = unique id SOAP_TYPE_ns3__GetBetHistoryResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetHistoryResp(): betHistoryItems(NULL), minorErrorCode(NULL) { ns3__GetBetHistoryResp::soap_default(NULL); }
	virtual ~ns3__GetBetHistoryResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetHistoryReq
#define SOAP_TYPE_ns3__GetBetHistoryReq (269)
/* ns3:GetBetHistoryReq */
class SOAP_CMAC ns3__GetBetHistoryReq : public ns3__APIRequest
{
public:
	enum ns3__BetStatusEnum betTypesIncluded;	/* required element of type ns3:BetStatusEnum */
	bool detailed;	/* required element of type xsd:boolean */
	ns3__ArrayOfInt *eventTypeIds;	/* optional element of type ns3:ArrayOfInt */
	int marketId;	/* required element of type xsd:int */
	std::string *locale;	/* optional element of type xsd:string */
	std::string *timezone;	/* optional element of type xsd:string */
	ns3__ArrayOfMarketTypeEnum *marketTypesIncluded;	/* optional element of type ns3:ArrayOfMarketTypeEnum */
	time_t placedDateFrom;	/* required element of type xsd:dateTime */
	time_t placedDateTo;	/* required element of type xsd:dateTime */
	int recordCount;	/* required element of type xsd:int */
	enum ns3__BetsOrderByEnum sortBetsBy;	/* required element of type ns3:BetsOrderByEnum */
	int startRecord;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 269; } /* = unique id SOAP_TYPE_ns3__GetBetHistoryReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetHistoryReq(): eventTypeIds(NULL), locale(NULL), timezone(NULL), marketTypesIncluded(NULL) { ns3__GetBetHistoryReq::soap_default(NULL); }
	virtual ~ns3__GetBetHistoryReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetAccountStatementResp
#define SOAP_TYPE_ns3__GetAccountStatementResp (272)
/* ns3:GetAccountStatementResp */
class SOAP_CMAC ns3__GetAccountStatementResp : public ns3__APIResponse
{
public:
	enum ns3__GetAccountStatementErrorEnum errorCode;	/* required element of type ns3:GetAccountStatementErrorEnum */
	ns3__ArrayOfAccountStatementItem *items;	/* optional element of type ns3:ArrayOfAccountStatementItem */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	int totalRecordCount;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 272; } /* = unique id SOAP_TYPE_ns3__GetAccountStatementResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetAccountStatementResp(): items(NULL), minorErrorCode(NULL) { ns3__GetAccountStatementResp::soap_default(NULL); }
	virtual ~ns3__GetAccountStatementResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetAccountStatementReq
#define SOAP_TYPE_ns3__GetAccountStatementReq (275)
/* ns3:GetAccountStatementReq */
class SOAP_CMAC ns3__GetAccountStatementReq : public ns3__APIRequest
{
public:
	time_t endDate;	/* required element of type xsd:dateTime */
	enum ns3__AccountStatementIncludeEnum itemsIncluded;	/* required element of type ns3:AccountStatementIncludeEnum */
	bool ignoreAutoTransfers;	/* required element of type xsd:boolean */
	int recordCount;	/* required element of type xsd:int */
	time_t startDate;	/* required element of type xsd:dateTime */
	int startRecord;	/* required element of type xsd:int */
	std::string *locale;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 275; } /* = unique id SOAP_TYPE_ns3__GetAccountStatementReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetAccountStatementReq(): locale(NULL) { ns3__GetAccountStatementReq::soap_default(NULL); }
	virtual ~ns3__GetAccountStatementReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketProfitAndLossResp
#define SOAP_TYPE_ns3__GetMarketProfitAndLossResp (276)
/* ns3:GetMarketProfitAndLossResp */
class SOAP_CMAC ns3__GetMarketProfitAndLossResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfProfitAndLoss *annotations;	/* optional element of type ns3:ArrayOfProfitAndLoss */
	double commissionApplied;	/* required element of type xsd:double */
	std::string *currencyCode;	/* optional element of type xsd:string */
	enum ns3__GetMarketProfitAndLossErrorEnum errorCode;	/* required element of type ns3:GetMarketProfitAndLossErrorEnum */
	bool includesSettledBets;	/* required element of type xsd:boolean */
	bool includesBspBets;	/* required element of type xsd:boolean */
	int marketId;	/* required element of type xsd:int */
	std::string *marketName;	/* optional element of type xsd:string */
	enum ns3__MarketStatusEnum marketStatus;	/* required element of type ns3:MarketStatusEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	std::string *unit;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 276; } /* = unique id SOAP_TYPE_ns3__GetMarketProfitAndLossResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketProfitAndLossResp(): annotations(NULL), currencyCode(NULL), marketName(NULL), minorErrorCode(NULL), unit(NULL) { ns3__GetMarketProfitAndLossResp::soap_default(NULL); }
	virtual ~ns3__GetMarketProfitAndLossResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketProfitAndLossReq
#define SOAP_TYPE_ns3__GetMarketProfitAndLossReq (279)
/* ns3:GetMarketProfitAndLossReq */
class SOAP_CMAC ns3__GetMarketProfitAndLossReq : public ns3__APIRequest
{
public:
	std::string *locale;	/* optional element of type xsd:string */
	bool includeSettledBets;	/* required element of type xsd:boolean */
	bool includeBspBets;	/* required element of type xsd:boolean */
	int marketID;	/* required element of type xsd:int */
	bool netOfCommission;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 279; } /* = unique id SOAP_TYPE_ns3__GetMarketProfitAndLossReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketProfitAndLossReq(): locale(NULL) { ns3__GetMarketProfitAndLossReq::soap_default(NULL); }
	virtual ~ns3__GetMarketProfitAndLossReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetResp
#define SOAP_TYPE_ns3__GetBetResp (280)
/* ns3:GetBetResp */
class SOAP_CMAC ns3__GetBetResp : public ns3__APIResponse
{
public:
	ns3__Bet *bet;	/* optional element of type ns3:Bet */
	enum ns3__GetBetErrorEnum errorCode;	/* required element of type ns3:GetBetErrorEnum */
public:
	virtual int soap_type() const { return 280; } /* = unique id SOAP_TYPE_ns3__GetBetResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetResp(): bet(NULL) { ns3__GetBetResp::soap_default(NULL); }
	virtual ~ns3__GetBetResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetReq
#define SOAP_TYPE_ns3__GetBetReq (281)
/* ns3:GetBetReq */
class SOAP_CMAC ns3__GetBetReq : public ns3__APIRequest
{
public:
	LONG64 betId;	/* required element of type xsd:long */
	std::string *locale;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 281; } /* = unique id SOAP_TYPE_ns3__GetBetReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetReq(): locale(NULL) { ns3__GetBetReq::soap_default(NULL); }
	virtual ~ns3__GetBetReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetLiteResp
#define SOAP_TYPE_ns3__GetBetLiteResp (282)
/* ns3:GetBetLiteResp */
class SOAP_CMAC ns3__GetBetLiteResp : public ns3__APIResponse
{
public:
	ns3__BetLite *betLite;	/* optional element of type ns3:BetLite */
	enum ns3__GetBetErrorEnum errorCode;	/* required element of type ns3:GetBetErrorEnum */
public:
	virtual int soap_type() const { return 282; } /* = unique id SOAP_TYPE_ns3__GetBetLiteResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetLiteResp(): betLite(NULL) { ns3__GetBetLiteResp::soap_default(NULL); }
	virtual ~ns3__GetBetLiteResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetLiteReq
#define SOAP_TYPE_ns3__GetBetLiteReq (285)
/* ns3:GetBetLiteReq */
class SOAP_CMAC ns3__GetBetLiteReq : public ns3__APIRequest
{
public:
	LONG64 betId;	/* required element of type xsd:long */
public:
	virtual int soap_type() const { return 285; } /* = unique id SOAP_TYPE_ns3__GetBetLiteReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetLiteReq() { ns3__GetBetLiteReq::soap_default(NULL); }
	virtual ~ns3__GetBetLiteReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetMatchesLiteReq
#define SOAP_TYPE_ns3__GetBetMatchesLiteReq (286)
/* ns3:GetBetMatchesLiteReq */
class SOAP_CMAC ns3__GetBetMatchesLiteReq : public ns3__APIRequest
{
public:
	LONG64 betId;	/* required element of type xsd:long */
public:
	virtual int soap_type() const { return 286; } /* = unique id SOAP_TYPE_ns3__GetBetMatchesLiteReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetMatchesLiteReq() { ns3__GetBetMatchesLiteReq::soap_default(NULL); }
	virtual ~ns3__GetBetMatchesLiteReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetBetMatchesLiteResp
#define SOAP_TYPE_ns3__GetBetMatchesLiteResp (287)
/* ns3:GetBetMatchesLiteResp */
class SOAP_CMAC ns3__GetBetMatchesLiteResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfMatchLite *matchLites;	/* optional element of type ns3:ArrayOfMatchLite */
	enum ns3__GetBetErrorEnum errorCode;	/* required element of type ns3:GetBetErrorEnum */
public:
	virtual int soap_type() const { return 287; } /* = unique id SOAP_TYPE_ns3__GetBetMatchesLiteResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetBetMatchesLiteResp(): matchLites(NULL) { ns3__GetBetMatchesLiteResp::soap_default(NULL); }
	virtual ~ns3__GetBetMatchesLiteResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCurrentBetsLiteResp
#define SOAP_TYPE_ns3__GetCurrentBetsLiteResp (290)
/* ns3:GetCurrentBetsLiteResp */
class SOAP_CMAC ns3__GetCurrentBetsLiteResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfBetLite *betLites;	/* optional element of type ns3:ArrayOfBetLite */
	enum ns3__GetCurrentBetsErrorEnum errorCode;	/* required element of type ns3:GetCurrentBetsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	int totalRecordCount;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 290; } /* = unique id SOAP_TYPE_ns3__GetCurrentBetsLiteResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCurrentBetsLiteResp(): betLites(NULL), minorErrorCode(NULL) { ns3__GetCurrentBetsLiteResp::soap_default(NULL); }
	virtual ~ns3__GetCurrentBetsLiteResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetCurrentBetsLiteReq
#define SOAP_TYPE_ns3__GetCurrentBetsLiteReq (291)
/* ns3:GetCurrentBetsLiteReq */
class SOAP_CMAC ns3__GetCurrentBetsLiteReq : public ns3__APIRequest
{
public:
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	int marketId;	/* required element of type xsd:int */
	enum ns3__BetsOrderByEnum orderBy;	/* required element of type ns3:BetsOrderByEnum */
	int recordCount;	/* required element of type xsd:int */
	int startRecord;	/* required element of type xsd:int */
	bool noTotalRecordCount;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 291; } /* = unique id SOAP_TYPE_ns3__GetCurrentBetsLiteReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetCurrentBetsLiteReq() { ns3__GetCurrentBetsLiteReq::soap_default(NULL); }
	virtual ~ns3__GetCurrentBetsLiteReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMUBetsLiteResp
#define SOAP_TYPE_ns3__GetMUBetsLiteResp (294)
/* ns3:GetMUBetsLiteResp */
class SOAP_CMAC ns3__GetMUBetsLiteResp : public ns3__APIResponse
{
public:
	ns3__ArrayOfMUBetLite *betLites;	/* optional element of type ns3:ArrayOfMUBetLite */
	enum ns3__GetMUBetsErrorEnum errorCode;	/* required element of type ns3:GetMUBetsErrorEnum */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
	int totalRecordCount;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 294; } /* = unique id SOAP_TYPE_ns3__GetMUBetsLiteResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMUBetsLiteResp(): betLites(NULL), minorErrorCode(NULL) { ns3__GetMUBetsLiteResp::soap_default(NULL); }
	virtual ~ns3__GetMUBetsLiteResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMUBetsLiteReq
#define SOAP_TYPE_ns3__GetMUBetsLiteReq (295)
/* ns3:GetMUBetsLiteReq */
class SOAP_CMAC ns3__GetMUBetsLiteReq : public ns3__APIRequest
{
public:
	enum ns3__BetStatusEnum betStatus;	/* required element of type ns3:BetStatusEnum */
	int marketId;	/* required element of type xsd:int */
	ns3__ArrayOfBetId *betIds;	/* optional element of type ns3:ArrayOfBetId */
	enum ns3__BetsOrderByEnum orderBy;	/* required element of type ns3:BetsOrderByEnum */
	enum ns3__SortOrderEnum sortOrder;	/* required element of type ns3:SortOrderEnum */
	int recordCount;	/* required element of type xsd:int */
	int startRecord;	/* required element of type xsd:int */
	time_t *matchedSince;	/* optional element of type xsd:dateTime */
	bool excludeLastSecond;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 295; } /* = unique id SOAP_TYPE_ns3__GetMUBetsLiteReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMUBetsLiteReq(): betIds(NULL), matchedSince(NULL) { ns3__GetMUBetsLiteReq::soap_default(NULL); }
	virtual ~ns3__GetMUBetsLiteReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketInfoResp
#define SOAP_TYPE_ns3__GetMarketInfoResp (296)
/* ns3:GetMarketInfoResp */
class SOAP_CMAC ns3__GetMarketInfoResp : public ns3__APIResponse
{
public:
	enum ns3__GetMarketErrorEnum errorCode;	/* required element of type ns3:GetMarketErrorEnum */
	ns3__MarketLite *marketLite;	/* optional element of type ns3:MarketLite */
	std::string *minorErrorCode;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 296; } /* = unique id SOAP_TYPE_ns3__GetMarketInfoResp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketInfoResp(): marketLite(NULL), minorErrorCode(NULL) { ns3__GetMarketInfoResp::soap_default(NULL); }
	virtual ~ns3__GetMarketInfoResp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetMarketInfoReq
#define SOAP_TYPE_ns3__GetMarketInfoReq (298)
/* ns3:GetMarketInfoReq */
class SOAP_CMAC ns3__GetMarketInfoReq : public ns3__APIRequest
{
public:
	int marketId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 298; } /* = unique id SOAP_TYPE_ns3__GetMarketInfoReq */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetMarketInfoReq() { ns3__GetMarketInfoReq::soap_default(NULL); }
	virtual ~ns3__GetMarketInfoReq() { }
};
#endif

#ifndef SOAP_TYPE_ns3__HandicapLine
#define SOAP_TYPE_ns3__HandicapLine (299)
/* ns3:HandicapLine */
class SOAP_CMAC ns3__HandicapLine : public ns3__ProfitAndLoss
{
public:
	double from;	/* required element of type xsd:double */
	double to;	/* required element of type xsd:double */
public:
	virtual int soap_type() const { return 299; } /* = unique id SOAP_TYPE_ns3__HandicapLine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__HandicapLine() { ns3__HandicapLine::soap_default(NULL); }
	virtual ~ns3__HandicapLine() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MultiWinnerOddsLine
#define SOAP_TYPE_ns3__MultiWinnerOddsLine (300)
/* ns3:MultiWinnerOddsLine */
class SOAP_CMAC ns3__MultiWinnerOddsLine : public ns3__ProfitAndLoss
{
public:
	double ifLoss;	/* required element of type xsd:double */
public:
	virtual int soap_type() const { return 300; } /* = unique id SOAP_TYPE_ns3__MultiWinnerOddsLine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MultiWinnerOddsLine() { ns3__MultiWinnerOddsLine::soap_default(NULL); }
	virtual ~ns3__MultiWinnerOddsLine() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ViewProfileV2Resp
#define SOAP_TYPE_ns1__ViewProfileV2Resp (100)
/* ns1:ViewProfileV2Resp */
class SOAP_CMAC ns1__ViewProfileV2Resp : public ns1__ViewProfileResp
{
public:
	std::string *tAN;	/* optional element of type xsd:string */
	std::string *referAndEarnCode;	/* optional element of type xsd:string */
	std::string *earthportID;	/* optional element of type xsd:string */
	enum ns1__KYCStatusEnum kYCStatus;	/* required element of type ns1:KYCStatusEnum */
	std::string *nationalIdentifier;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns1__ViewProfileV2Resp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ViewProfileV2Resp(): tAN(NULL), referAndEarnCode(NULL), earthportID(NULL), nationalIdentifier(NULL) { ns1__ViewProfileV2Resp::soap_default(NULL); }
	virtual ~ns1__ViewProfileV2Resp() { }
};
#endif

#ifndef SOAP_TYPE_ns3__GetSilksV2Req
#define SOAP_TYPE_ns3__GetSilksV2Req (188)
/* ns3:GetSilksV2Req */
class SOAP_CMAC ns3__GetSilksV2Req : public ns3__GetSilksReq
{
public:
	virtual int soap_type() const { return 188; } /* = unique id SOAP_TYPE_ns3__GetSilksV2Req */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__GetSilksV2Req() { ns3__GetSilksV2Req::soap_default(NULL); }
	virtual ~ns3__GetSilksV2Req() { }
};
#endif

#ifndef SOAP_TYPE___ns2__login
#define SOAP_TYPE___ns2__login (736)
/* Operation wrapper: */
struct __ns2__login
{
public:
	_ns2__login *ns2__login;	/* optional element of type ns2:login */
};
#endif

#ifndef SOAP_TYPE___ns2__retrieveLIMBMessage
#define SOAP_TYPE___ns2__retrieveLIMBMessage (740)
/* Operation wrapper: */
struct __ns2__retrieveLIMBMessage
{
public:
	_ns2__retrieveLIMBMessage *ns2__retrieveLIMBMessage;	/* optional element of type ns2:retrieveLIMBMessage */
};
#endif

#ifndef SOAP_TYPE___ns2__submitLIMBMessage
#define SOAP_TYPE___ns2__submitLIMBMessage (744)
/* Operation wrapper: */
struct __ns2__submitLIMBMessage
{
public:
	_ns2__submitLIMBMessage *ns2__submitLIMBMessage;	/* optional element of type ns2:submitLIMBMessage */
};
#endif

#ifndef SOAP_TYPE___ns2__logout
#define SOAP_TYPE___ns2__logout (748)
/* Operation wrapper: */
struct __ns2__logout
{
public:
	_ns2__logout *ns2__logout;	/* optional element of type ns2:logout */
};
#endif

#ifndef SOAP_TYPE___ns2__keepAlive
#define SOAP_TYPE___ns2__keepAlive (752)
/* Operation wrapper: */
struct __ns2__keepAlive
{
public:
	_ns2__keepAlive *ns2__keepAlive;	/* optional element of type ns2:keepAlive */
};
#endif

#ifndef SOAP_TYPE___ns2__getEvents
#define SOAP_TYPE___ns2__getEvents (756)
/* Operation wrapper: */
struct __ns2__getEvents
{
public:
	_ns2__getEvents *ns2__getEvents;	/* optional element of type ns2:getEvents */
};
#endif

#ifndef SOAP_TYPE___ns2__getActiveEventTypes
#define SOAP_TYPE___ns2__getActiveEventTypes (760)
/* Operation wrapper: */
struct __ns2__getActiveEventTypes
{
public:
	_ns2__getActiveEventTypes *ns2__getActiveEventTypes;	/* optional element of type ns2:getActiveEventTypes */
};
#endif

#ifndef SOAP_TYPE___ns2__getAllEventTypes
#define SOAP_TYPE___ns2__getAllEventTypes (764)
/* Operation wrapper: */
struct __ns2__getAllEventTypes
{
public:
	_ns2__getAllEventTypes *ns2__getAllEventTypes;	/* optional element of type ns2:getAllEventTypes */
};
#endif

#ifndef SOAP_TYPE___ns2__getSubscriptionInfo
#define SOAP_TYPE___ns2__getSubscriptionInfo (768)
/* Operation wrapper: */
struct __ns2__getSubscriptionInfo
{
public:
	_ns2__getSubscriptionInfo *ns2__getSubscriptionInfo;	/* optional element of type ns2:getSubscriptionInfo */
};
#endif

#ifndef SOAP_TYPE___ns2__depositFromPaymentCard
#define SOAP_TYPE___ns2__depositFromPaymentCard (772)
/* Operation wrapper: */
struct __ns2__depositFromPaymentCard
{
public:
	_ns2__depositFromPaymentCard *ns2__depositFromPaymentCard;	/* optional element of type ns2:depositFromPaymentCard */
};
#endif

#ifndef SOAP_TYPE___ns2__addPaymentCard
#define SOAP_TYPE___ns2__addPaymentCard (776)
/* Operation wrapper: */
struct __ns2__addPaymentCard
{
public:
	_ns2__addPaymentCard *ns2__addPaymentCard;	/* optional element of type ns2:addPaymentCard */
};
#endif

#ifndef SOAP_TYPE___ns2__deletePaymentCard
#define SOAP_TYPE___ns2__deletePaymentCard (780)
/* Operation wrapper: */
struct __ns2__deletePaymentCard
{
public:
	_ns2__deletePaymentCard *ns2__deletePaymentCard;	/* optional element of type ns2:deletePaymentCard */
};
#endif

#ifndef SOAP_TYPE___ns2__updatePaymentCard
#define SOAP_TYPE___ns2__updatePaymentCard (784)
/* Operation wrapper: */
struct __ns2__updatePaymentCard
{
public:
	_ns2__updatePaymentCard *ns2__updatePaymentCard;	/* optional element of type ns2:updatePaymentCard */
};
#endif

#ifndef SOAP_TYPE___ns2__getPaymentCard
#define SOAP_TYPE___ns2__getPaymentCard (788)
/* Operation wrapper: */
struct __ns2__getPaymentCard
{
public:
	_ns2__getPaymentCard *ns2__getPaymentCard;	/* optional element of type ns2:getPaymentCard */
};
#endif

#ifndef SOAP_TYPE___ns2__withdrawToPaymentCard
#define SOAP_TYPE___ns2__withdrawToPaymentCard (792)
/* Operation wrapper: */
struct __ns2__withdrawToPaymentCard
{
public:
	_ns2__withdrawToPaymentCard *ns2__withdrawToPaymentCard;	/* optional element of type ns2:withdrawToPaymentCard */
};
#endif

#ifndef SOAP_TYPE___ns2__selfExclude
#define SOAP_TYPE___ns2__selfExclude (796)
/* Operation wrapper: */
struct __ns2__selfExclude
{
public:
	_ns2__selfExclude *ns2__selfExclude;	/* optional element of type ns2:selfExclude */
};
#endif

#ifndef SOAP_TYPE___ns2__convertCurrency
#define SOAP_TYPE___ns2__convertCurrency (800)
/* Operation wrapper: */
struct __ns2__convertCurrency
{
public:
	_ns2__convertCurrency *ns2__convertCurrency;	/* optional element of type ns2:convertCurrency */
};
#endif

#ifndef SOAP_TYPE___ns2__getAllCurrencies
#define SOAP_TYPE___ns2__getAllCurrencies (804)
/* Operation wrapper: */
struct __ns2__getAllCurrencies
{
public:
	_ns2__getAllCurrencies *ns2__getAllCurrencies;	/* optional element of type ns2:getAllCurrencies */
};
#endif

#ifndef SOAP_TYPE___ns2__getAllCurrenciesV2
#define SOAP_TYPE___ns2__getAllCurrenciesV2 (808)
/* Operation wrapper: */
struct __ns2__getAllCurrenciesV2
{
public:
	_ns2__getAllCurrenciesV2 *ns2__getAllCurrenciesV2;	/* optional element of type ns2:getAllCurrenciesV2 */
};
#endif

#ifndef SOAP_TYPE___ns2__viewReferAndEarn
#define SOAP_TYPE___ns2__viewReferAndEarn (812)
/* Operation wrapper: */
struct __ns2__viewReferAndEarn
{
public:
	_ns2__viewReferAndEarn *ns2__viewReferAndEarn;	/* optional element of type ns2:viewReferAndEarn */
};
#endif

#ifndef SOAP_TYPE___ns2__viewProfile
#define SOAP_TYPE___ns2__viewProfile (816)
/* Operation wrapper: */
struct __ns2__viewProfile
{
public:
	_ns2__viewProfile *ns2__viewProfile;	/* optional element of type ns2:viewProfile */
};
#endif

#ifndef SOAP_TYPE___ns2__viewProfileV2
#define SOAP_TYPE___ns2__viewProfileV2 (820)
/* Operation wrapper: */
struct __ns2__viewProfileV2
{
public:
	_ns2__viewProfileV2 *ns2__viewProfileV2;	/* optional element of type ns2:viewProfileV2 */
};
#endif

#ifndef SOAP_TYPE___ns2__modifyProfile
#define SOAP_TYPE___ns2__modifyProfile (824)
/* Operation wrapper: */
struct __ns2__modifyProfile
{
public:
	_ns2__modifyProfile *ns2__modifyProfile;	/* optional element of type ns2:modifyProfile */
};
#endif

#ifndef SOAP_TYPE___ns2__createAccount
#define SOAP_TYPE___ns2__createAccount (828)
/* Operation wrapper: */
struct __ns2__createAccount
{
public:
	_ns2__createAccount *ns2__createAccount;	/* optional element of type ns2:createAccount */
};
#endif

#ifndef SOAP_TYPE___ns2__forgotPassword
#define SOAP_TYPE___ns2__forgotPassword (832)
/* Operation wrapper: */
struct __ns2__forgotPassword
{
public:
	_ns2__forgotPassword *ns2__forgotPassword;	/* optional element of type ns2:forgotPassword */
};
#endif

#ifndef SOAP_TYPE___ns2__modifyPassword
#define SOAP_TYPE___ns2__modifyPassword (836)
/* Operation wrapper: */
struct __ns2__modifyPassword
{
public:
	_ns2__modifyPassword *ns2__modifyPassword;	/* optional element of type ns2:modifyPassword */
};
#endif

#ifndef SOAP_TYPE___ns2__withdrawByBankTransfer
#define SOAP_TYPE___ns2__withdrawByBankTransfer (840)
/* Operation wrapper: */
struct __ns2__withdrawByBankTransfer
{
public:
	_ns2__withdrawByBankTransfer *ns2__withdrawByBankTransfer;	/* optional element of type ns2:withdrawByBankTransfer */
};
#endif

#ifndef SOAP_TYPE___ns2__setChatName
#define SOAP_TYPE___ns2__setChatName (844)
/* Operation wrapper: */
struct __ns2__setChatName
{
public:
	_ns2__setChatName *ns2__setChatName;	/* optional element of type ns2:setChatName */
};
#endif

#ifndef SOAP_TYPE___ns2__transferFunds
#define SOAP_TYPE___ns2__transferFunds (848)
/* Operation wrapper: */
struct __ns2__transferFunds
{
public:
	_ns2__transferFunds *ns2__transferFunds;	/* optional element of type ns2:transferFunds */
};
#endif

#ifndef SOAP_TYPE___ns4__getAccountFunds
#define SOAP_TYPE___ns4__getAccountFunds (852)
/* Operation wrapper: */
struct __ns4__getAccountFunds
{
public:
	_ns4__getAccountFunds *ns4__getAccountFunds;	/* optional element of type ns4:getAccountFunds */
};
#endif

#ifndef SOAP_TYPE___ns4__cancelBets
#define SOAP_TYPE___ns4__cancelBets (856)
/* Operation wrapper: */
struct __ns4__cancelBets
{
public:
	_ns4__cancelBets *ns4__cancelBets;	/* optional element of type ns4:cancelBets */
};
#endif

#ifndef SOAP_TYPE___ns4__cancelBetsByMarket
#define SOAP_TYPE___ns4__cancelBetsByMarket (860)
/* Operation wrapper: */
struct __ns4__cancelBetsByMarket
{
public:
	_ns4__cancelBetsByMarket *ns4__cancelBetsByMarket;	/* optional element of type ns4:cancelBetsByMarket */
};
#endif

#ifndef SOAP_TYPE___ns4__updateBets
#define SOAP_TYPE___ns4__updateBets (864)
/* Operation wrapper: */
struct __ns4__updateBets
{
public:
	_ns4__updateBets *ns4__updateBets;	/* optional element of type ns4:updateBets */
};
#endif

#ifndef SOAP_TYPE___ns4__placeBets
#define SOAP_TYPE___ns4__placeBets (868)
/* Operation wrapper: */
struct __ns4__placeBets
{
public:
	_ns4__placeBets *ns4__placeBets;	/* optional element of type ns4:placeBets */
};
#endif

#ifndef SOAP_TYPE___ns4__getMarket
#define SOAP_TYPE___ns4__getMarket (872)
/* Operation wrapper: */
struct __ns4__getMarket
{
public:
	_ns4__getMarket *ns4__getMarket;	/* optional element of type ns4:getMarket */
};
#endif

#ifndef SOAP_TYPE___ns4__getMarketInfo
#define SOAP_TYPE___ns4__getMarketInfo (876)
/* Operation wrapper: */
struct __ns4__getMarketInfo
{
public:
	_ns4__getMarketInfo *ns4__getMarketInfo;	/* optional element of type ns4:getMarketInfo */
};
#endif

#ifndef SOAP_TYPE___ns4__getMarketPrices
#define SOAP_TYPE___ns4__getMarketPrices (880)
/* Operation wrapper: */
struct __ns4__getMarketPrices
{
public:
	_ns4__getMarketPrices *ns4__getMarketPrices;	/* optional element of type ns4:getMarketPrices */
};
#endif

#ifndef SOAP_TYPE___ns4__getCompleteMarketPricesCompressed
#define SOAP_TYPE___ns4__getCompleteMarketPricesCompressed (884)
/* Operation wrapper: */
struct __ns4__getCompleteMarketPricesCompressed
{
public:
	_ns4__getCompleteMarketPricesCompressed *ns4__getCompleteMarketPricesCompressed;	/* optional element of type ns4:getCompleteMarketPricesCompressed */
};
#endif

#ifndef SOAP_TYPE___ns4__getMarketTradedVolumeCompressed
#define SOAP_TYPE___ns4__getMarketTradedVolumeCompressed (888)
/* Operation wrapper: */
struct __ns4__getMarketTradedVolumeCompressed
{
public:
	_ns4__getMarketTradedVolumeCompressed *ns4__getMarketTradedVolumeCompressed;	/* optional element of type ns4:getMarketTradedVolumeCompressed */
};
#endif

#ifndef SOAP_TYPE___ns4__getMarketPricesCompressed
#define SOAP_TYPE___ns4__getMarketPricesCompressed (892)
/* Operation wrapper: */
struct __ns4__getMarketPricesCompressed
{
public:
	_ns4__getMarketPricesCompressed *ns4__getMarketPricesCompressed;	/* optional element of type ns4:getMarketPricesCompressed */
};
#endif

#ifndef SOAP_TYPE___ns4__getAllMarkets
#define SOAP_TYPE___ns4__getAllMarkets (896)
/* Operation wrapper: */
struct __ns4__getAllMarkets
{
public:
	_ns4__getAllMarkets *ns4__getAllMarkets;	/* optional element of type ns4:getAllMarkets */
};
#endif

#ifndef SOAP_TYPE___ns4__getInPlayMarkets
#define SOAP_TYPE___ns4__getInPlayMarkets (900)
/* Operation wrapper: */
struct __ns4__getInPlayMarkets
{
public:
	_ns4__getInPlayMarkets *ns4__getInPlayMarkets;	/* optional element of type ns4:getInPlayMarkets */
};
#endif

#ifndef SOAP_TYPE___ns4__getPrivateMarkets
#define SOAP_TYPE___ns4__getPrivateMarkets (904)
/* Operation wrapper: */
struct __ns4__getPrivateMarkets
{
public:
	_ns4__getPrivateMarkets *ns4__getPrivateMarkets;	/* optional element of type ns4:getPrivateMarkets */
};
#endif

#ifndef SOAP_TYPE___ns4__getCurrentBets
#define SOAP_TYPE___ns4__getCurrentBets (908)
/* Operation wrapper: */
struct __ns4__getCurrentBets
{
public:
	_ns4__getCurrentBets *ns4__getCurrentBets;	/* optional element of type ns4:getCurrentBets */
};
#endif

#ifndef SOAP_TYPE___ns4__getCoupon
#define SOAP_TYPE___ns4__getCoupon (912)
/* Operation wrapper: */
struct __ns4__getCoupon
{
public:
	_ns4__getCoupon *ns4__getCoupon;	/* optional element of type ns4:getCoupon */
};
#endif

#ifndef SOAP_TYPE___ns4__getCurrentBetsLite
#define SOAP_TYPE___ns4__getCurrentBetsLite (916)
/* Operation wrapper: */
struct __ns4__getCurrentBetsLite
{
public:
	_ns4__getCurrentBetsLite *ns4__getCurrentBetsLite;	/* optional element of type ns4:getCurrentBetsLite */
};
#endif

#ifndef SOAP_TYPE___ns4__getMUBets
#define SOAP_TYPE___ns4__getMUBets (920)
/* Operation wrapper: */
struct __ns4__getMUBets
{
public:
	_ns4__getMUBets *ns4__getMUBets;	/* optional element of type ns4:getMUBets */
};
#endif

#ifndef SOAP_TYPE___ns4__getMUBetsLite
#define SOAP_TYPE___ns4__getMUBetsLite (924)
/* Operation wrapper: */
struct __ns4__getMUBetsLite
{
public:
	_ns4__getMUBetsLite *ns4__getMUBetsLite;	/* optional element of type ns4:getMUBetsLite */
};
#endif

#ifndef SOAP_TYPE___ns4__getDetailAvailableMktDepth
#define SOAP_TYPE___ns4__getDetailAvailableMktDepth (928)
/* Operation wrapper: */
struct __ns4__getDetailAvailableMktDepth
{
public:
	_ns4__getDetailAvailableMktDepth *ns4__getDetailAvailableMktDepth;	/* optional element of type ns4:getDetailAvailableMktDepth */
};
#endif

#ifndef SOAP_TYPE___ns4__getMarketTradedVolume
#define SOAP_TYPE___ns4__getMarketTradedVolume (932)
/* Operation wrapper: */
struct __ns4__getMarketTradedVolume
{
public:
	_ns4__getMarketTradedVolume *ns4__getMarketTradedVolume;	/* optional element of type ns4:getMarketTradedVolume */
};
#endif

#ifndef SOAP_TYPE___ns4__getBetHistory
#define SOAP_TYPE___ns4__getBetHistory (936)
/* Operation wrapper: */
struct __ns4__getBetHistory
{
public:
	_ns4__getBetHistory *ns4__getBetHistory;	/* optional element of type ns4:getBetHistory */
};
#endif

#ifndef SOAP_TYPE___ns4__getAccountStatement
#define SOAP_TYPE___ns4__getAccountStatement (940)
/* Operation wrapper: */
struct __ns4__getAccountStatement
{
public:
	_ns4__getAccountStatement *ns4__getAccountStatement;	/* optional element of type ns4:getAccountStatement */
};
#endif

#ifndef SOAP_TYPE___ns4__getMarketProfitAndLoss
#define SOAP_TYPE___ns4__getMarketProfitAndLoss (944)
/* Operation wrapper: */
struct __ns4__getMarketProfitAndLoss
{
public:
	_ns4__getMarketProfitAndLoss *ns4__getMarketProfitAndLoss;	/* optional element of type ns4:getMarketProfitAndLoss */
};
#endif

#ifndef SOAP_TYPE___ns4__getBet
#define SOAP_TYPE___ns4__getBet (948)
/* Operation wrapper: */
struct __ns4__getBet
{
public:
	_ns4__getBet *ns4__getBet;	/* optional element of type ns4:getBet */
};
#endif

#ifndef SOAP_TYPE___ns4__getBetLite
#define SOAP_TYPE___ns4__getBetLite (952)
/* Operation wrapper: */
struct __ns4__getBetLite
{
public:
	_ns4__getBetLite *ns4__getBetLite;	/* optional element of type ns4:getBetLite */
};
#endif

#ifndef SOAP_TYPE___ns4__getBetMatchesLite
#define SOAP_TYPE___ns4__getBetMatchesLite (956)
/* Operation wrapper: */
struct __ns4__getBetMatchesLite
{
public:
	_ns4__getBetMatchesLite *ns4__getBetMatchesLite;	/* optional element of type ns4:getBetMatchesLite */
};
#endif

#ifndef SOAP_TYPE___ns4__getSilks
#define SOAP_TYPE___ns4__getSilks (960)
/* Operation wrapper: */
struct __ns4__getSilks
{
public:
	_ns4__getSilks *ns4__getSilks;	/* optional element of type ns4:getSilks */
};
#endif

#ifndef SOAP_TYPE___ns4__getSilksV2
#define SOAP_TYPE___ns4__getSilksV2 (964)
/* Operation wrapper: */
struct __ns4__getSilksV2
{
public:
	_ns4__getSilksV2 *ns4__getSilksV2;	/* optional element of type ns4:getSilksV2 */
};
#endif

#ifndef SOAP_TYPE___ns4__heartbeat
#define SOAP_TYPE___ns4__heartbeat (968)
/* Operation wrapper: */
struct __ns4__heartbeat
{
public:
	_ns4__heartbeat *ns4__heartbeat;	/* optional element of type ns4:heartbeat */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (969)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (970)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (972)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (975)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (976)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
